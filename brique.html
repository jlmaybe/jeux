<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>BRICK BLITZ ELYSIUM</title>
  <link href="https://fonts.googleapis.com/css?family=Press+Start+2P" rel="stylesheet">
  <style>



  /* ✅ OPTIMISATION POUR NOUVELLE FENÊTRE */
  {
    margin: 0 !important;
    padding: 0 !important;
    box-sizing: border-box;
  }

  html, body {
    margin: 5;
    padding: 5;
    background: #000;
    overflow: hidden; /* ✅ DÉSACTIVE COMPLÈTEMENT L'ASCENSEUR */
    height: 100vh; /* ✅ HAUTEUR FIXE au lieu de min-height */
  }


  /* ✅ CONTENEUR PRINCIPAL CENTRÉ */
  body {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      height: 100vh; /* ✅ CHANGÉ : hauteur exacte sans dépassement */
      padding: 5; /* ✅ SUPPRIMÉ : plus de padding qui crée des marges */
      margin: 5; /* ✅ AJOUT : supprime les marges par défaut */
      max-width: 100vw;
      overflow: hidden; /* ✅ COHÉRENT : pas de scroll */
  }


  /* === AJUSTEMENT DU TITRE === */
  #title {
      font-family: 'Press Start 2P', monospace;
      font-size: 2.5em;
      letter-spacing: 0.2em;
      text-shadow: 0 0 15px #0ff, 0 0 40px #ff0, 0 0 150px #f0f;
      margin-top: 0; /* ✅ CHANGÉ : de -10px à 0 */
      padding: 0 0 10px 0; /* ✅ CHANGÉ : supprime le padding du haut, garde un peu en bas */
      font-weight: bold;
      filter: brightness(1.4);
      text-align: center;
      width: 100%;
      position: relative;
      left: 0;
      top: 0;
      transform: none;
      pointer-events: none;
      user-select: none;
      z-index: 20;
      white-space: nowrap;
      overflow: hidden;
  }



  /* === AJUSTEMENT DU HUD === */
  #hud {
      position: relative;
      left: 50%; /* ✅ NOUVEAU : Position au centre */
      top: 0;
      transform: translateX(-50%); /* ✅ NOUVEAU : Correction du centrage exact */
      width: 100%;
      max-width: 1140px;
      margin: 10px 0; /* ✅ CHANGÉ : margin vertical seulement, pas de centrage auto */
      text-align: center;
      font-family: 'Press Start 2P', monospace;
      color: #fff;
      pointer-events: none;
      z-index: 10;
      user-select: none;
      background: linear-gradient(260deg, #0ff 0%, #f0f 50%, #ff0 100%);
      box-shadow: 0 0 20px #0ff, 0 0 40px #f0f;
      border-radius: 12px;
      padding: 8px 0 6px 0;
  }



  /* ✅ CORRECTION : Ajouter #cookies au sélecteur */
  #score, #vies, #niveau, #mult, #cookies {
    font-family: 'Press Start 2P', monospace;
    font-size:1.1em;
    margin:0 30px;
    display:inline-block;
    text-shadow:0 0 9px #0ff, 0 0 9px #f0f;
    text-align: right;
    vertical-align:top;
    color: #fff;
    letter-spacing: 2px;
    transition: filter 0.2s, font-size 0.15s, color 0.15s;
  }

    #score.flash, #mult.flash {
      font-family: 'Press Start 2P', monospace;
      filter: brightness(1) drop-shadow(0 0 15px #ff0);
      /* ✅ SUPPRIMÉ : font-size:1.3em; pour éviter le redimensionnement */
      color: #ff0;
      /* ✅ NOUVEAU : Effet visuel alternatif sans changement de taille */
      text-shadow:
        0 0 24px #ff0,
        0 0 36px #fef,
        0 0 48px #fff;
      transform: scale(1.2); /* ✅ Légère mise à l'échelle qui n'affecte pas le layout */
      transform-origin: center center;
    }


    #bonus-anim {
      font-family: 'Press Start 2P', monospace;
      position:absolute; left:50%; top:50%; font-size:20px;
      pointer-events:none; opacity:0; transform:translate(-50%,-50%) scale(1.2);
      text-shadow:0 0 32px #fff, 0 0 64px #f0f, 0 0 128px #0ff;
      transition:opacity 0.4s, transform 0.4s;
      z-index:100;
    }
    #decrement-timer {

      position: absolute;
      left: 0; right: 0;
      font-family: 'Press Start 2P', monospace;
      font-size: 1em;
      color: #ff4444;
      text-shadow: 0 0 12px #fff, 0 0 24px #f00;
      z-index: 50;
      pointer-events: none;
      user-select: none;
      display: none;
      background: rgba(0,0,0,0.7);
      padding: 4px 10px;
      border-radius: 8px;
      text-align: center;
      top: 0;
    }

    /* === CONTAINER DE COUPLAGE GAMECANVAS + STATSPANEL === */
    .game-canvas-container {
      display: flex;
      align-items: flex-start; /* Alignement parfait en hauteur */
      gap: 15px; /* ✅ EXACTEMENT 15px entre canvas et panel */
      justify-content: center;
      position: relative;
      margin: 20px auto 0; /* Centrage et marge supérieure */
      width: fit-content; /* S'adapte au contenu */
    }

    /* === GAMECANVAS DANS LE CONTAINER === */
    #gameCanvas {
      display: block;
      margin: 0; /* ✅ SUPPRIMÉ : tous les margins/positions manuels */
      background: #111;
      box-shadow: 0 0 40px #0ff, 0 0 80px #f0f;
      border-radius: 12px;
      /* ✅ SUPPRIMÉ : position, left, top - maintenant géré par flex */
      flex-shrink: 0; /* Empêche la compression */
      cursor: none !important;
    }

    /* === STATSPANEL COUPLÉ AU CANVAS === */
    /* === STATSPANEL COUPLÉ AU CANVAS === */
    #statsPanel {
        /* ✅ CORRECTION MAJEURE : Position relative pour permettre le positionnement absolu du copyright */
        position: relative !important;

        /* ✅ DIMENSIONS IDENTIQUES AU CANVAS */
        width: 250px !important;
        height: 900px !important;
        max-height: 900px !important;
        min-height: 900px !important;

        /* ✅ STYLES VISUELS CONSERVÉS */
        background: #111;
        box-shadow: 0 0 40px #0ff, 0 0 80px #f0f;
        border-radius: 12px;
        z-index: 5;
        overflow-y: auto;
        overflow-x: hidden;
        box-sizing: border-box !important;

        /* ✅ FLEX : Pas de compression ni d'expansion */
        flex-shrink: 0;
        flex-grow: 0;
    }

    #bonusPanel {
      font-family: 'Press Start 2P', monospace;
      position: fixed;
      top: 52%;
      left: 50%;
      transform: translate(-50%, -50%);
      /* ✅ DIMENSIONS FIXES DE RÉFÉRENCE (comme le game-main-container) */
      width: 650px;
      height: 850px;

      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 2000;

      font-size: 0.8rem;
      box-sizing: border-box;
      overflow: hidden;

      /* ✅ STYLES VISUELS CONSERVÉS */
      border-radius: 18px;
      box-shadow:
        0 0 40px rgba(0, 255, 255, 0.8),
        0 0 80px rgba(255, 0, 255, 0.6),
        0 0 120px rgba(255, 255, 0, 0.4),
        inset 0 0 30px rgba(0, 255, 255, 0.2);
    }


  /* ✅ ARRIÈRE-PLAN AVEC PULSATION VISIBLE */
  #bonusPanel::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    z-index: -1;

    Background: rgba(0, 0, 0, 0.40);
    border-radius: 18px;

    box-shadow:
      0 0 60px rgba(0, 255, 255, 1),
      0 0 120px rgba(255, 0, 255, 0.8),
      0 0 180px rgba(255, 255, 0, 0.6);

    animation: haloStaticPulse 2s ease-in-out infinite alternate;
  }

  /* ✅ HALO EXTERNE ROTATIF ULTRA-VISIBLE */
  #bonusPanel::after {
    content: '';
    position: absolute;
    top: -20px;
    left: -20px;
    right: -20px;
    bottom: -20px;
    z-index: -2;

    /* ✅ NOUVEAU : Gradient en forme de rayons pour rotation visible */
    background: conic-gradient(
      from 0deg,
      rgba(0, 255, 255, 1) 0%,     /* Cyan intense - rayon 1 */
      transparent 5%,
      rgba(255, 0, 255, 1) 15%,    /* Magenta intense - rayon 2 */
      transparent 20%,
      rgba(255, 255, 0, 1) 30%,    /* Jaune intense - rayon 3 */
      transparent 35%,
      rgba(0, 255, 0, 1) 45%,      /* Vert intense - rayon 4 */
      transparent 50%,
      rgba(255, 165, 0, 1) 60%,    /* Orange intense - rayon 5 */
      transparent 65%,
      rgba(138, 43, 226, 1) 75%,   /* Violet intense - rayon 6 */
      transparent 80%,
      rgba(0, 255, 255, 1) 90%,    /* Retour cyan - rayon 7 */
      transparent 95%,
      rgba(255, 0, 255, 1) 100%    /* Magenta final - rayon 8 */
    );

    border-radius: 35px;

    /* ✅ ANIMATION PLUS RAPIDE ET VISIBLE */
    animation: haloRotate 3s linear infinite;

    /* ✅ BLUR RÉDUIT pour voir la rotation */
    filter: blur(6px);
  }

  /* ✅ ANIMATIONS OPTIMISÉES POUR LA VISIBILITÉ */
  @keyframes haloRotate {
    0% {
      transform: rotate(0deg) scale(1);
      filter: blur(6px);
    }
    25% {
      transform: rotate(90deg) scale(1.03);
      filter: blur(4px);
    }
    50% {
      transform: rotate(180deg) scale(1);
      filter: blur(6px);
    }
    75% {
      transform: rotate(270deg) scale(1.03);
      filter: blur(4px);
    }
    100% {
      transform: rotate(360deg) scale(1);
      filter: blur(6px);
    }
  }

  @keyframes haloStaticPulse {
    0% {
      opacity: 0.8;
      transform: scale(0.98);
      box-shadow:
        0 0 60px rgba(0, 255, 255, 1),
        0 0 120px rgba(255, 0, 255, 0.8),
        0 0 180px rgba(255, 255, 0, 0.6);
    }
    50% {
      opacity: 1;
      transform: scale(1.02);
      box-shadow:
        0 0 80px rgba(0, 255, 255, 1),
        0 0 160px rgba(255, 0, 255, 1),
        0 0 240px rgba(255, 255, 0, 0.8);
    }
    100% {
      opacity: 0.9;
      transform: scale(1);
      box-shadow:
        0 0 70px rgba(0, 255, 255, 1),
        0 0 140px rgba(255, 0, 255, 0.9),
        0 0 210px rgba(255, 255, 0, 0.7);
    }
  }

  /* ✅ EFFET HOVER RENFORCÉ */
  #bonusPanel:hover::before {
    animation-duration: 1s; /* Pulsation plus rapide au survol */
    background: rgba(0, 0, 0, 0.9);
  }

  #bonusPanel:hover::after {
    animation-duration: 1.5s; /* Rotation plus rapide au survol */
    filter: blur(3px); /* Halo plus net */
    transform: scale(0.70); /* Légèrement plus grand */
  }

  #bonusPanel:hover {
    box-shadow:
      0 0 80px rgba(0, 255, 255, 1),
      0 0 160px rgba(255, 0, 255, 0.9),
      0 0 240px rgba(255, 255, 0, 0.8),
      inset 0 0 50px rgba(0, 255, 255, 0.4);
  }



/* === CONTAINER PRINCIPAL RESPONSIVE === */
.game-main-container {
  position: relative;
  width: 1200px;
  height: 1000px;
  margin: 0 auto;
  transform-origin: center top;
  transition: transform 0.3s ease;
  /* ✅ Le scale sera calculé dynamiquement par JavaScript */
}


    .bonus-panel-content {
      background: rgba(30, 40, 60, 0.75);
      color: #fff;
      border-radius: clamp(12px, 2vw, 18px);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.45);

      /* ✅ NOUVEAU : Padding responsive mais sans créer de débordement */
      padding: clamp(20px, 5vw, 40px) clamp(25px, 6vw, 45px) clamp(15px, 4vw, 35px) clamp(25px, 6vw, 45px);

      font-family: 'Press Start 2P', monospace;
      text-align: left;

      /* ✅ SUPPRIMÉ : overflow-y: auto pour éliminer l'ascenseur interne */
      /* ✅ SUPPRIMÉ : height: 100% qui forçait le scroll */
      width: 100%;
      max-width: 100%;

      /* ✅ NOUVEAU : Taille de police légèrement plus grande */
      font-size: clamp(0.6em, 1.8vw, 0.85em); /* ✅ AUGMENTÉ pour meilleure lisibilité */

      /* ✅ NOUVEAU : Espacement des lignes optimisé */
      line-height: clamp(1.4, 2vw, 1.8);
      box-sizing: border-box;

      /* ✅ NOUVEAU : Disposition naturelle sans contrainte de hauteur */
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
    }

    /* Animation de clignotement générique et réutilisable */
    .blinking-effect {
      animation: blink-animation 1s step-end infinite;
    }
    @keyframes blink-animation {
      50% {
        opacity: 0;
      }
    }


    /* ✅ NOUVEAU : Éléments internes responsive */
    /* ✅ NOUVEAU : Éléments internes optimisés pour la nouvelle taille */
  .bonus-panel-content h2 {
    text-align: center;
    color: #FFD700;
    margin-top: 0;
    margin-bottom: clamp(12px, 4vw, 25px); /* ✅ AUGMENTÉ proportionnellement */

    font-size: clamp(0.9em, 2.4vw, 1.3em); /* ✅ AUGMENTÉ : de 2vw à 2.4vw */
    letter-spacing: clamp(1px, 0.4vw, 3px); /* ✅ AUGMENTÉ */
    text-shadow: 1px 2px 0 #222;
  }

  .bonus-panel-content h3 {
    text-align: center;
    color: #FFE000;
    margin-top: 0;
    margin-bottom: clamp(10px, 2.5vw, 20px); /* ✅ AUGMENTÉ */

    font-size: clamp(0.4em, 1.2vw, 0.6em); /* ✅ AUGMENTÉ : de 1vw à 1.2vw */
    letter-spacing: clamp(1px, 0.25vw, 2.5px);
    text-shadow: 1px 5px 0 #122;
  }

  .bonus-panel-content ul {
    list-style: none;
    padding: 0;
    margin-bottom: clamp(15px, 4vw, 30px); /* ✅ AUGMENTÉ */
  }

  .bonus-panel-content li {
    margin-bottom: clamp(8px, 2vw, 16px); /* ✅ AUGMENTÉ : de 1.5vw à 2vw */
    display: flex;
    align-items: center;
    font-size: clamp(0.55em, 1.6vw, 0.95em); /* ✅ AUGMENTÉ : de 1.3vw à 1.6vw */
  }

  .bonus-emoji {
    font-size: clamp(1em, 2.4vw, 1.5em); /* ✅ AUGMENTÉ : de 2vw à 2.4vw */
    margin-right: clamp(10px, 2.5vw, 18px); /* ✅ AUGMENTÉ */
    filter: drop-shadow(0 0 6px #0ff);

    /* ✅ NOUVELLE TAILLE minimale */
    min-width: clamp(20px, 3.5vw, 30px); /* ✅ AUGMENTÉ */
    display: inline-block;
    text-align: center;
  }

  #closeBonusPanel {
    display: block;
    margin: clamp(8px, 2.5vw, 15px) auto 0; /* ✅ AUGMENTÉ */
    padding: clamp(10px, 2.5vw, 16px) clamp(25px, 6vw, 45px); /* ✅ AUGMENTÉ */

    background: linear-gradient(90deg, #FFD700 45%, #FF6F00 100%);
    color: #222;
    border: none;
    border-radius: clamp(8px, 2vw, 12px); /* ✅ AUGMENTÉ */

    font-family: 'Press Start 2P', monospace;
    font-size: clamp(0.7em, 1.8vw, 1.2em); /* ✅ AUGMENTÉ : de 1.5vw à 1.8vw */
    letter-spacing: clamp(1px, 0.4vw, 2.5px);
    cursor: pointer;

    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
    transition: background 0.2s, transform 0.1s;
  }

  #closeBonusPanel:hover {
    background: linear-gradient(90deg, #FFEC80 45%, #FF9F00 100%);
    transform: scale(clamp(1.03, 1.08, 1.12)); /* ✅ AUGMENTÉ : hover plus marqué */
  }

    /* Panneau de fin */
    #endPanel {
      font-family: 'Press Start 2P', monospace;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);

      /* ✅ DIMENSIONS FIXES DE RÉFÉRENCE (comme les autres panneaux) */
      width: 900px;
      height: 700px;

      display: none; /* Caché par défaut */
      align-items: center;
      justify-content: center;
      flex-direction: column;
      z-index: 3000;

      /* ✅ STYLES VISUELS CONSERVÉS */
      background: rgba(0,0,0,0.94);
      border-radius: 15px;
      box-shadow: 0 0 50px rgba(0, 255, 255, 0.3);
      border: 2px solid rgba(255, 255, 255, 0.1);
      overflow: hidden;
      box-sizing: border-box;
    }

    /* ✅ SUPPRIME TOUS LES @media DU END PANEL ! */

    #endPanel .score-final {
      color:#FFD700;
      font-size: clamp(1.8em, 3vw, 2.2em); /* ✅ RÉDUIT ET RESPONSIVE */
      text-shadow:0 0 25px #ff0,0 0 50px #f0f; /* ✅ RÉDUIT */
      margin-bottom: clamp(14px, 2.5vw, 18px); /* ✅ RESPONSIVE */
      text-align:center;
    }

    #endPanel .stat {
      color:#fff;
      font-size: clamp(0.9em, 1.5vw, 1em); /* ✅ RÉDUIT ET RESPONSIVE */
      margin-bottom: clamp(12px, 2vw, 14px); /* ✅ RESPONSIVE */
      text-align:center;
      line-height: 1.4; /* ✅ NOUVEAU : Meilleur espacement */
    }

    #endPanel .best-score {
      color:#FFD700;
      font-size: clamp(0.9em, 1.5vw, 1em); /* ✅ RÉDUIT ET RESPONSIVE */
      margin-bottom: clamp(14px, 2.5vw, 16px); /* ✅ RESPONSIVE */
      text-align:center;
    }

    #endPanel button {
      padding: clamp(10px, 2vw, 12px) clamp(30px, 5vw, 35px); /* ✅ RESPONSIVE */
      font-size: clamp(0.9em, 1.4vw, 1em); /* ✅ RÉDUIT ET RESPONSIVE */
      border-radius: clamp(7px, 1.5vw, 9px); /* ✅ RESPONSIVE */
      background:linear-gradient(90deg,#FFD700 45%,#FF6F00 100%);
      border:none;
      color:#222;
      font-family:'Press Start 2P',monospace;
      margin-top: clamp(12px, 2.5vw, 16px); /* ✅ RESPONSIVE */
      cursor:pointer;
      transition: transform 0.1s ease; /* ✅ NOUVEAU : Animation hover */
    }

    #endPanel button:hover {
      background: linear-gradient(90deg, #FFEC80 45%, #FF9F00 100%);
      transform: scale(1.05); /* ✅ EFFET HOVER AJUSTÉ */
    }

    /* ✅ NOUVEAU : Ajustements pour le leaderboard dans endPanel */
    #leaderboardSection {
      max-height: clamp(350px, 60vh, 450px) !important; /* ✅ HAUTEUR RESPONSIVE */
      overflow: hidden !important; /* ✅ COHÉRENT avec les autres panneaux */
      margin-top: clamp(15px, 3vw, 20px); /* ✅ MARGE RESPONSIVE */
    }

    #leaderboardList table {
      font-size: clamp(0.6em, 1.2vw, 0.8em) !important; /* ✅ TAILLE AJUSTÉE */
      line-height: 1.3 !important; /* ✅ ESPACEMENT OPTIMISÉ */
    }

    #leaderboardList td {
      padding: clamp(6px, 1.5vw, 8px) clamp(3px, 1vw, 4px) !important; /* ✅ PADDING RESPONSIVE */
    }

    /* ✅ NOUVEAU : Ajustements pour la saisie du nom */
    #playerNameSection input {
      font-size: clamp(0.9em, 1.4vw, 1em) !important; /* ✅ TAILLE AJUSTÉE */
      padding: clamp(8px, 1.5vw, 10px) !important; /* ✅ PADDING RESPONSIVE */
      width: clamp(160px, 25vw, 200px) !important; /* ✅ LARGEUR RESPONSIVE */
    }

    #playerNameSection button {
      font-size: clamp(0.8em, 1.2vw, 0.9em) !important; /* ✅ BOUTONS PLUS PETITS */
      padding: clamp(8px, 1.5vw, 10px) clamp(15px, 3vw, 20px) !important; /* ✅ PADDING AJUSTÉ */
    }

    #psyCanvas {
      position: absolute;
      top: 0; left: 0; width: 100%; height: 100%;
      z-index: 1;
      pointer-events: none;
    }

    #autopilot-status {
      display: none; /* Caché par défaut */
      font-family: 'Press Start 2P', monospace;
      font-size: 1.1em; /* Même taille que le score */
      margin-left: 25px; /* Espace par rapport au score */

      color: #0ff; /* Couleur cyan, pour un look "high-tech" */
      text-shadow: 0 0 8px #0ff, 0 0 16px #0ff, 0 0 24px #fff;

      /* Animation de clignotement */
      animation: blink-effect 1s step-end infinite;
    }

    /* Définition de l'animation de clignotement */
    @keyframes blink-effect {
      50% {
        opacity: 0;
      }
    }

    #psyOverlay {
      position: relative;
      z-index: 2;
      width: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
    }


    .stats-panel-content {
      padding: 20px 15px;
      font-family: 'Press Start 2P', monospace;
      color: #fff;
      font-size: 0.7em;
    }

    .stats-panel-content h3 {
      text-align: center;
      color: #FFD700;
      margin: 0 0 20px 0;
      font-size: 1.1em;
      letter-spacing: 2px;
      text-shadow: 0 0 10px #FFD700;
    }

    .stats-section {
      margin-bottom: 20px;
      border-bottom: 1px solid rgba(0, 255, 255, 0.3);
      padding-bottom: 15px;
    }

    .stats-section:last-child {
      border-bottom: none;
    }

    .stats-section h4 {
      color: #0ff;
      margin: 0 0 10px 0;
      font-size: 0.8em;
      text-shadow: 0 0 8px #0ff;
      letter-spacing: 1px;
    }

    .stats-item {
      display: flex;
      justify-content: space-between;
      margin-bottom: 5px;
      font-size: 0.75em;
    }

    .stats-item-label {
      color: #fff;
      flex: 1;
    }

    .stats-item-value {
      color: #ff0;
      font-weight: bold;
      text-shadow: 0 0 6px #ff0;
    }

    .stats-emoji {
      font-family: 'Apple Color Emoji', 'Segoe UI Emoji', 'Noto Color Emoji', monospace;
      margin-right: 8px;
      filter: drop-shadow(0 0 4px #0ff);
    }

    /* ✅ NOUVEAU : Styles copyright corrigés pour le bas du panneau stats */
    .copyright-line {
        position: absolute !important; /* ✅ FORCE le positionnement absolu */
        bottom: 5px !important;        /* ✅ TOUT EN BAS du panneau */
        left: 0;
        right: 0;

        font-family: 'Courier New', monospace;
        font-size: 8px;                /* ✅ Taille réduite comme demandé */
        color: #555;
        text-shadow: 1px 1px 0px rgba(0,0,0,0.6);
        background: rgba(0,0,0,0.1);
        border-top: 1px solid rgba(255,255,255,0.05);

        text-align: center;
        line-height: 1.2;
        padding: 3px 0;
        margin: 0;
        z-index: 100;                  /* ✅ Au-dessus de tout */
        white-space: nowrap;
    }

    .copyright-line:hover {
        color: #777;
        background: rgba(0,0,0,0.2);
        transition: all 0.2s ease;
    }

    /* ✅ S'assurer que le panneau stats ait assez d'espace */
    .stats-panel-content {
        padding-bottom: 25px; /* ✅ Espace pour le copyright */
    }

    /* Indicateur de danger pour les skulls */
    .danger-indicator {
      color: #f44 !important;
      animation: dangerBlink 1s infinite;
    }

    @keyframes dangerBlink {
      0%, 50% { opacity: 1; }
      51%, 100% { opacity: 0.3; }
    }

    /* Indicateur positif pour les multiplicateurs */
    .positive-indicator {
      color: #0f0 !important;
      text-shadow: 0 0 8px #0f0 !important;
    }

    .flashy-score {
      color: #ff0; /* Jaune vif par défaut */
      color: #FFD700;
      text-shadow: 0 0 10px #0ff, 0 0 20px #f0f, 0 0 40px #ff0, 0 0 80px #f0f;
      font-weight: bold;
      animation: flashyColor 0.5s infinite alternate;
    }

    @keyframes flashyColor {
      0%   { color: #ff0; text-shadow: 0 0 10px #0ff, 0 0 40px #f0f; }
      25%  { color: #0ff; text-shadow: 0 0 10px #ff0, 0 0 40px #f0f; }
      50%  { color: #f0f; text-shadow: 0 0 10px #ff0, 0 0 40px #0ff; }
      75%  { color: #ff00cc; text-shadow: 0 0 10px #ff0, 0 0 40px #0ff; }
      100% { color: #ff0; text-shadow: 0 0 10px #0ff, 0 0 40px #f0f; }
    }
    /* Style du bandeau d'alerte pour l'autopilote */
    #autopilot-banner {
      display: none; /* Caché par défaut */
      position: absolute;
      left: 45%;
      top: 35%;
      transform: translate(-50%, -50%);
      padding: 12px 30px;

      font-family: 'Press Start 2P', monospace;
      font-size: 1em; /* Grande taille pour être bien visible */
      color: #FFD700; /* Couleur or, classique */

      background: rgba(20, 10, 40, 0.65); /* Fond plus transparent (0.85 -> 0.65) */
        border: 4px solid rgba(255, 0, 255, 0.5); /* Bordure plus transparente */
        border-radius: 12px;
        box-shadow: 0 0 20px rgba(255, 0, 255, 0.5), /* Ombres externes plus douces */

      text-align: center;
      text-shadow: 0 0 10px #ff0, 0 0 20px #f0f;
      white-space: nowrap; /* Empêche le texte de passer à la ligne */
      z-index: 0; /* S'assure qu'il est au-dessus du jeu */

      user-select: none; /* Empêche la sélection du texte */
      pointer-events: none; /* Permet aux clics de passer à travers */
    }

    /* Animation de "flash" pour attirer l'attention */
    #autopilot-banner.flash {
      animation: banner-flash 0.3s ease-in-out;
    }

    @keyframes banner-flash {
      0%   { transform: translate(-50%, -50%) scale(1.05); filter: brightness(1.5); }
      100% { transform: translate(-50%, -50%) scale(1); filter: brightness(1); }
    }

  </style>
</head>

<body>
  <!-- ✅ NOUVEAU : Container principal scalable -->
  <div class="game-main-container">
    <div id="title">BRICK BLITZ ELYSIUM</div>

    <div id="hud">
      <span id="vies">VIE(S):3</span>
      <span id="cookies">COOKIE(S):0</span>
      <span id="niveau">NIVEAU(X):1</span>
      <span id="mult">x1</span>
      <span id="score">000000000</span>
      <span id="autopilot-status">AUTOPILOT</span>
    </div>

    <div id="bonus-anim"></div>
    <div id="decrement-timer"></div>

    <!-- ✅ NOUVEAU : Container de couplage Canvas + StatsPanel -->
    <div class="game-canvas-container">
      <canvas id="gameCanvas" width="875" height="900"></canvas>

      <div id="statsPanel">
        <div class="stats-panel-content">
          <h3>STATISTIQUES</h3>

          <div class="stats-section">
            <h4>BRIQUES</h4>
            <div id="bricksStats"></div>
          </div>

          <div class="stats-section">
            <h4>BONUS</h4>
            <div id="bonusesStats"></div>
          </div>

          <div class="stats-section">
            <h4>POWER-UPS</h4>
            <div id="powerupsStats"></div>
          </div>

          <div class="stats-section">
            <h4>ÉTAT DU JEU</h4>
            <div id="gameStateStats"></div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- ✅ FIN du container principal scalable -->

  <!-- ✅ Éléments qui restent HORS du scaling -->
  <div id="autopilot-banner"></div>

  <!-- Panneau d'explication des bonus -->
  <div id="bonusPanel">
    <div class="bonus-panel-content">
      <h2>BONUS</h2>
      <ul>
        <li><span class="bonus-emoji">🍒 🍌 🍇 🌸</span> <b>500 pts Petit bonus de score</li>
        <li><span class="bonus-emoji">🍓</span> <b>1000 pts Bonus de score</li>
        <li><span class="bonus-emoji">🐲</span> <b>1500 pts Bonus fleuri</li>
        <li><span class="bonus-emoji">🛸 🍉</span> <b>2000 pts Super bonus</li>
        <li><span class="bonus-emoji">🍑</span> <b>5000 pts Méga bonus</li>
        <li><span class="bonus-emoji">💝</span> <b>8000 pts Bonus de score</li>
        <li><span class="bonus-emoji">🇫🇷</span> <b>10000 pts Méga bonus</li>
        <li><span class="bonus-emoji">💊</span> <b>15000 pts Méga bonus</li>
        <h2>POWER-UPS</h2>
        <li><span class="bonus-emoji">️↔️</span> <b>Raquette longue</b> <span class="bonus-emoji">🏴‍☠️</span> <b>Raquette courte</b> <span class="bonus-emoji">❤️‍🔥</span> <b>Raquette géante</b></li>
        <li><span class="bonus-emoji">1️⃣ 2️⃣ 4️⃣ 6️⃣ </span> <b>Multiplicateurs de score pendant 30s</li>
        <li><span class="bonus-emoji">️🦁</span> <b>Multiplicateur à vie</li>
        <li><span class="bonus-emoji">🍭</span> <b>MultiTimer +60s Multiplicateur, MaxMultiplier dévérouillé</li>
        <li><span class="bonus-emoji">🍪</span> <b>Cookies  Bouton autopilot</li>
        <li><span class="bonus-emoji">🇵🇸</span> <b>Cookies  x2</li>
        <li><span class="bonus-emoji">🌈</span> <b>Vie      Une vie</li>
        <li><span class="bonus-emoji">🏖️</span> <b>Niveau   Niveau suivant</li>


        <li><span class="bonus-emoji">☠️</span>  <b>Malus    Score en décrémentation pendant 30s</li>
      </ul>
      <h2>ACTIONS</h2>
      <li><span class="bonus-emoji">M</span>Bouton panique  <span class="bonus-emoji">P</span>Pause <span class="bonus-emoji">S</span>Son Marche/Arrêt</li>
      <ul>
      <button id="closeBonusPanel">OK</button>
    </div>
  </div>

  <!-- Panneau de fin de partie -->
  <div id="endPanel">
    <canvas id="psyCanvas"></canvas>
    <div id="psyOverlay">
      <div class="score-final" id="TITRE"></div>
      <div class="score-final" id="finalScore"></div>

      <!-- ✅ NOUVEAU : Formulaire de saisie du nom -->
      <div id="playerNameSection" style="display: none;">
        <div style="color: #fff; font-size: 1.2em; margin: 20px 0; text-align: center;">
          🏆 NOUVEAU RECORD ! 🏆
        </div>
        <div style="color: #FFD700; font-size: 1em; margin-bottom: 15px; text-align: center;">
          Entrez votre nom :
        </div>
        <input type="text" id="playerNameInput" maxlength="12"
               style="padding: 10px; font-size: 1.1em; font-family: 'Press Start 2P', monospace;
                      text-align: center; background: #222; color: #fff; border: 2px solid #0ff;
                      border-radius: 5px; margin-bottom: 15px; width: 200px;"
               placeholder="JOUEUR">
        <br>
        <button id="saveScoreBtn" style="padding: 10px 20px; font-size: 1em;
                font-family: 'Press Start 2P', monospace; background: linear-gradient(90deg, #FFD700 45%, #FF6F00 100%);
                color: #222; border: none; border-radius: 5px; cursor: pointer; margin-right: 10px;">
          SAUVER
        </button>
        <button id="skipSaveBtn" style="padding: 10px 20px; font-size: 1em;
                font-family: 'Press Start 2P', monospace; background: #666;
                color: #fff; border: none; border-radius: 5px; cursor: pointer;">
          PASSER
        </button>
      </div>

      <!-- ✅ NOUVEAU : Tableau des meilleurs scores -->
      <div id="leaderboardSection" style="display: none; margin-top: 20px; max-height: 500px; overflow-y: auto;">
        <div style="color: #FFD700; font-size: 1.2em; margin-bottom: 15px; text-align: center;">
          🥇 TOP 10 🥇
        </div>
          <br>
        <div id="leaderboardList"></div>
        <br>  <br>
      </div>

      <div class="stat" id="levelsPassed"></div>
      <div class="stat" id="bricksHit"></div>
      <div class="stat" id="timePlayed"></div>
      <div class="stat" id="powerupDetails"></div>
      <div class="best-score" id="bestScore"></div>
      <button onclick="closeEndPanel()">OK</button>
    </div>
  </div>

</body>


  <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/@emailjs/browser@4/dist/email.min.js"></script>


  <script>

    // === CONSTANTES GLOBALES ===

    // ✅ NOUVEAU : Variable de version du jeu
    const GAME_VERSION = "🇫🇷 1.20";
    const COPYRIGHT_YEAR = "2025";
    const AUTHOR_NAME = "🇫🇷 Jean-Luc Faisans";

    const COLORS = ["#0ff", "#f0f", "#ff0", "#0f0", "#fff"];
    const BRICK_GRADIENTS = [
      ["#0ff", "#0cf"],
      ["#f0f", "#c0f"],
      ["#ff0", "#fc0"],
      ["#0f0", "#0c8"],
      ["#fff", "#aaa"]
    ];
//    const SPECIAL_ICONS = ["↔️️","🍭","🏴‍☠️","1️⃣","2️⃣","4️⃣","8️⃣","❤️‍🔥"];
    const SPECIAL_ICONS = ["↔️️","🍭","🏴‍☠️","1️⃣","2️⃣","4️⃣","❤️‍🔥","6️⃣"];

    const BONUS_ICONS = [
      {emoji:"🍒", points:500, color:"#f06"},
      {emoji:"🍓", points:1000, color:"#f44"},
      {emoji:"🛸", points:2000, color:"#0ff"},
      {emoji:"🍑", points:5000, color:"#fa8"},
      {emoji:"🌸", points:500, color:"#f9f"},
      {emoji:"💝", points:8000, color:"#f44"},
      {emoji:"🍉", points:2000, color:"#0ff"},
      {emoji:"🇫🇷", points:10000, color:"#0ff"},
      {emoji:"💊", points:15000, color:"#fa8"},
      {emoji:"🐲", points:15000, color:"#f9f"},
      {emoji:"🍇", points:2000, color:"#94f"},
      {emoji:"🍪", points:0, color:"#A67B5B", type:"cookie"},
      {emoji:"🇵🇸", points:0, color:"#A67B5B", type:"cookiex2"},
      {emoji:"🌈", points:0, color:"#A67B5B", type:"vie"},
      {emoji:"🏖", points:0, color:"#A67B5B", type:"niveau"},
      {emoji:"🦁", points:0, color:"#A67B5B", type:"XultX"},
      {emoji:"🍌", points:500, color:"#ff4"},
    ];



    const PERF_CONFIG = {
      enabled: true,               // Activer/désactiver l’adaptation
      measureIntervalFrames: 300,  // Nombre de frames entre deux mesures
      fpsThresholdDisable: 30,     // Seuil pour désactiver la galaxie
      fpsThresholdLow: 35,         // Basculer en qualité “low” sous ce FPS
    };



    const FONT = "Press Start 2P, monospace";
    const EMOJI_FONT = "'Apple Color Emoji', 'Segoe UI Emoji', 'Noto Color Emoji', 'Press Start 2P', monospace";
    const CANVAS_W = 875, CANVAS_H = 900;

    let vies = 4, niveau = 1, score = 0, displayScore = 0;
    let mult = 1, multTimer = 0, lastMult = 1;
    let bricks = [], particles = [], powerups = [], bonuses = [], animations = [];
    let brickCols = 14;
    let wallOffset = 50;
    let multX = 0;
    multX = loadMultX(); //Fin de variable multX
    let brickW = 61, brickH = 28; brickGap = 2;
    let paddleW = 150, paddleH = 18, paddleY = CANVAS_H-60;
    let paddleX = (CANVAS_W-paddleW)/2, paddleSpeed = 18;
    let isMouseCaptured = false;
    let perfLastTime = performance.now();
//    let MOVE_SPEED = 1000;
    let ballSpeed0 = 12; // IMPORTANT : avant son utilisation
    let LancementAutoPilote = 0;
    let brickRows = 7; //et autour de la ligne 700
    let isEndGame = false;
    let ball = null, ballSpeed = ballSpeed0, ballR = 13;
    let ballDX = 0, ballDY = 0;
    let leftDown = false, rightDown = false;
    let lastFrame = 0, gameOver = false, pause = false;
    let bonusAnimTimeout = null;
    let paddleHugeTimeout = null;
    let decrementTimer = 0;
    let decrementActive = false;
    let decrementEffect = false;
    let levelsPassed = 0;
    let paddleAcceleration = 0;
    const maxPaddleAcceleration = 15;   // Accélération maximale (ajuste selon le feeling)
    const paddleAccelerationStep = 1.02; // Vitesse d'accélération (ajuste selon le feeling)
    let paddleBaseW = 150; // Taille de base de la raquette
    let decrementStartTime = 0;
    let gameStarted = false;
    let autopilot = false;
    let aimingError = 0;      // AJOUT : Mémorise l'erreur de placement du coup précédent.
    let desiredPaddleX = 0;   // AJOUT : Stocke la position cible calculée par l'IA.
//    let AutopilotBanner = false
    let targetX = 0;
    let priority = 0;
    let movementType = 0;
    let dt = 0;
    let panic = false
    let PanicButon = false
    let cookies = 0;
    let wallOffsetPlus =0;
    let megaspeed=1
    let gameLoopId = null; // Ajouter en haut du fichier
    let longTimeout = null;
    let shortTimeout = null;
    let impactTimeout = null;
    let paddleVelocity = 0;
    let Debug = false;
    let skulls = [];
    let shotHistory = [];
    let lastTargetBrick = null;
    let lastPaddleTarget = 0;
    let paddleSizeEffect = null;
    let paddleOriginalSize = paddleBaseW;
    let dernierUtilisateur = null;
    let autopilotLock = { type: null, until: 0, targetX: 0 };
    let shotLock = { until: 0, target: null }; // verrou de tir
    let remaining = 0;
    let multiTMP = 0;
    multX = loadMultX();

    const MULTX_STORAGE_KEY = "ELYSIUM_multX";
      function loadMultX() {
        try {
          const raw = localStorage.getItem(MULTX_STORAGE_KEY);
          if (raw === null) return 0;
          const val = parseInt(raw, 10);
          if (!isFinite(val) || val < 0) return 0; // borne simple: pas de négatif
            return Math.min(val, 999); // sécurité: borne haute
          } catch (e) {
            console.warn("Impossible de charger multX:", e);
            return 0;
      }
    } //Fin de fonction loadMultX

    function saveMultX(value) {
      try {
        const v = Math.max(0, Math.min(999, parseInt(value, 10) || 0));
        localStorage.setItem(MULTX_STORAGE_KEY, String(v));
      } catch (e) {
        console.warn("Impossible d’enregistrer multX:", e);
      }
    } //Fin de fonction saveMultX

      // === VARIABLE DE SENSIBILITÉ SOURIS ===
    let mouseSensitivity = 1.50; // ✅ NOUVEAU : Facteur de démultiplication (1.8x plus sensible)
    let lastMouseX = null; // ✅ NOUVEAU : Position précédente de la souris pour calcul du delta
    //Fin de variables sensibilité souris

// === VARIABLES GALAXIE ÉVOLUTIVES ===
let galaxyParticles = [];
let galaxyTime = 0;
let galaxyCenter = { x: CANVAS_W/2, y: CANVAS_H/2 };
let galaxyRadius = 400;
let galaxyParticleCount = 150; // Nombre de pixels lumineux
let galaxyColorScheme = 2; // Schéma de couleur actuel (0-4)
let galaxySpacing = 1.5; // Multiplicateur d'espacement (0.7-1.5)
let galaxyRotationMode = 2; // Mode de rotation (0-2)
let reqX = 0;
let vv = false;
let ballDXballDX = 0;
let ballDXballDY = 0;
let multMax = 30 + multX;

const AIM = {
  active: false,
  targetX: 0,
  targetY: 0,
  impactRel: 0,
  until: 0
}; //Fin de variable AIM


// ✅ OPTIMISATION : Cache trigonométrique
let trigCache = {
    sin: new Array(360),
    cos: new Array(360),
    init() {
        for (let i = 0; i < 360; i++) {
            let rad = (i * Math.PI) / 180;
            this.sin[i] = Math.sin(rad);
            this.cos[i] = Math.cos(rad);
        }
    },
    getSin(angle) {
        return this.sin[Math.floor(angle * 180 / Math.PI) % 360];
    },
    getCos(angle) {
        return this.cos[Math.floor(angle * 180 / Math.PI) % 360];
    }
};
trigCache.init();

let MultTMP = 0;
let isBossLevel = false;
let boss = null;
let bossPhase = 1;
let bossMaxHP = 100;
let bossHP = 100;
let bossInvulnerable = false;
let bossAttackTimer = 0;
let bossMovementTimer = 0;
let bossDefeated = false;
let psyAnimId = null;
let emailSent = false; // Pour éviter les envois multiples
let gameSessionId = null; // ID unique de la session de jeu
let levelComplete = false;


// === SYSTÈME D'APPRENTISSAGE AUTOPILOTE ULTRA-EFFICACE ===

function getZoneDataSafe(zoneIndex) {
let z = Number.isInteger(zoneIndex) ? Math.max(0, Math.min(8, zoneIndex)) : null;
if (z === null) return null;

if (!Array.isArray(autopilotAI.zoneStats)) {
autopilotAI.zoneStats = new Array(9).fill().map(() => ({
attempts: 0, hits: 0, misses: 0, avgError: 0, correction: 0, confidence: 0.5
}));
}
if (!autopilotAI.zoneStats[z]) {
autopilotAI.zoneStats[z] = { attempts: 0, hits: 0, misses: 0, avgError: 0, correction: 0, confidence: 0.5 };
}
return autopilotAI.zoneStats[z];
} //Fin de fonction getZoneDataSafe


let autopilotAI = {
    // Historique des tirs par zone (9 zones = 3x3)
    zoneStats: new Array(9).fill().map(() => ({
        attempts: 0,
        hits: 0,
        misses: 0,
        avgError: 0,
        correction: 0,
        confidence: 0.5
    })),

    // Tir en cours
    currentShot: null,

    // Paramètres d'apprentissage
    learningRate: 0.25,

    // Historique récent (max 20 tirs)
    recentShots: [],

    // Vitesses de mouvement (petites saccades pour précision)
    speeds: {
    emergency: 1250,
    urgent: 1000,
    precise: 520,
    collect: 520
    } //Fin de propriété speeds
};


//let frameCount = 0;
//let lastPerformanceCheck = 0;

const EMAILJS_CONFIG = {
    publicKey: "S4SodZJrD9Ftqor5s",
    serviceId: "service_z3kyzle",
    templateId: "template_7x60gk8",
    toEmail: "jlmaybe1024@gmail.com", // ✅ AJOUT : Email de destination
    enabled: true // ✅ AJOUT : Possibilité de désactiver facilement
};

let totalBonusPoints = 0;
let gyroActive = false;
//let gyroSupported = false;
//let gyroPermission = false;
//let touchStartX = 0;
//let touchStartY = 0;
//let isTouching = false;
//let touchControlZone = null; // 'left', 'right', ou null

// === SYSTÈME DE QUALITÉ DYNAMIQUE ===
let renderQuality = "low"; // "high", "medium", "low"
//let performanceFrames = 0;
//let performanceStart = 0;

let baseGameSpeed = 12;
let currentGameSpeed = 12;
//let levelSpeedBonus = 0;
let brickSpeedBonus = 0;
let speedIncreasePerBrick = 0.001; // ✅ RÉDUIT de 0.02 à 0.008 (60% plus lent)
let speedIncreasePerLevel = 0.025;   // ✅ RÉDUIT de 1.2 à 0.6 (50% plus lent)
let autopilotSpeedMultiplier = 1.04; // ✅ RÉDUIT de 1.15 à 1.08 (seulement 8% plus rapide)

// === VARIABLES DE TRANSITION DE NIVEAU ===
let levelTransition = false;
let levelTransitionTimer = 0;
let levelTransitionMessage = "";
let levelTransitionDelay = 5000; // 4 secondes en millisecondes

// === SYSTÈME DE CAPTURE DE SOURIS POUR LE CANVAS ===
let isPointerLocked = false;
let virtualMouseX = CANVAS_W / 2; // Position virtuelle de la souris


let bricksHit = 0;
let powerupsCaptured = {
  "long": 0,
  "temps":0,
  "short": 0,
  "mult1": 0,
  "mult2": 0,
  "mult4": 0,
  "mult8": 0,
  "huge": 0,
  "skull": 0
};

let bonusesCaptured = {
  "🍒": 0,   // +500 pts
  "🍓": 0,   // +1000 pts
  "🛸": 0,   // +2000 pts
  "🍑": 0,   // +5000 pts
  "🌸": 0,   // +500 pts
  "💝": 0,   // +8000 pts
  "🍉": 0,   // +2000 pts
  "🇫🇷": 0,   // +10000 pts
  "💊": 0,   // +15000 pts
  "🐲": 0,   // +15000 pts
  "🍇": 0,   // +2000 pts
  "🍪": 0,   // Cookie(s)
  "🇵🇸": 0,   // Cookie(x2)
  "🌈": 0,   // Vie(s)
  "🍌": 0    // +500 pts
};

let startTime = null;
let elapsedTime = 0;

// ✅ NOUVELLES VARIABLES POUR L'OPTIMISATION DES STATS ===
let lastStatsUpdate = 0;
let statsUpdateInterval = 200; // Mise à jour toutes les 200ms (5 fois/seconde)

// Variables pour mémoriser l'état précédent
let lastStatsState = {
    aliveBricks: 0,
    totalBonuses: 0,
    totalPowerups: 0,
    autopilot: false,
    ballSpeed: 0,
    mult: 1,
    skulls: 0
};

// Variables manquantes pour le système de qualité
//let particleCountMax = 80; // Pour ajuster la qualité

let perfFrameCount = 0;
//let harmonyResetTimer = null; // Variable globale pour la chaîne harmonique



    // === GESTIONNAIRE CENTRALISÉ DES TIMEOUTS ===
    const timeoutManager = {
        timeouts: new Map(),

        set(key, callback, delay) {
            this.clear(key);
            const id = setTimeout(() => {
                callback();
                this.timeouts.delete(key);
            }, delay);
            this.timeouts.set(key, id);
        },

        clear(key) {
            if (this.timeouts.has(key)) {
                clearTimeout(this.timeouts.get(key));
                this.timeouts.delete(key);
            }
        },

        clearAll() {
            console.log(`🧹 Nettoyage de ${this.timeouts.size} timeouts gérés`);
            for (let id of this.timeouts.values()) {
                clearTimeout(id);
            }
            this.timeouts.clear();
        },

        // ✅ NOUVELLE MÉTHODE : Diagnostic des timeouts actifs
        diagnose() {
            console.log(`📊 Timeouts actifs : ${this.timeouts.size}`);
            for (let [key, id] of this.timeouts.entries()) {
                console.log(`  - ${key} : ID ${id}`);
            }
        }
    };
    //Fin de fonction timeoutManager

    const countdownRange = 10; // Le compte à rebours commence 5 briques AVANT l'activation.
    const TimerBonus = 15

    // === NOUVELLES VARIABLES STATISTIQUES ===
    bricksHit = 0;
    powerupsCaptured = {
      "long": 0,
      "short": 0,
      "mult1": 0,
      "mult2": 0,
      "mult4": 0,
      "mult8": 0,
      "huge": 0,
      "skull": 0
    };
    startTime = null;
    elapsedTime = 0;

    // === ACCÈS DOM ===

    const canvas = document.getElementById('gameCanvas');
    const elAutopilotBanner = document.getElementById('autopilot-banner');
    const ctx = canvas.getContext('2d');
    const elScore = document.getElementById('score');
    const elVies = document.getElementById('vies');
    const elNiveau = document.getElementById('niveau');
    const elBonusAnim = document.getElementById('bonus-anim');
    const elMult = document.getElementById('mult');
    const elDec = document.getElementById('decrement-timer');
    const elAutopilotStatus = document.getElementById('autopilot-status');
    // === AUDIO : Effets sonores simples arcade ===
    const audioCtx = new(window.AudioContext||window.webkitAudioContext)();
    // === NOUVELLE VARIABLE GLOBALE (à ajouter en haut du fichier) ===
    let galaxyEnabled = true;

    // ✅ CORRECTION : Initialisation copyright dans le panneau stats uniquement
    function initializeCopyright() {
        // ✅ CIBLER SPÉCIFIQUEMENT le panneau de statistiques
        const statsPanel = document.querySelector('.stats-panel-content');

        if (statsPanel) {
            // Vérifier si le copyright existe déjà
            let existingCopyright = statsPanel.querySelector('.copyright-line');

            if (!existingCopyright) {
                // ✅ CRÉER le copyright avec taille réduite
                const copyrightDiv = document.createElement('div');
                copyrightDiv.className = 'copyright-line';
                copyrightDiv.innerHTML = `(c) ${AUTHOR_NAME} ${COPYRIGHT_YEAR} v${GAME_VERSION}`;

                // ✅ L'ajouter à la fin du panneau de stats (pas ailleurs)
                statsPanel.appendChild(copyrightDiv);

                console.log(`✅ Copyright intégré au panneau stats : (c) ${AUTHOR_NAME} ${COPYRIGHT_YEAR} v${GAME_VERSION}`);
            }
        } else {
            console.warn("⚠️ Panneau de statistiques non trouvé pour le copyright");
        }
    }
    //Fin de fonction initializeCopyright
    function computePaddleBounce(ballDX, ballDY, impactRel, maxBounceAngle = 4 * Math.PI / 12, aimTilt = 0.0) {
    // Garde-fous numériques
    if (!isFinite(ballDX)) ballDX = 0;
    if (!isFinite(ballDY)) ballDY = -1; // vers le haut par défaut
    if (!isFinite(impactRel)) impactRel = 0;
    if (!isFinite(maxBounceAngle) || maxBounceAngle <= 0) maxBounceAngle = 4 * Math.PI / 12;

    // 1) Clamp dur de l’impact relatif
    let rel = Math.max(-1, Math.min(1, impactRel + (isFinite(aimTilt) ? aimTilt : 0)));

    // 2) Courbe “S” douce
    const s = 0.85;
    rel = Math.sign(rel) * Math.pow(Math.abs(rel), s);

    // 3) Angle max constant
    const newAngle = rel * maxBounceAngle;

    // 4) Vitesse scalaire conservée (avec plancher)
    let speed = Math.hypot(ballDX, ballDY);
    if (!isFinite(speed) || speed < 0.0001) speed = 10; // repli sûr

    const dx = speed * Math.sin(newAngle);
    const dy = -speed * Math.cos(newAngle); // vers le haut

    // Dernier filet de sécurité
    return {
    dx: isFinite(dx) ? dx : 0,
    dy: isFinite(dy) ? dy : -Math.abs(speed)
    };
    } //Fin de fonction computePaddleBounce

    // Fonction pour obtenir la zone (0-8) d'une position
    function getAIZone(x, y) {
        let zoneX = Math.floor((x / CANVAS_W) * 3);
        let zoneY = Math.floor((y / CANVAS_H) * 3);
        return Math.min(8, zoneY * 3 + zoneX);
    }
    //Fin de fonction getAIZone

    function calculatePerfectBallIntercept() {
        if (ballDY <= 0) return null;

        let timeToImpact = (paddleY - ball.y) / ballDY;
        if (timeToImpact <= 0) return null;

        let interceptX = ball.x + ballDX * timeToImpact;

        // Gestion des rebonds (max 5 pour performance)
        for (let i = 0; i < 5; i++) {
            if (interceptX < 0) {
                interceptX = Math.abs(interceptX);
            } else if (interceptX > CANVAS_W) {
                interceptX = CANVAS_W - (interceptX - CANVAS_W);
            } else {
                break;
            }
        }

        return {
            x: Math.max(paddleW/2, Math.min(CANVAS_W - paddleW/2, interceptX)),
            timeToImpact: timeToImpact
        };
    }
    //Fin de fonction calculatePerfectBallIntercept

    function findSkullThreat() {
    if (!skulls || skulls.length === 0) return null;

    let maxDanger = 0;
    let bestEscape = null;

    skulls.forEach(skull => {
    if (skull && skull.y < paddleY && skull.y > CANVAS_H * 0.3) {
    let timeToImpact = (paddleY - skull.y) / (skull.speed || 7);
    let dangerZone = paddleW + 20;
    let distance = Math.abs(skull.x - (paddleX + paddleW/2));

    if (distance < dangerZone && timeToImpact > 0) {
      let danger = dangerZone / (timeToImpact * distance * 0.01);

      if (danger > maxDanger) {
        maxDanger = danger;
        let leftSafe = skull.x - dangerZone;
        let rightSafe = skull.x + dangerZone;
        let currentCenter = paddleX + paddleW/2;
        let safeX = null;

        if (leftSafe >= paddleW/2 && rightSafe <= CANVAS_W - paddleW/2) {
          safeX = Math.abs(leftSafe - currentCenter) < Math.abs(rightSafe - currentCenter) ? leftSafe : rightSafe;
        } else if (leftSafe >= paddleW/2) {
          safeX = leftSafe;
        } else if (rightSafe <= CANVAS_W - paddleW/2) {
          safeX = rightSafe;
        }

        if (safeX !== null) bestEscape = { safeX, danger };
      }
    }
  }

  });

  if (bestEscape && (bestEscape.safeX < paddleW/2 || bestEscape.safeX > CANVAS_W - paddleW/2)) {
  bestEscape.safeX = Math.max(paddleW/2, Math.min(CANVAS_W - paddleW/2, bestEscape.safeX));
  }
  return bestEscape;
  } //Fin de fonction findSkullThreat


    function findAdaptiveBrickTarget() {
        let aliveBricks = bricks.filter(b => b && b.alive);
        if (aliveBricks.length === 0) return null;

        let bestTarget = null;
        let bestScore = -1;

        aliveBricks.forEach(brick => {
            let brickCenterX = brick.x + brick.w/2;
            let brickCenterY = brick.y + brick.h/2;
            let deltaX = brickCenterX - ball.x;
            let deltaY = brickCenterY - ball.y;

            if (deltaY >= 0) return; // Brique derrière

            // ✅ NOUVEAU : Calcul avec angle de correction de 5°
            let baseAngle = Math.atan2(deltaX, -deltaY);

            // Ajouter 5° (converti en radians) avec variation selon la position
            let correctionAngle = 5 * Math.PI / 180; // 5° en radians

            // ✅ Varier l'angle selon la position horizontale de la brique
            if (brickCenterX < CANVAS_W * 0.3) {
                // Côté gauche : angle légèrement vers la droite
                correctionAngle *= 1.2;
            } else if (brickCenterX > CANVAS_W * 0.7) {
                // Côté droit : angle légèrement vers la gauche
                correctionAngle *= -1.2;
            }

            let adjustedAngle = baseAngle + correctionAngle;
            let requiredPaddleX = ball.x + Math.tan(adjustedAngle) * (ball.y - paddleY);

            if (requiredPaddleX < paddleW/2 || requiredPaddleX > CANVAS_W - paddleW/2) {
                // ✅ NOUVEAU : Tentative avec angle opposé si impossible
                adjustedAngle = baseAngle - correctionAngle;
                requiredPaddleX = ball.x + Math.tan(adjustedAngle) * (ball.y - paddleY);

                if (requiredPaddleX < paddleW/2 || requiredPaddleX > CANVAS_W - paddleW/2) {
                    return; // Vraiment impossible
                }
            }

            // Score de base (inchangé)
            let distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            let moveDistance = Math.abs(requiredPaddleX - (paddleX + paddleW/2));
            let score = 1000 - distance * 0.8 - moveDistance * 1.2;

            // Bonus spéciaux (inchangés)
            if (aliveBricks.length === 1) score += 5000;
            if (brick.special && !brick.special.includes("☠️")) score += 300;
            if (brick.y > wallOffset + brickH * 4) score += 200;

            // 🧠 APPRENTISSAGE avec correction d'angle
            let zone = getAIZone(brickCenterX, brickCenterY);
            let zoneData = getZoneDataSafe(zone);
            if (zoneData && zoneData.attempts > 0) {
            requiredPaddleX += zoneData.correction;
            let confidence = zoneData.hits / Math.max(1, zoneData.attempts);
            score *= (0.3 + confidence * 0.7);
            if (confidence > 0.7) score += 400;
            }

            if (zoneData.attempts > 0) {
                requiredPaddleX += zoneData.correction;
                let confidence = zoneData.hits / zoneData.attempts;
                score *= (0.3 + confidence * 0.7);

                if (confidence > 0.7) {
                    score += 400;
                }
            }

            if (score > bestScore) {
                bestScore = score;
                bestTarget = {
                    brick: brick,
                    paddleX: requiredPaddleX,
                    zone: zone,
                    confidence: zoneData.attempts > 0 ? zoneData.hits / zoneData.attempts : 0.5,
                    usedAngleCorrection: correctionAngle // ✅ NOUVEAU : Mémoriser l'angle utilisé
                };
            }
        });

        return bestTarget;
    }
    //Fin de fonction findAdaptiveBrickTarget
    //Fin de fonction findAdaptiveBrickTarget

    function findSecurePowerup() {
        // ✅ NOUVEAU : Sécurité moins stricte pour collecter plus
        if (ballDY > 0 && ball.y > CANVAS_H * 0.75) return null; // Seuil abaissé de 0.6 à 0.75

        let allItems = [...(powerups || []), ...(bonuses || [])];
        let bestItem = null;
        let bestScore = -1;

        allItems.forEach(item => {
            if (!item || item.caught || item.type === "skull") return;

            // ✅ NOUVEAU : Zone de collecte élargie
            if (item.y > 50 && item.y < paddleY + 150) { // Zone élargie de 80 à 150
                let timeToCollect = (paddleY - item.y) / (item.speed || 6);
                let distance = Math.abs(item.x - (paddleX + paddleW/2));

                // ✅ NOUVEAU : Prédiction de position future de l'item
                let futureItemX = item.x + (item.dx || 0) * timeToCollect;
                let futurePaddleDistance = Math.abs(futureItemX - (paddleX + paddleW/2));

                // ✅ CONDITIONS ASSOUPLIES pour collecter plus facilement
                if (timeToCollect > 0.3 && futurePaddleDistance < 120) { // Seuils assouplis
                    let score = 100;

                    // ✅ PRIORISATION AMÉLIORÉE avec bonus pour proximité
                    switch(item.type) {
                        case "mult8": score = 1200; break;
                        case "mult4": score = 1000; break;
                        case "temps": score = 1500; break; // Priorité absolue
                        case "mult2": score = 800; break;
                        case "mult1": score = 600; break;
                        case "huge": score = 700; break;
                        case "long": score = 500; break;
                        case "cookie": case "cookiex2": score = 400; break;
                        case "vie": case "niveau": score = 900; break;
                        case "XultX": case "XultX": score =1500; break;

                        default:
                            if (item.points && item.points > 5000) score = 600;
                            else if (item.points && item.points > 1000) score = 400;
                            else score = 200;
                    }

                    // ✅ BONUS pour les items proches et faciles à atteindre
                    score -= futurePaddleDistance * 0.3; // Réduit le malus distance
                    score -= timeToCollect * 5; // Réduit le malus temps
                    score += Math.max(0, 50 - distance) * 2; // Bonus proximité actuelle

                    // ✅ BONUS spécial si l'item est dans le sens de déplacement
                    let currentDirection = paddleVelocity ? Math.sign(paddleVelocity) : 0;
                    let itemDirection = Math.sign(futureItemX - (paddleX + paddleW/2));
                    if (currentDirection === itemDirection) score += 100;

                    if (score > bestScore) {
                        bestScore = score;
                        bestItem = item;
                    }
                }
            }
        });

        return bestItem;
    }
    //Fin de fonction findSecurePowerup

    //Fin de fonction findSecurePowerup

    function executeAutopilotMovement(targetX, priority, movementType, dt) {
        // Contraintes sécurisées
        targetX = Math.max(paddleW/2, Math.min(CANVAS_W - paddleW/2, targetX));
        let targetPaddleX = targetX - paddleW/2;

        let deltaX = targetPaddleX - paddleX;
        let distance = Math.abs(deltaX);

        if (distance > 1) {
            let direction = deltaX > 0 ? 1 : -1;

            // ✅ NOUVEAU : Système de vitesse progressive selon la distance
            let baseSpeed = autopilotAI.speeds[movementType] * (megaspeed || 1);
            let progressiveSpeed;

            if (distance > 100) {
                // Grande distance : vitesse maximale
                progressiveSpeed = baseSpeed;
            } else if (distance > 50) {
                // Distance moyenne : vitesse réduite progressivement
                progressiveSpeed = baseSpeed * (0.4 + (distance - 50) / 50 * 0.6);
            } else {
                // Petite distance : vitesse très réduite pour précision
                progressiveSpeed = baseSpeed * (0.2 + distance / 50 * 0.2);
            }

            // ✅ NOUVEAU : Lissage du mouvement avec inertie
            if (!paddleVelocity) paddleVelocity = 0;

            let targetVelocity = direction * progressiveSpeed * dt;
            let acceleration = 0.15; // Facteur d'inertie (plus petit = plus fluide)

            paddleVelocity = paddleVelocity * (1 - acceleration) + targetVelocity * acceleration;

            // ✅ Application du mouvement lissé
            let maxMove = Math.min(distance, Math.abs(paddleVelocity));
            paddleX += Math.sign(paddleVelocity) * maxMove;

            // ✅ Gestion spéciale pour l'urgence (mais toujours lissée)
            if (movementType === "emergency" && priority >= 4) {
                let emergencyBoost = Math.min(distance * 0.3, baseSpeed * dt * 0.5);
                paddleX += direction * emergencyBoost;
            }

            // Contrainte finale
            paddleX = Math.max(0, Math.min(CANVAS_W - paddleW, paddleX));
        } else {
            // ✅ Arrêt progressif quand on arrive à destination
            if (paddleVelocity) {
                paddleVelocity *= 0.8; // Décélération douce
                if (Math.abs(paddleVelocity) < 0.1) paddleVelocity = 0;
            }
        }
    }
    //Fin de fonction executeAutopilotMovement

    //Fin de fonction executeAutopilotMovement

    function learnFromResult(success, hitBrick = null) {
    // Garde-fous de base
    if (!autopilotAI || typeof autopilotAI !== 'object') return;
    if (!autopilotAI.currentShot) return;

    // Sûreté des structures
    if (!Array.isArray(autopilotAI.recentShots)) autopilotAI.recentShots = [];
    if (!isFinite(autopilotAI.learningRate)) autopilotAI.learningRate = 0.1;

    const shot = autopilotAI.currentShot;

    // On ne traite que les tirs de type brick_shot avec zone valide
    if (shot.type === "brick_shot" && Number.isInteger(shot.zone)) {
    // Clamp zone 0..8
    let z = Math.max(0, Math.min(8, shot.zone));
    // Récupération sécurisée des stats
    if (!Array.isArray(autopilotAI.zoneStats)) {
      autopilotAI.zoneStats = new Array(9).fill().map(() => ({
        attempts: 0, hits: 0, misses: 0, avgError: 0, correction: 0, confidence: 0.5
      }));
    }
    if (!autopilotAI.zoneStats[z]) {
      autopilotAI.zoneStats[z] = { attempts: 0, hits: 0, misses: 0, avgError: 0, correction: 0, confidence: 0.5 };
    }

    let zoneData = autopilotAI.zoneStats[z];

    // Compteurs
    zoneData.attempts = (zoneData.attempts | 0) + 1;

    if (success && hitBrick) {
      zoneData.hits = (zoneData.hits | 0) + 1;
    } else {
      zoneData.misses = (zoneData.misses | 0) + 1;

      // Correction si brique prévue vs brique touchée
      if (hitBrick && shot.targetBrick && isFinite(autopilotAI.learningRate)) {
        const expectedX = shot.targetBrick.x + shot.targetBrick.w / 2;
        const actualX = hitBrick.x + hitBrick.w / 2;
        const error = actualX - expectedX;

        if (isFinite(error)) {
          const lr = Math.max(0, Math.min(1, autopilotAI.learningRate));
          const newCorr = (zoneData.correction || 0) + error * lr;
          zoneData.correction = Math.max(-40, Math.min(40, newCorr));
        }
      }
    }

    // Confiance
    zoneData.confidence = zoneData.hits / Math.max(1, zoneData.attempts);

    // Historique
    autopilotAI.recentShots.push({ zone: z, success: !!success, timestamp: performance.now() });
    if (autopilotAI.recentShots.length > 20) {
      autopilotAI.recentShots.shift();
    }
  }

  // Toujours nettoyer
  autopilotAI.currentShot = null;
  } //Fin de fonction learnFromResult

    // Fonction de diagnostic des performances
    function diagnoseAutopilot() {
        console.log("=== DIAGNOSTIC AUTOPILOTE ===");

        let totalAttempts = 0;
        let totalHits = 0;

        autopilotAI.zoneStats.forEach((zone, i) => {
            if (zone.attempts > 0) {
                totalAttempts += zone.attempts;
                totalHits += zone.hits;
                let accuracy = (zone.hits / zone.attempts * 100).toFixed(1);
                console.log(`Zone ${i}: ${zone.hits}/${zone.attempts} (${accuracy}%) - Correction: ${zone.correction.toFixed(1)}px`);
            }
        });

        let globalAccuracy = totalAttempts > 0 ? (totalHits / totalAttempts * 100).toFixed(1) : 0;
        console.log(`PRÉCISION GLOBALE: ${globalAccuracy}% (${totalHits}/${totalAttempts})`);

        console.log("=== FIN DIAGNOSTIC ===");
    }
    //Fin de fonction diagnoseAutopilot


    function autopilotMove(dt) {


        if (!ball || !dt) return;

        // Hystérésis: si un lock est actif, on le respecte tant qu'il est valable
        if (autopilotLock.type && performance.now() < autopilotLock.until) {
        executeAutopilotMovementTight(autopilotLock.targetX, 5, "urgent", dt);
        return;
        }

        const paddleCenter = paddleX + paddleW/2;
        let targetX = paddleCenter;
        let priority = 0; // 0=idle, 1=powerup, 2=brick, 3=skull, 4=ball
        let movementType = "idle";

        // 0) Préemption vitaux powerups si atteignables (avant tout)
        //    On utilise une version "vital first" de findSecurePowerup ci‑dessous.
        let vital = findSecurePowerupVitalFirst();
        if (vital && ballDY < 0) {
            // Si la balle monte, on peut collecter sans risque
//            targetX = vital.x;
            targetX = predictItemX(vital);
            priority = 1;
            movementType = "collect";
        }

        // Fenêtre vitale même si la balle descend mais loin/temps long
        if (!vital && ballDY > 0) {
            let interceptResult = calculatePerfectBallIntercept();
            if (interceptResult && interceptResult.timeToImpact > 0.45) {
              let vital2 = findSecurePowerupVitalFirst();
                if (vital2) {
                  const px = predictItemX(vital2);
                  const distP = Math.abs(px - (paddleX + paddleW/2));
                  if (distP < Math.max(160, paddleW)) {
                      targetX = px;
                      priority = 1;
                      movementType = "collect";
                      autopilotLock = { type: "powerup", until: performance.now() + 140, targetX };
                  }
                }
            }
        }

        // 1) Sauvegarde balle (priorité absolue)
        if (ballDY > 0 && ball.y > CANVAS_H * 0.48) {
            let interceptResult = calculatePerfectBallIntercept();
            if (interceptResult) {
                targetX = interceptResult.x;
                priority = 4;
                movementType = "emergency";
                autopilotAI.currentShot = {
                    type: "ball_save",
                    targetX: interceptResult.x,
                    ballPos: {x: ball.x, y: ball.y},
                    timestamp: performance.now()
                };
            }
        }

        // 2) Évitement skull
        if (priority < 3) {
            let skullThreat = findSkullThreat();
            if (skullThreat) {
                targetX = skullThreat.safeX;
                priority = 3;
                movementType = "urgent";
            }
        }

        // 3) Powerups (seconde passe non vitale, si rien d’urgent)
        const shotActive = (autopilotAI.currentShot && autopilotAI.currentShot.type === "brick_shot") ||
        (shotLock.target && performance.now() < shotLock.until);
        if (priority < 1 && !shotActive && ballDY < 0) {
        const pu = findSecurePowerupRelaxed();
        if (pu) {
        targetX = predictItemX(pu);
        priority = 1;
        movementType = "collect";
        }
        }

        if (shotLock.target && performance.now() < shotLock.until) {
        // On conserve la cible verrouillée tant que la fenêtre court
        const t = shotLock.target;
        // Recompute la solution d’impact au besoin, sinon conserve targetX
        const solved = solveImpactForTarget(ball, t.bx, t.by, paddleY, paddleW);
        if (solved) {
        const desiredCenter = Math.max(paddleW/2, Math.min(CANVAS_W - paddleW/2, solved.paddleCenterX));
        targetX = desiredCenter;
        priority = 2;
        movementType = "precise";
        // Maintenir currentShot cohérent
        autopilotAI.currentShot = {
        type: "brick_shot",
        targetBrick: t.brick,
        targetX: desiredCenter,
        zone: getAIZone(t.bx, t.by),
        ballPos: {x: ball.x, y: ball.y},
        timestamp: performance.now(),
        confidence: t.confidence || 0.5
        };
        // Armer AIM sûr
        AIM.active = false;
        if (isFinite(solved.impactRel)) {
        AIM.impactRel = Math.max(-1, Math.min(1, solved.impactRel));
        AIM.until = performance.now() + 900;
        AIM.active = true;
        }
        // Et on sort de la section “choix brique”
        }
        }
        executeAutopilotMovementTight(targetX, 2, "precise", dt);
        return;
        //Fin de verrou shotLock (entrée)


        // 4) Vise brique si la balle monte et si tir faisable (version unifiée)
        if (priority < 2 && ballDY < 0) {
        let brickTarget = null;

        if (remaining <= 5) {
        // vise la brique la plus proche verticalement de la balle (rapide à finir)
        const alive = bricks.filter(b => b && b.alive && (b.y + b.h/2) < ball.y);
        if (alive.length) {
        alive.sort((a,b) => {
        const ay = ball.y - (a.y + a.h/2);
        const by = ball.y - (b.y + b.h/2);
        const ax = Math.abs((a.x + a.w/2) - ball.x);
        const bx = Math.abs((b.x + b.w/2) - ball.x);
        return (ay - by) || (ax - bx);
        });
        const tgt = alive;
        const bx = tgt.x + tgt.w/2, by = tgt.y + tgt.h/2;
        const solved = solveImpactForTarget(ball, bx, by, paddleY, paddleW);
        if (solved) {
        brickTarget = { brick: tgt, paddleX: solved.paddleCenterX, zone: getAIZone(bx, by), confidence: 0.6 };
        }
        }
        }

        if (!brickTarget) {
        brickTarget = findAdaptiveBrickTargetFeasible();
        }
        if (!brickTarget) {
        const likely = findLikelyTarget();
        if (likely && likely.brick) {
        const bx = likely.brick.x + likely.brick.w/2;
        const by = likely.brick.y + likely.brick.h/2;
        const solved = solveImpactForTarget(ball, bx, by, paddleY, paddleW);
        if (solved) brickTarget = { brick: likely.brick, paddleX: solved.paddleCenterX, zone: getAIZone(bx, by), confidence: 0.5 };
        }
        }

      } //Fin de fonction autopilotMove (partie armement)
        } //Fin de bloc vise brique simplifié

        // 5) Mouvement
        executeAutopilotMovementTight(targetX, priority, movementType, dt);

        // Si priorité très basse (rien) on relâche
        if (priority === 0) autopilotLock.type = null;

    //Fin de fonction autopilotMove

    function predictItemX(item) {
    if (!item) return paddleX + paddleW/2;
    const vy = (item.speed || 6);
    const dy = Math.max(0, (paddleY - item.y));
    const t = dy / (vy + 1e-6);
    const futureX = item.x + (item.dx || 0) * t;
    return Math.max(paddleW/2, Math.min(CANVAS_W - paddleW/2, futureX));
    } //Fin de fonction predictItemX



    function isVitalPowerup(item) {
    if (!item) return false;
    // Types critiques (à adapter si tu veux durcir/alléger)
    return item.type === "temps" || item.type === "mult4" || item.type === "mult8" ||
    item.type === "vie" || item.type === "niveau" ||
    // Cookie utile si bouton panic envisagé:
    (item.type === "cookie" && cookies === 0);
    } //Fin de fonction isVitalPowerup

    function findSecurePowerupVitalFirst() {

      // Version stricte: vitaux clairement atteignables
      let best = null;
      let bestScore = -1;

      let all = [...(powerups || []), ...(bonuses || [])];
      all.forEach(item => {
      if (!item || item.caught || item.type === "skull" || item.type === "boss_projectile") return;
      if (!isVitalPowerup(item)) return;


      if (item.y > 40 && item.y < paddleY + 160) {
        const vy = (item.speed || 6);
        const dy = Math.max(0, paddleY - item.y);
        const t = dy / (vy + 0.0001);

        // prédiction future
        const futureX = item.x + (item.dx || 0) * t;
        const dist = Math.abs(futureX - (paddleX + paddleW/2));

        // Fenêtre dynamique
        const speedCollect = (autopilotAI && autopilotAI.speeds ? autopilotAI.speeds.collect : 520) * (megaspeed || 1);
        const minWindow = 0.18 + Math.min(0.17, dist / Math.max(200, paddleW) * 0.25);
        if (t <= minWindow) return;

        // Distance atteignable raisonnable
        if (dist < Math.max(140, paddleW * 0.9)) {
          let base = 1000;
          if (item.type === "temps") base += 900;
          else if (item.type === "mult8") base += 700;
          else if (item.type === "mult4") base += 550;
          else if (item.type === "vie") base += 500;
          else if (item.type === "niveau") base += 450;
          else if (item.type === "cookie") base += 200;

          const score = base - dist * 0.6 - t * 120;

          if (autopilotAI.currentShot && autopilotAI.currentShot.type === "brick_shot" && autopilotAI.currentShot.targetBrick) {
          if (autopilotAI.currentShot.targetBrick !== brick) {
          // Pénalité d’inertie pour éviter de sauter de cible en cible
          score -= 120; // petit frein au “change d’avis”
          }
        }


          if (score > bestScore) { bestScore = score; best = item; }
        }
      }

      });

      return best;
      } //Fin de fonction findSecurePowerupVitalFirst

function findSecurePowerupRelaxed() {
      // Version plus permissive: on considère aussi bonus à points
      let best = null;
      let bestScore = -1;
      let all = [...(powerups || []), ...(bonuses || [])];
      all.forEach(item => {
          if (!item || item.caught || item.type === "skull" || item.type === "boss_projectile") return;

          if (item.y > 50 && item.y < paddleY + 170) {
              let timeToCollect = (paddleY - item.y) / ((item.speed || 6) + 0.0001);
              if (timeToCollect <= 0.16) return; // trop tard

              let futureX = item.x + (item.dx || 0) * timeToCollect;
              let dist = Math.abs(futureX - (paddleX + paddleW/2));

              if (dist < Math.max(170, paddleW)) {
                  // Pondération par type
                  let score = 100;
                  if (isVitalPowerup(item)) score += 400;
                  else if (item.points && item.points >= 5000) score += 220;
                  else if (item.points && item.points >= 1000) score += 160;
                  else score += 80;

                  // Bonus si le mouvement actuel est dans le bon sens
                  let currentDir = paddleVelocity ? Math.sign(paddleVelocity) : 0;
                  let itemDir = Math.sign(futureX - (paddleX + paddleW/2));
                  if (currentDir === itemDir) score += 60;

                  score -= dist * 0.4;
                  score -= timeToCollect * 90;

                  if (score > bestScore) { bestScore = score; best = item; }
              }
          }
      });

      return best;

      } //Fin de fonction findSecurePowerupRelaxed


      function findAdaptiveBrickTargetFeasible() {
      const aliveBricks = bricks.filter(b => b && b.alive && !b.animating);
      if (aliveBricks.length === 0) return null;

      let best = null;
      let bestScore = -1;

      aliveBricks.forEach(brick => {
      const cx = brick.x + brick.w/2;
      const cy = brick.y + brick.h/2;
      const dx = cx - ball.x;
      const dy = cy - ball.y;
      if (dy >= 0) return; // brique derrière la balle (la balle monte)

      // Correction latérale douce 5°
      let corr = 5 * Math.PI / 180;
      if (cx < CANVAS_W * 0.3) corr *= 1.2;
      else if (cx > CANVAS_W * 0.7) corr *= -1.2;

      // Pente horizontale vers la raquette, repère unifié
      const dYabs = Math.max(1, (ball.y - paddleY)); // distance verticale positive jusqu’à la raquette
      let slope = (dx / Math.abs(dy)) + Math.tan(corr);

      // Position requise du centre de la raquette
      let reqXcenter = ball.x + slope * dYabs;

      // Si hors-limites, essaie corr dans l’autre sens (petit repli)
      if (reqXcenter < paddleW/2 || reqXcenter > CANVAS_W - paddleW/2) {
        slope = (dx / Math.abs(dy)) - Math.tan(corr);
        reqXcenter = ball.x + slope * dYabs;
        if (reqXcenter < paddleW/2 || reqXcenter > CANVAS_W - paddleW/2) return;
      }

      // Faisabilité en temps réel
      const moveDist = Math.abs(reqXcenter - (paddleX + paddleW/2));
      const vy = Math.abs(ballDY) + 1e-3;
      const timeBeforeDown = Math.max(0.05, Math.abs(dy) / vy);
      const vx = (autopilotAI && autopilotAI.speeds ? autopilotAI.speeds.precise : 520) * (megaspeed || 1);
      const maxReach = vx * timeBeforeDown * 0.85;
//      const feasible = moveDist <= Math.max(120, maxReach);
      let feasible = moveDist <= Math.max(120, maxReach);

      if (!findAdaptiveBrickTargetFeasible._hys) {
      findAdaptiveBrickTargetFeasible._hys = { lastOk: 0, lastId: null };
      }
      const hys = findAdaptiveBrickTargetFeasible._hys;
      const id = brick._id || (brick._id = `${cx|0}_${cy|0}`);

      const recentlyOk = (hys.lastId === id) && (performance.now() - hys.lastOk < 250);
      if (!feasible && recentlyOk) {
      const relaxedReach = Math.max(120, maxReach * 1.12);
      if (moveDist <= relaxedReach) feasible = true;
      }
      if (feasible) { hys.lastOk = performance.now(); hys.lastId = id; }


      if (!feasible && aliveBricks.length > 2) return;

      // Score
      const distance = Math.sqrt(dx*dx + dy*dy);
      const remain = aliveBricks.length;
      let score = 1000;

      if (remain <= 3) score += 1200;
      if (remain === 1) score += 2500;

      score += Math.min(400, timeBeforeDown * 600);
      score -= distance * 0.6;
      score -= moveDist * 0.8;

      if (brick.special && !brick.special.includes("☠️")) score += 300;

      // Apprentissage par zone
      const zone = getAIZone(cx, cy);
//      const z = autopilotAI.zoneStats[zone];
      const z = getZoneDataSafe(zone);
      if (z && z.attempts > 2) {
        reqXcenter += z.correction;
        const conf = z.hits / z.attempts;
        score *= (0.35 + conf * 0.65);
        if (conf > 0.7) score += 400;
      }

      // Fin de niveau: favoriser brique basse et proche latéralement
      if (remain <= 2) {
        score += (CANVAS_H - cy) * 0.5;
        score -= Math.abs((paddleX + paddleW/2) - cx) * 0.35;
      }

      const lateral = Math.abs(cx - ball.x);
      score -= lateral * 0.15; // léger malus latéral (évite cibles opposées)
      if (aliveBricks.length <= 4) {
      score += Math.max(0, (CANVAS_H - cy)) * 0.25; // favorise briques basses en fin
      }


      if (score > bestScore) {
        bestScore = score;
        best = { brick, paddleX: reqXcenter, zone, confidence: (z && z.attempts ? z.hits/z.attempts : 0.5) };
      }

      });

      return best;
      } //Fin de fonction findAdaptiveBrickTargetFeasible

      // Cible probable simple: prend une brique vivante proche de l'axe vertical de la balle et en avant (y plus haut)
      function findLikelyTarget() {
        const alive = bricks.filter(b => b && b.alive);
        if (alive.length === 0) return null;

        // Pondère par proximité latérale et par "être sous la balle" (ty < ball.y)
        let best = null;
        let bestScore = -Infinity;

        alive.forEach(b => {
          const cx = b.x + b.w / 2;
          const cy = b.y + b.h / 2;
          if (cy > ball.y) return; // on ne vise que vers le haut

          const lateral = Math.abs(cx - ball.x);
          const vertical = ball.y - cy;

          // Score très simple: bas vertical = mieux, latéral faible = mieux
          let score = vertical * 1.0 - lateral * 0.6;

          // Légers bonus si brique spéciale non skull
          if (b.special && !b.special.includes("☠️")) score += 120;

          if (score > bestScore) {
            bestScore = score;
            best = b;
          }
        });

        return best ? { brick: best } : null;
      } //Fin de fonction findLikelyTarget


      function executeAutopilotMovementTight(targetX, priority, movementType, dt) {
      targetX = Math.max(paddleW/2, Math.min(CANVAS_W - paddleW/2, targetX));
      let targetPaddleX = targetX - paddleW/2;
      let deltaX = targetPaddleX - paddleX;
      let distance = Math.abs(deltaX);

      if (distance > 0.5) {
      let direction = deltaX > 0 ? 1 : -1;
      let base = (autopilotAI && autopilotAI.speeds ? autopilotAI.speeds[movementType] : 500);
      let maxSpeed = base * (megaspeed || 1);

      // Progression
    let progressive = distance > 120 ? maxSpeed
                   : distance > 60 ? maxSpeed * (0.55 + (distance - 60)/60 * 0.45)
                   : maxSpeed * (0.25 + distance/60 * 0.25);

     if (bricks.filter(b => b && b.alive).length <= 5) {
       progressive *= 1.15;
     } //Fin de renfort finishing

    // Inertie plus nerveuse
    if (!paddleVelocity) paddleVelocity = 0;
    let targetVel = direction * progressive * dt;
    let alpha = 0.25;
    paddleVelocity = paddleVelocity * (1 - alpha) + targetVel * alpha;

    // Cap mouvement
    let maxMove = Math.min(distance, Math.abs(paddleVelocity));
    paddleX += Math.sign(paddleVelocity) * maxMove;

    // Boost urgence si sauvetage balle
    if (movementType === "emergency" && priority >= 4) {
      let boost = Math.min(distance * 0.45, maxSpeed * dt * 0.65);
      paddleX += direction * boost;
    }

    // Contrainte
    paddleX = Math.max(0, Math.min(CANVAS_W - paddleW, paddleX));

    } else {
    // Snap si la cible est quasi-stable
    if (!executeAutopilotMovementTight.prevTarget) {
    executeAutopilotMovementTight.prevTarget = targetPaddleX;
    }
    const drift = Math.abs(executeAutopilotMovementTight.prevTarget - targetPaddleX);
    if (drift < 4.5 && priority >= 2) {
    paddleX = targetPaddleX;
    }

    executeAutopilotMovementTight.prevTarget = targetPaddleX;

    if (paddleVelocity) {
      paddleVelocity *= 0.6;
      if (Math.abs(paddleVelocity) < 0.05) paddleVelocity = 0;
    }
    }
    } //Fin de fonction executeAutopilotMovementTight

    // === SYSTÈME DE SCALE PROPORTIONNEL POUR END PANEL ===
    function calculateEndPanelScale() {
        const panelWidth = 900;   // Largeur de référence
        const panelHeight = 700;  // Hauteur de référence

        // Dimensions disponibles dans la fenêtre
        const availableWidth = window.innerWidth;
        const availableHeight = window.innerHeight;

        // Calcul des ratios pour chaque dimension
        const scaleX = availableWidth / panelWidth;
        const scaleY = availableHeight / panelHeight;

        // On prend le plus petit ratio pour que TOUT rentre
        // avec une marge de sécurité de 8% (un peu moins que le bonus panel)
        const optimalScale = Math.min(scaleX, scaleY) * 0.92;

        // Limites de sécurité
        return Math.max(0.3, Math.min(1.3, optimalScale));
    }

    function initPointerLock() {
        // Vérifier la compatibilité
        if (!canvas.requestPointerLock) {
            console.warn("⚠️ Pointer Lock non supporté - utilisation de la méthode alternative");
            return false;
        }

        // Gestionnaire de capture
        canvas.addEventListener('click', () => {
            if (!isPointerLocked && !autopilot) {
                canvas.requestPointerLock();
            }
        });

        // Gestionnaires d'état
        document.addEventListener('pointerlockchange', () => {
            isPointerLocked = document.pointerLockElement === canvas;

            if (isPointerLocked) {
                console.log("🔒 Souris capturée - contrôle total activé");
                canvas.style.cursor = 'none';
            } else {
                console.log("🔓 Souris libérée");
                canvas.style.cursor = 'default';
            }
        });

        // Gestionnaire de mouvement avec pointer lock
        document.addEventListener('mousemove', (e) => {
            if (!isPointerLocked || autopilot) return;

            // Mouvement relatif avec pointer lock
            virtualMouseX += e.movementX;

            // ✅ CONTRAINTE : Maintenir la souris virtuelle dans les limites
            virtualMouseX = Math.max(paddleW / 2, Math.min(CANVAS_W - paddleW / 2, virtualMouseX));

            // ✅ MOUVEMENT FLUIDE de la raquette
            paddleX = virtualMouseX - paddleW / 2;

            // ✅ SÉCURITÉ : Contrainte finale de la raquette
            const limits = getEffectiveCanvasLimits();
            paddleX = Math.max(0, Math.min(limits.width - paddleW, paddleX));
        });

        return true;
    }

function lockPointer() {
    if (canvas.requestPointerLock && !isPointerLocked) {
        canvas.requestPointerLock();
    }
}

function unlockPointer() {
    if (document.exitPointerLock && isPointerLocked) {
        document.exitPointerLock();
    }
}


//Fin de fonction initPointerLock

    function applyEndPanelScale() {
        const endPanel = document.querySelector('#endPanel');
        if (endPanel) {
            const scale = calculateEndPanelScale();
            endPanel.style.transform = `translate(-50%, -50%) scale(${scale})`;

            console.log(`🏁 End Panel scale: ${scale.toFixed(3)} (fenêtre: ${window.innerWidth}×${window.innerHeight})`);
        }
    }
    //Fin de fonction applyEndPanelScale

    function diagnosePerfomance() {
        console.log("🔍 DIAGNOSTIC PERFORMANCE");
        console.log("Animations actives:", animations.length);
        console.log("Particules:", particles.length);
        console.log("Powerups:", powerups.length);
        console.log("Bonus:", bonuses.length);
        console.log("Skulls:", skulls.length);
        console.log("GameLoop ID:", gameLoopId);
        console.log("Psy Animation ID:", psyAnimId);
        timeoutManager.diagnose();
    }


    function adjustRenderQuality() {
        // ✅ NOUVEAU : Calcul des FPS manquant
        if (perfFrameCount >= PERF_CONFIG.measureIntervalFrames) {
            const now = performance.now();
            const avgFrameTime = (now - perfLastTime) / perfFrameCount;
            const estimatedFPS = 1000 / avgFrameTime;

            // ✅ ADAPTATION AUTOMATIQUE DE LA QUALITÉ
            if (estimatedFPS < 30) {
                renderQuality = "low";
                brickCacheRadius = 0; // Coins moins arrondis = plus rapide

            } else if (estimatedFPS < 35) {
                renderQuality = "medium";
                brickCacheRadius = 0;

            } else if (estimatedFPS < 40) {
                renderQuality = "medium";
                brickCacheRadius = 2;

            } else if (estimatedFPS < 45) {
                renderQuality = "medium";
                brickCacheRadius = 3;
            } else {
                renderQuality = "high";
                brickCacheRadius = 6; // Coins bien arrondis
            }

            // ✅ RECRÉER LE CACHE avec le nouveau rayon
            brickShapeCache = null;

            // ✅ RESET DES COMPTEURS
            perfFrameCount = 0;
            perfLastTime = now;
        }
    }
    //Fin de fonction adjustRenderQuality

    //Fin de fonction adjustRenderQuality

    // === SYSTÈME DE SCALE PROPORTIONNEL POUR BONUS PANEL ===
    function calculateBonusPanelScale() {
        const panelWidth = 600;   // Largeur de référence
        const panelHeight = 800;  // Hauteur de référence

        // Dimensions disponibles dans la fenêtre
        const availableWidth = window.innerWidth;
        const availableHeight = window.innerHeight;

        // Calcul des ratios pour chaque dimension
        const scaleX = availableWidth / panelWidth;
        const scaleY = availableHeight / panelHeight;

        // On prend le plus petit ratio pour que TOUT rentre
        // avec une marge de sécurité de 10% (plus conservatrice que le jeu)
        const optimalScale = Math.min(scaleX, scaleY) * 0.9;

        // Limites de sécurité
        return Math.max(0.4, Math.min(1.2, optimalScale));
    }

    function applyBonusPanelScale() {
        const bonusPanel = document.querySelector('#bonusPanel');
        if (bonusPanel) {
            const scale = calculateBonusPanelScale();
            bonusPanel.style.transform = `translate(-50%, -50%) scale(${scale})`;

            console.log(`🎁 Bonus Panel scale: ${scale.toFixed(3)} (fenêtre: ${window.innerWidth}×${window.innerHeight})`);
        }
    }
    //Fin de fonction applyBonusPanelScale



    function clearAllAnimations() {
      console.log("🧹 Nettoyage de toutes les animations");

      // ✅ ARRÊTER LA BOUCLE PRINCIPALE
      if (gameLoopId) {
        cancelAnimationFrame(gameLoopId);
        gameLoopId = null;
        console.log("🔄 Boucle principale arrêtée");
      }

      // ✅ ARRÊTER L'ANIMATION PSYCHÉDÉLIQUE
      if (psyAnimId) {
        cancelAnimationFrame(psyAnimId);
        psyAnimId = null;
        console.log("🌈 Animation psychédélique arrêtée");
      }

      // ✅ NETTOYER TOUS LES TIMEOUTS INDIVIDUELS
      const timeoutsToClean = [
        'bonusAnimTimeout',
        'paddleHugeTimeout',
        'longTimeout',
        'shortTimeout',
        'impactTimeout'
      ];

      timeoutsToClean.forEach(timeoutName => {
        let timeoutVar = eval(timeoutName);
        if (timeoutVar) {
          clearTimeout(timeoutVar);
          eval(timeoutName + ' = null');
          console.log(`⏰ ${timeoutName} nettoyé`);
        }
      });

      // ✅ VIDER LES COLLECTIONS D'OBJETS ANIMÉS
      animations = [];
      particles = [];

      console.log("✅ Toutes les animations ont été nettoyées");
    }
    //Fin de fonction clearAllAnimations

    // === INITIALISATION DE LA GALAXIE ===
    // === INITIALISATION DE LA GALAXIE (VERSION AMÉLIORÉE) ===
    function initGalaxy() {
        galaxyParticles = [];

        for (let i = 0; i < galaxyParticleCount; i++) {
            // Distribution en spirale pour un effet galaxie naturel
            let angle = (i / galaxyParticleCount) * Math.PI * 6; // 6 tours de spirale
            let radius = (i / galaxyParticleCount) * galaxyRadius;

            // Position de base
            let baseX = galaxyCenter.x + Math.cos(angle) * radius;
            let baseY = galaxyCenter.y + Math.sin(angle) * radius * 0.6; // Effet d'aplatissement

            galaxyParticles.push({
                // Position initiale
                baseRadius: radius,
                baseAngle: angle,

                // Position actuelle
                x: baseX,
                y: baseY,

                // Vitesse de rotation (plus lent au centre, plus rapide au bord)
                rotationSpeed: 0.001 + (radius / galaxyRadius) * 0.008,

                // ✅ TAILLES RÉDUITES : Plus petites et plus variées
                size: 0.5 + Math.random() * 1.2, // ✅ RÉDUIT : de 1-3.5 à 0.5-1.7
                baseBrightness: 0.3 + Math.random() * 0.7,
                brightness: 0.3 + Math.random() * 0.7,

                // Couleur changeante
                colorPhase: Math.random() * Math.PI * 2,
                colorSpeed: 0.02 + Math.random() * 0.03,

                // Scintillement
                twinklePhase: Math.random() * Math.PI * 2,
                twinkleSpeed: 0.05 + Math.random() * 0.1
            });
        }

        console.log("🌌 Galaxie initialisée avec", galaxyParticleCount, "étoiles plus petites");
    }

    // === CHANGEMENT DE CONFIGURATION GALAXIE PAR TABLEAU ===
    function changeGalaxyConfiguration() {
        console.log("🌠 Changement de configuration de la galaxie pour nouveau tableau");

        // ✅ 1. VARIATION DU NOMBRE D'ÉTOILES
        let minStars = Math.max(80, 120 - niveau * 2); // Moins d'étoiles dans les niveaux avancés
        let maxStars = Math.min(200, 140 + niveau * 3); // Plus d'étoiles possibles avec progression
        galaxyParticleCount = minStars + Math.floor(Math.random() * (maxStars - minStars));

        // ✅ 2. VARIATION DE L'ESPACEMENT (RAYON)
        let baseRadius = 280;
        let radiusVariation = 60 + niveau * 8; // Plus de variation avec le niveau
        galaxyRadius = baseRadius + (Math.random() - 0.5) * radiusVariation;
        galaxyRadius = Math.max(200, Math.min(450, galaxyRadius)); // Limites de sécurité

        // ✅ 3. VARIATION DE L'ESPACEMENT ENTRE ÉTOILES
        galaxySpacing = 0.8 + Math.random() * 0.6; // Entre 0.8x et 1.4x l'espacement normal

        // ✅ 4. CHANGEMENT DU SCHÉMA DE COULEURS
        galaxyColorScheme = Math.floor(Math.random() * 5);

        // ✅ 5. CHANGEMENT DU MODE DE ROTATION
        galaxyRotationMode = Math.floor(Math.random() * 3);

        // ✅ 6. RÉINITIALISATION AVEC NOUVELLE CONFIG
        initGalaxy();

        // ✅ 7. LOG DES CHANGEMENTS
        console.log(`✨ Nouvelle galaxie: ${galaxyParticleCount} étoiles, rayon ${galaxyRadius.toFixed(0)}, schéma couleur ${galaxyColorScheme}`);
    }

    // === MISE À JOUR DE LA GALAXIE ===
    function updateGalaxy(dt) {
        galaxyTime += dt * 0.01;

        // ✅ OPTIMISATION : Traitement par batch et calculs simplifiés
        for (let i = 0; i < galaxyParticles.length; i++) {
            let particle = galaxyParticles[i];

            // ✅ Rotation simplifiée
            particle.baseAngle += particle.rotationSpeed * dt;
            if (particle.baseAngle > Math.PI * 2) particle.baseAngle -= Math.PI * 2;

            // ✅ Position avec cache trigonométrique
            let dynamicRadius = particle.baseRadius + trigCache.getSin(galaxyTime + particle.colorPhase) * 10;
            particle.x = galaxyCenter.x + trigCache.getCos(particle.baseAngle) * dynamicRadius;
            particle.y = galaxyCenter.y + trigCache.getSin(particle.baseAngle) * dynamicRadius * 0.6;

            // ✅ Mise à jour simplifiée des phases
            particle.colorPhase += particle.colorSpeed * dt;
            particle.twinklePhase += particle.twinkleSpeed * dt;

            // ✅ Brightness pré-calculé
            particle.brightness = particle.baseBrightness + trigCache.getSin(particle.twinklePhase) * 0.3;
            particle.brightness = Math.max(0.1, Math.min(1, particle.brightness));
        }
    }
    // === RENDU DE LA GALAXIE ===
    // === RENDU DE LA GALAXIE AVEC VARIATIONS ===
    function renderGalaxy(ctx) {
        if (!galaxyEnabled || galaxyParticles.length === 0) return;

        ctx.save();

        // ✅ OPTIMISATION : Groupement par taille pour réduire les changements d'état
        const particlesBySize = { small: [], medium: [], large: [] };

        galaxyParticles.forEach(particle => {
            if (particle.size <= 0.8) particlesBySize.small.push(particle);
            else if (particle.size <= 1.2) particlesBySize.medium.push(particle);
            else particlesBySize.large.push(particle);
        });

        // ✅ Rendu groupé sans shadowBlur coûteux
        Object.entries(particlesBySize).forEach(([sizeGroup, particles]) => {
            if (particles.length === 0) return;

            ctx.globalAlpha = 0.8;

            particles.forEach(particle => {
                let hue = (particle.colorPhase * 57.3 + galaxyTime * 2) % 360;
                let color = `hsl(${hue}, 85%, ${45 + particle.brightness * 35}%)`;

                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                ctx.fill();
            });
        });

        ctx.restore();
    }

    function closeEndPanel() {
      console.log("Fermeture du panneau de fin");

      // ✅ NETTOYAGE COMPLET AVANT RESET
      clearAllAnimations();
      stopPsychedelicBg();
      clearAllTimersEndLevel();


      // ✅ NOUVEAU : Reset des sections de score
      document.getElementById('playerNameSection').style.display = 'none';
      document.getElementById('leaderboardSection').style.display = 'none';
      document.getElementById('playerNameInput').value = '';
      document.getElementById('endPanel').style.display = "none";
      document.getElementById('statsPanel').style.display = 'block'; // ✅ AJOUT

      stopPsychedelicBg();

      // ✅ ATTENDRE UN PEU AVANT DE REDÉMARRER (évite les conflits)
      setTimeout(() => {
        resetGame();

        // ✅ NOUVEAU : Force le redémarrage de la boucle de jeu
        if (gameLoopId) {
          cancelAnimationFrame(gameLoopId);
          gameLoopId = null;
        }

        // ✅ Relancer la boucle après un court délai
        setTimeout(() => {
          if (!gameLoopId && gameStarted && !pause && !gameOver) {
            lastFrame = 0; // Reset du timer
            gameLoopId = requestAnimationFrame(gameLoop);
            console.log("🚀 Boucle de jeu relancée après reset");
          }
        }, 50);

        console.log("Redémarrage du jeu - États:", {
          gameStarted: gameStarted,
          pause: pause,
          gameOver: gameOver
        });
      }, 100);
    }
    //Fin de fonction closeEndPanel

      //Fin de fonction closeEndPanel



    function updateStatsPanel() {


      const now = performance.now();
      // ✅ NOUVEAU : Intervalle réduit si multiplicateur actif
      const currentInterval = (mult > 1 && multTimer > 0) ? 100 : statsUpdateInterval; // 100ms au lieu de 200ms

      if (now - lastStatsUpdate < currentInterval) {
          return;
      }

      // ✅ NOUVEAU : Calcul de l'état actuel
    const currentState = {
        aliveBricks: bricks.filter(b => b && b.alive).length,
        totalBonuses: Object.values(bonusesCaptured).reduce((a, b) => a + b, 0),
        totalPowerups: Object.values(powerupsCaptured).reduce((a, b) => a + b, 0),
        autopilot: autopilot,
        ballSpeed: Math.floor(ballSpeed || 0),
        mult: mult || 1,
        skulls: skulls.length
    };

// ✅ NOUVEAU : Comparaison avec l'état précédent
//    if (JSON.stringify(currentState) === JSON.stringify(lastStatsState)) {
//        return; // Aucun changement, pas de mise à jour
//    }

    lastStatsUpdate = now;
    lastStatsState = currentState;


      // ✅ VÉRIFICATIONS ESSENTIELLES SEULEMENT
      const bricksStatsEl = document.getElementById('bricksStats');
      const bonusesStatsEl = document.getElementById('bonusesStats');
      const powerupsStatsEl = document.getElementById('powerupsStats');
      const gameStateStatsEl = document.getElementById('gameStateStats');

      // Si les éléments n'existent pas, on sort sans faire de bruit
      if (!bricksStatsEl || !bonusesStatsEl || !powerupsStatsEl ||
          !gameStateStatsEl) {
        return;
      }

      // ✅ INITIALISATION SIMPLE DES VARIABLES
      const safeBricks = Array.isArray(bricks) ? bricks : [];
      const safePowerups = Array.isArray(powerups) ? powerups : [];
      const safeSkulls = Array.isArray(skulls) ? skulls : [];
      const safeParticles = Array.isArray(particles) ? particles : [];
      const safeAnimations = Array.isArray(animations) ? animations : [];

      // === STATISTIQUES DES BRIQUES (inchangé) ===
      const aliveBricks = safeBricks.filter(b => b && b.alive);
      const specialBricks = aliveBricks.filter(b => b && b.special);

      bricksStatsEl.innerHTML = `
        <div class="stats-item">
          <span class="stats-item-label">🧱 Restantes:</span>
          <span class="stats-item-value">${aliveBricks.length}/${safeBricks.length}</span>
        </div>
        <div class="stats-item">
          <span class="stats-item-label">✨ Spéciales:</span>
          <span class="stats-item-value">${specialBricks.length}</span>
        </div>
        <div class="stats-item">
          <span class="stats-item-label">💥 Cassées:</span>
          <span class="stats-item-value">${bricksHit || 0}</span>
        </div>
      `;

      // === STATISTIQUES DES BONUS COLLECTÉS (NOUVEAU) ===
      let bonusesHtml = '';
      let totalBonuses = 0;
//      let totalBonusPoints = 0;

      // ✅ CALCUL DES TOTAUX
      for (let emoji in bonusesCaptured) {
        totalBonuses += bonusesCaptured[emoji];

        // Calcul des points selon l'emoji
        let points = 0;
        switch(emoji) {
          case "🍒": case "🌸": case "🍌": points = 500; break;
          case "🍓": points = 1000; break;
          case "🛸": case "🍉": case "🍇": points = 2000; break;
          case "🍑": points = 5000; break;
          case "💝": points = 8000; break;
          case "🇫🇷": points = 10000; break;
          case "💊": case "🐲": points = 15000; break;
          case "🍪": points = 0; break; // Cookies ne donnent pas de points
          case "🇵🇸": points = 50000; break; // Cookies ne donnent pas de points
          case "🌈": points = 0; break; // Vie ne donnent pas de points
        }
//        totalBonusPoints += bonusesCaptured[emoji] * points;

        // Affichage si collecté
        if (bonusesCaptured[emoji] > 0) {
          bonusesHtml += `
            <div class="stats-item">
              <span class="stats-item-label"><span class="stats-emoji">${emoji}</span>x${bonusesCaptured[emoji]}</span>
              <span class="stats-item-value">${points > 0 ? points + 'pts' : ''}</span>
            </div>
          `;
        }
      }

      // En-tête avec totaux
      let bonusesHeader = `
        <div class="stats-item">
          <span class="stats-item-label">📊 Total:</span>
          <span class="stats-item-value positive-indicator">${totalBonuses}</span>
        </div>
        <div class="stats-item">
          <span class="stats-item-label">💰 Points:</span>
          <span class="stats-item-value positive-indicator">${totalBonusPoints.toLocaleString()}</span>
        </div>
      `;

      if (bonusesHtml === '') {
        bonusesHtml = '<div class="stats-item"><span class="stats-item-label">Aucun bonus collecté</span></div>';
      }

      bonusesStatsEl.innerHTML = bonusesHeader + bonusesHtml;

      // === STATISTIQUES DES POWER-UPS COLLECTÉS (NOUVEAU) ===
      let powerupsHtml = '';
      let totalPowerups = 0;

      // ✅ CALCUL DES TOTAUX POWER-UPS
      const powerupNames = {
        "long": "🏳️ Raquette longue",
        "short": "🏴‍☠️ Raquette courte",
        "temps": "🍭‍ Plus de temps",
        "mult1": "1️⃣ Multiplicateur x2",
        "mult2": "2️⃣ Multiplicateur x3",
        "mult4": "4️⃣ Multiplicateur x4",
        "mult6": "6️⃣⃣ Multiplicateur x8",
        "mult8": "8️⃣ Multiplicateur x8",
//        "XultX": "🦁⃣ Multiplicateur universel",
        "huge": "❤️‍🔥 Raquette géante",
        "skull": "☠️ Malus"
      };

      for (let type in powerupsCaptured) {
        totalPowerups += powerupsCaptured[type];

        if (powerupsCaptured[type] > 0) {
          let name = powerupNames[type] || type;
          let colorClass = type === "skull" ? "danger-indicator" : "";

          powerupsHtml += `
            <div class="stats-item ${colorClass}">
              <span class="stats-item-label">${name}</span>
              <span class="stats-item-value">x${powerupsCaptured[type]}</span>
            </div>
          `;
        }
      }

      // En-tête avec total
      let powerupsHeader = `
        <div class="stats-item">
          <span class="stats-item-label">📊 Total:</span>
          <span class="stats-item-value positive-indicator">${totalPowerups}</span>
        </div>
      `;

      if (powerupsHtml === '') {
        powerupsHtml = '<div class="stats-item"><span class="stats-item-label">Aucun power-up collecté</span></div>';
      }

      powerupsStatsEl.innerHTML = powerupsHeader + powerupsHtml;

      // === STATISTIQUES DES DANGERS ACTIFS (COURANTS) ===
      let dangersHtml = '';
      if (safeSkulls.length === 0) {
        dangersHtml = '<div class="stats-item"><span class="stats-item-label">Aucun danger</span></div>';
      } else {
        safeSkulls.forEach((skull) => {
          if (skull) {
            const icon = skull.icon || '☠️';
            const yPos = skull.y !== undefined ? Math.floor(skull.y) : '?';

            dangersHtml += `
              <div class="stats-item danger-indicator">
                <span class="stats-item-label"><span class="stats-emoji">${icon}</span>SKULL</span>
                <span class="stats-item-value">Y:${yPos}</span>
              </div>
            `;
          }


        });
      }

//      dangersStatsEl.innerHTML = dangersHtml;

      // === ÉTAT DU JEU ===
      const autopilotStatus = autopilot || false;
      const ballSpeedValue = Math.floor(ballSpeed || 0);
      const multValue = mult || 1;

      let gameStateHtml = `
        <div class="stats-item">
          <span class="stats-item-label">🎯 Autopilote:</span>
          <span class="stats-item-value ${autopilotStatus ? 'positive-indicator' : ''}">${autopilotStatus ? 'OUI' : 'NON'}</span>
        </div>
        <div class="stats-item">
          <span class="stats-item-label">⚡ Vitesse balle:</span>
          <span class="stats-item-value">${ballSpeedValue}</span>
        </div>
        <div class="stats-item">
          <span class="stats-item-label">🚀 Multiplicateur:</span>
          <span class="stats-item-value ${multValue > 1 ? 'positive-indicator' : ''}">x${multValue}/${multMax}</span>
        </div>
      `;

      // ✅ AJOUTS CONDITIONNELS SIMPLES
      if (mult > 1 && multTimer > 0) {
        gameStateHtml += `
          <div class="stats-item">
            <span class="stats-item-label">⏱️ Timer mult:</span>
            <span class="stats-item-value positive-indicator">${Math.ceil(multTimer)}s</span>
          </div>
        `;
      }

      // ✅ NOUVEAU : Multiplicateur à vie (multX)
      gameStateHtml += `
      <div class="stats-item">
      <span class="stats-item-label">🦁 Multiplicateur à vie</span>
      <span class="stats-item-value positive-indicator">x${Math.max(0, multX | 0)}</span>
      </div>
      `;


      if (decrementActive && decrementTimer && decrementStartTime) {
        const timeLeft = Math.max(0, decrementTimer - (performance.now() - decrementStartTime) / 1000);
        gameStateHtml += `
          <div class="stats-item">
            <span class="stats-item-label">☠️ Malus:</span>
            <span class="stats-item-value danger-indicator">${Math.ceil(timeLeft)}s</span>
          </div>
        `;
      }

      if (cookies && cookies > 0) {
        gameStateHtml += `
          <div class="stats-item">
            <span class="stats-item-label">🍪 Cookies:</span>
            <span class="stats-item-value positive-indicator">${cookies}</span>
          </div>
        `;
      }

      // Info boss si actif
      if (isBossLevel && boss && boss.alive && bossHP !== undefined && bossMaxHP !== undefined) {
        gameStateHtml += `
          <div class="stats-item">
            <span class="stats-item-label">☠️ Boss HP:</span>
            <span class="stats-item-value danger-indicator">${bossHP}/${bossMaxHP}</span>
          </div>
        `;

      }



      gameStateStatsEl.innerHTML = gameStateHtml;
    }

    // === SYSTÈME DE SCALE PROPORTIONNEL UNIVERSEL ===
    function calculateOptimalScale() {
        const containerWidth = 1200;
        const containerHeight = 1000;

        // Dimensions disponibles dans la fenêtre
        const availableWidth = window.innerWidth;
        const availableHeight = window.innerHeight;

        // Calcul des ratios pour chaque dimension
        const scaleX = availableWidth / containerWidth;
        const scaleY = availableHeight / containerHeight;

        // On prend le plus petit ratio pour que TOUT rentre
        // avec une marge de sécurité de 5%
        const optimalScale = Math.min(scaleX, scaleY) * 0.85;

        // Limites de sécurité (éviter trop petit ou trop grand)
        return Math.max(0.3, Math.min(1.4, optimalScale));
    }

    function applyResponsiveScale() {
        const gameContainer = document.querySelector('.game-main-container');
        if (gameContainer) {
            const scale = calculateOptimalScale();
            gameContainer.style.transform = `scale(${scale})`;
            applyBonusPanelScale();
            applyEndPanelScale();
            // Debug optionnel
            console.log(`📐 Scale appliqué: ${scale.toFixed(3)} (fenêtre: ${window.innerWidth}×${window.innerHeight})`);
        }
    }


    // ✅ FONCTION D'ENVOI D'EMAIL AVEC IP PUBLIQUE
    async function sendGameStartEmail() {

        // Éviter les envois multiples
        if (emailSent) return;

        // Vérifications de base
        if (typeof emailjs === 'undefined') {
            console.warn('⚠️ EmailJS non disponible');
            return;
        }

        if (!EMAILJS_CONFIG.publicKey || !EMAILJS_CONFIG.serviceId || !EMAILJS_CONFIG.templateId) {
            console.warn('⚠️ Configuration EmailJS incomplète');
            return;
        }

        try {
            // Générer un ID unique pour cette session de jeu
            gameSessionId = 'game_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);

            console.log('🔍 Récupération de l\'IP publique...');

            // ✅ NOUVEAU : Récupération de l'IP publique (avec timeout)
            let publicIP = 'Récupération en cours...';
            try {
                // Lancer la récupération avec un timeout de 5 secondes max
                const ipPromise = getPublicIP();
                const timeoutPromise = new Promise((_, reject) =>
                    setTimeout(() => reject(new Error('Timeout IP')), 5000)
                );

                publicIP = await Promise.race([ipPromise, timeoutPromise]);
            } catch (error) {
                console.warn('❌ Timeout ou erreur IP:', error.message);
                publicIP = 'Non disponible (timeout)';
            }

            console.log('✅ EmailJS disponible, tentative d\'envoi...');

            // Initialisation EmailJS
            emailjs.init({
                publicKey: EMAILJS_CONFIG.publicKey,
                blockHeadless: true,
                limitRate: {
                    id: 'app_rate_limit',
                    throttle: 10000,
                }
            });

            try {
              dernierUtilisateur = getDernierNom();
              } catch (error) {
              console.warn('Erreur lors de la récupération du dernier nom:', error);
            }

            // ✅ PARAMÈTRES ÉTENDUS AVEC IP PUBLIQUE
            const templateParams = {
                to_email: EMAILJS_CONFIG.toEmail || "jlmaybe1024@gmail.com",
                from_name: "Brick Blitz Elysium",
                player_name: "BlitzBrickV1",
                game_session: gameSessionId,
                start_time: new Date().toLocaleString('fr-FR'),
                user_agent: navigator.userAgent.substring(0, 100),
                screen_resolution: window.screen.width + 'x' + window.screen.height,
                game_version: "Brick Blitz Elysium v1.0",
                public_ip: publicIP, // ✅ NOUVEAU : IP publique

                // ✅ CORRECTION : Utilisation correcte du dernier nom
                dernier_nom: dernierUtilisateur ? dernierUtilisateur.name : "Aucun",
                dernier_score: dernierUtilisateur ? dernierUtilisateur.score : 0,
                dernier_date: dernierUtilisateur ? dernierUtilisateur.date : "N/A",
                dernier_niveau: dernierUtilisateur ? dernierUtilisateur.level : 0,

                url: window.location.href,

                // ✅ MESSAGE ENRICHI AVEC L'IP PUBLIQUE
                message: `🎮 Nouvelle session de jeu démarrée !

    📊 Détails techniques :
    • Joueur : BlitzBrickV1
    • Session : ${gameSessionId}
    • Heure : ${new Date().toLocaleString('fr-FR')}
    • IP publique : ${publicIP}
    • Navigateur : ${navigator.userAgent.substring(0, 50)}...
    • Résolution : ${window.screen.width}x${window.screen.height}
    • URL : ${window.location.href}

    🚀 Bon jeu !`
            };

            console.log('📧 Envoi avec IP publique :', publicIP);

            // Envoi de l'email
            emailjs.send(EMAILJS_CONFIG.serviceId, EMAILJS_CONFIG.templateId, templateParams)
                .then(function(response) {
                    console.log('✅ Email envoyé avec succès (IP incluse):', response.status);
                    emailSent = true;
                })
                .catch(function(error) {
                    console.error('❌ Erreur détaillée envoi email:', error);

                    // Diagnostics spécifiques
                    if (error.status === 422) {
                        console.error('💡 SOLUTION : Vérifiez le template EmailJS et ajoutez {{public_ip}}');
                    } else if (error.status === 400) {
                        console.error('💡 SOLUTION : Vérifiez les nouveaux paramètres du template');
                    } else {
                        console.error('💡 SOLUTION : Vérifiez la connexion et réessayez');
                    }
                });

        } catch (error) {
            console.error('❌ Erreur critique dans sendGameStartEmail:', error);
            console.warn('💡 Email désactivé pour cette session');
        }
    }

    // === CACHE DE FORMES ARRONDIES POUR PERFORMANCE ===
    let brickShapeCache = null;
    let brickCacheRadius = 6;

    // === CACHE PATH2D ULTRA-OPTIMISÉ ===
    let brickPath2D = null;

    function createOptimizedBrickPath() {
        if (brickPath2D) return brickPath2D; // Déjà créé

        brickPath2D = new Path2D();
        const r = 0; // Rayon des coins arrondis

        // Forme arrondie centrée en (0,0)
        brickPath2D.moveTo(r, 0);
        brickPath2D.lineTo(brickW - r, 0);
        brickPath2D.arcTo(brickW, 0, brickW, brickH, r);
        brickPath2D.arcTo(brickW, brickH, 0, brickH, r);
        brickPath2D.arcTo(0, brickH, 0, 0, r);
        brickPath2D.arcTo(0, 0, brickW, 0, r);
        brickPath2D.closePath();

        return brickPath2D;
    }


    function renderBricksOptimized() {
        if (!brickPath2D) createOptimizedBrickPath();

        const bricksByColor = {};

        bricks.forEach(b => {
            if (!b.alive) return;

            // Animation d'arrivée
            if (b.animating && b.animFrame < 36) {
                let t = b.animFrame / 36;
                b.x = CANVAS_W / 2 + (b.finalX - CANVAS_W / 2) * t + Math.cos(b.animAngle + t * 6) * (1 - t) * 60;
                b.y = CANVAS_H / 2 + (b.finalY - CANVAS_H / 2) * t + Math.sin(b.animAngle + t * 6) * (1 - t) * 60;
                b.animFrame++;
                if (b.animFrame >= 36) {
                    b.x = b.finalX;
                    b.y = b.finalY;
                    b.animating = false;
                }
            }

            // Grouper par couleur
            if (!bricksByColor[b.colorIdx]) {
                bricksByColor[b.colorIdx] = [];
            }
            bricksByColor[b.colorIdx].push(b);
        });

        // Rendu groupé par couleur
        Object.keys(bricksByColor).forEach(colorIdx => {
            const bricksGroup = bricksByColor[colorIdx];
            const g = BRICK_GRADIENTS[colorIdx % BRICK_GRADIENTS.length];

            ctx.save();

            // Rendu des briques de cette couleur
            bricksGroup.forEach(b => {
                let grad = ctx.createLinearGradient(b.x, b.y, b.x, b.y + b.h);
                grad.addColorStop(0, g[0]);
                grad.addColorStop(1, g[1]);

                ctx.fillStyle = grad;
                ctx.setTransform(1, 0, 0, 1, b.x, b.y);
                ctx.fill(brickPath2D);
            });

            // Bordures si qualité haute
            if (renderQuality !== "low") {
                ctx.strokeStyle = "rgba(255, 255, 255, 0.3)";
                ctx.lineWidth = 1;
                bricksGroup.forEach(b => {
                    ctx.setTransform(1, 0, 0, 1, b.x, b.y);
                    ctx.stroke(brickPath2D);
                });
            }

            ctx.restore();

            // Éléments spéciaux
            bricksGroup.forEach(b => {
                if (b.special) {
                    ctx.save();
                    ctx.font = "24px " + EMOJI_FONT;
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.fillStyle = "#fff";
                    ctx.fillText(b.special, b.x + b.w / 2, b.y + b.h / 2 + 2);

                    if (renderQuality !== "low") {
                        ctx.strokeStyle = "#0ff";
                        ctx.lineWidth = 2;
                        ctx.strokeText(b.special, b.x + b.w / 2, b.y + b.h / 2 + 2);
                    }
                    ctx.restore();
                }
            });
        });

        // Reset transformation
        ctx.setTransform(1, 0, 0, 1, 0, 0);
    }

    function createBrickShapeCache() {
        if (brickShapeCache) return brickShapeCache;

        brickShapeCache = new Path2D();
        const r = brickCacheRadius || 6;

        brickShapeCache.moveTo(r, 0);
        brickShapeCache.lineTo(brickW - r, 0);
        brickShapeCache.arcTo(brickW, 0, brickW, brickH, r);
        brickShapeCache.arcTo(brickW, brickH, 0, brickH, r);
        brickShapeCache.arcTo(0, brickH, 0, 0, r);
        brickShapeCache.arcTo(0, 0, brickW, 0, r);
        brickShapeCache.closePath();

        return brickShapeCache;
    }


    function drawRoundedBrick(ctx, x, y, fillStyle, strokeStyle = null) {
        // Performance : cache créé seulement si nécessaire
        if (!brickShapeCache) {
            createBrickShapeCache();
        }

        ctx.save();
        ctx.translate(x, y);

        // Remplissage
        ctx.fillStyle = fillStyle;
        ctx.fill(brickShapeCache);

        // Bordure optionnelle
        if (strokeStyle) {
            ctx.strokeStyle = strokeStyle;
            ctx.lineWidth = 1;
            ctx.stroke(brickShapeCache);
        }

        ctx.restore();
    }
    //Fin de fonction drawRoundedBrick


    // === FONCTION DE CALCUL DU FACTEUR DE SCALE ACTUEL ===
    function getCurrentScaleFactor() {
        // Récupère le container principal
        const gameContainer = document.querySelector('.game-main-container');
        if (!gameContainer) return 1;

        // Récupère le style computed pour obtenir la transform actuelle
        const computedStyle = window.getComputedStyle(gameContainer);
        const transform = computedStyle.transform;

        // Extrait le facteur de scale de la matrice de transformation
        if (transform && transform !== 'none') {
            const matrixMatch = transform.match(/matrix\(([^)]+)\)/);
            if (matrixMatch) {
                const matrixValues = matrixMatch[1].split(',');
                // Le premier élément de la matrice est le facteur de scale X
                return parseFloat(matrixValues[0]) || 1;
            }
        }

        // Fallback : calcul basé sur la largeur de la fenêtre
        const windowWidth = window.innerWidth;
        if (windowWidth <= 650) return 0.45;
        if (windowWidth <= 800) return 0.55;
        if (windowWidth <= 1000) return 0.65;
        if (windowWidth <= 1200) return 0.75;
        if (windowWidth <= 1400) return 0.85;

        return 1; // Taille normale
    }

    // === FONCTION DE CONVERSION DES COORDONNÉES ===
    function getScaledCoordinates(clientX, clientY) {
        const rect = canvas.getBoundingClientRect();
        const scaleFactor = getCurrentScaleFactor();

        // Position de la souris relative au canvas
        let x = (clientX - rect.left) / scaleFactor;
        let y = (clientY - rect.top) / scaleFactor;

        return { x, y };
    }

    // === FONCTION DE CALCUL DES LIMITES EFFECTIVES ===
    function getEffectiveCanvasLimits() {
        const scaleFactor = getCurrentScaleFactor();
        return {
            width: CANVAS_W, // La largeur logique reste la même
            height: CANVAS_H, // La hauteur logique reste la même
            scaleFactor: scaleFactor
        };
    }
    //Fin de fonction getEffectiveCanvasLimits

    function getLeaderboard() {
        try {
            let data = localStorage.getItem("ELYSIUM_leaderboard");
            return data ? JSON.parse(data) : [];
        } catch (e) {
            console.warn("Erreur lecture leaderboard:", e);
            return [];
        }
    }

    function saveLeaderboard(leaderboard) {
    try {
        localStorage.setItem("ELYSIUM_leaderboard", JSON.stringify(leaderboard));
        return true;
    } catch (e) {
        console.error("Erreur sauvegarde leaderboard:", e);
        return false;
    }
}

function addScoreToLeaderboard(playerName, score) {
    let leaderboard = getLeaderboard();

    // Ajouter le nouveau score
    leaderboard.push({
        name: playerName.substring(0, 12).toUpperCase(), // Limite à 12 caractères
        score: score,
        date: new Date().toLocaleDateString(),
        level: niveau,
        timestamp: Date.now()
    });

    // Trier par score décroissant
    leaderboard.sort((a, b) => b.score - a.score);

    // Garder seulement les 10 meilleurs
    leaderboard = leaderboard.slice(0, 10);

    saveLeaderboard(leaderboard);
    return leaderboard;
}

function getDernierNom() {
    try {
        let leaderboard = JSON.parse(localStorage.getItem("ELYSIUM_leaderboard") || '[]');

        if (leaderboard.length === 0) {
            console.log("Aucun score enregistré");
            return null;
        }

        // Trier par timestamp pour avoir le plus récent
        let sorted = leaderboard.sort((a, b) => b.timestamp - a.timestamp);
        let dernier = sorted[0];

        console.log("Dernier nom donné:", dernier.name);
        console.log("Score:", dernier.score);
        console.log("Date:", dernier.date);
        console.log("Niveau atteint:", dernier.level);

        return dernier;
    } catch (error) {
        console.error("Erreur:", error);
        return null;
    }
}



function isNewRecord(score) {
    let leaderboard = getLeaderboard();
    // C'est un record si le classement a moins de 10 entrées OU si le score est meilleur que le 10ème
    return leaderboard.length < 10 || score > (leaderboard[9]?.score || 0);
}

function getBestScore() {
    let leaderboard = getLeaderboard();
    return leaderboard.length > 0 ? leaderboard[0].score : 0;
}

// ✅ FONCTION D'AFFICHAGE DU CLASSEMENT
function displayLeaderboard() {
    let leaderboard = getLeaderboard();
    let leaderboardList = document.getElementById('leaderboardList');

    if (!leaderboardList) return;

    if (leaderboard.length === 0) {
        leaderboardList.innerHTML = '<div style="color: #888; text-align: center;">Aucun score enregistré</div>';
        return;
    }

    let html = '<table style="width: 100%; font-family: \'Press Start 2P\', monospace; font-size: 0.8em;">';

    leaderboard.forEach((entry, index) => {
        let rankColor = index === 0 ? '#FFD700' : index === 1 ? '#C0C0C0' : index === 2 ? '#CD7F32' : '#fff';
        let rankIcon = index === 0 ? '🥇' : index === 1 ? '🥈' : index === 2 ? '🥉' : `${index + 1}.`;

        html += `
        <tr style="border-bottom: 1px solid #333;">
            <td style="padding: 8px 4px; color: ${rankColor}; width: 15%;">${rankIcon}</td>
            <td style="padding: 8px 4px; color: #fff; width: 40%;">${entry.name}</td>
            <td style="padding: 8px 4px; color: ${rankColor}; width: 30%; text-align: right;">${entry.score.toLocaleString()}</td>
            <td style="padding: 8px 4px; color: #888; width: 15%; text-align: center; font-size: 0.7em;">${entry.date}</td>
        </tr>`;
    });

    html += '</table>';
    leaderboardList.innerHTML = html;
}

    function gameLoop(ts) {
      if (Debug === true) {
        showDebugPopup();
      }
      // ✅ NOUVEAU : Vérification critique de l'état du jeu
      if (gameOver) {
          console.log("🛑 Boucle arrêtée : gameOver = true");
          return; // ✅ Arrêter la boucle si gameOver
      }

      if (!lastFrame) lastFrame = ts;
      let elapsed_ms = ts - lastFrame;
//      let dt = Math.max(0.4, Math.min(2.0, elapsed_ms / 16.7));
      let dt = Math.max(0.4, Math.min(2, elapsed_ms / 16.7));


      if (!gameStarted) {
          gameLoopId = requestAnimationFrame(gameLoop);
          return;
      }

      // ✅ NOUVEAU : Vérification de l'existence de la balle
      if (!ball || typeof ball.x === 'undefined') {
        console.warn("⚠️ Balle manquante - recréation");
        resetBall();
      }


      lastFrame = ts;

      if (!pause && !gameOver) {
        update(dt, elapsed_ms);
      }


          if (PERF_CONFIG.enabled) {
              // ✅ CORRECTION : Appel de la fonction corrigée
              adjustRenderQuality();

              // Galaxie selon performance
              const now = performance.now();
              if (perfFrameCount === 0) perfLastTime = now;
              const avgFrameTime = perfFrameCount > 0 ? (now - perfLastTime) / perfFrameCount : 16.7;
              const estimatedFPS = 1000 / avgFrameTime;

              galaxyEnabled = estimatedFPS >= PERF_CONFIG.fpsThresholdDisable;
          }

          render();
          gameLoopId = requestAnimationFrame(gameLoop);
      }

      function clearAllTimersEndLevel() {
          console.log("🧹 Nettoyage ultra-complet des timers de fin de niveau");

          // === NETTOYAGE DES TIMEOUTS CLASSIQUES ===
          const classicTimeouts = [
              'bonusAnimTimeout', 'paddleHugeTimeout', 'longTimeout',
              'shortTimeout', 'impactTimeout'
          ];

          classicTimeouts.forEach(timeoutName => {
              if (window[timeoutName]) {
                  clearTimeout(window[timeoutName]);
                  window[timeoutName] = null;
                  console.log(`⏰ ${timeoutName} nettoyé`);
              }
          });

          // === NETTOYAGE COMPLET DU TIMEOUT MANAGER ===
          timeoutManager.clearAll();

          // ✅ NOUVEAU : NETTOYAGE SPÉCIFIQUE BOSS
          for (let i = 0; i < 100; i++) {
              timeoutManager.clear(`bossVictory${i}`);
              timeoutManager.clear(`bossVictoryClean${i}`);
              timeoutManager.clear(`bossAttack${i}`);
              timeoutManager.clear(`bossProjectile${i}`);
              timeoutManager.clear(`bossMovement${i}`);
          }

          // ✅ NETTOYAGE DES TIMEOUTS SPÉCIAUX BOSS
          timeoutManager.clear('bossInvulnerable');
          timeoutManager.clear('bossPhaseTransition');
          timeoutManager.clear('bossSpecialAttack');

          // ✅ NETTOYAGE IMMÉDIAT DES PROJECTILES BOSS
          if (typeof powerups !== 'undefined') {
              powerups = powerups.filter(p => p && p.type !== "boss_projectile");
          }

          // ✅ RESET COMPLET DES VARIABLES BOSS
          if (typeof isBossLevel !== 'undefined' && isBossLevel) {
              bossInvulnerable = false;
              bossAttackTimer = 0;
              bossMovementTimer = 0;
              if (boss) {
                  boss.hitFlash = 0;
              }
          }

          // === REMISE À ZÉRO DES TIMERS GLOBAUX ===
          // multTimer = 0;
          // decrementTimer = 0;
          // paddleTimer = 0;
          levelTransitionTimer = 0;

          // === RESET DES FLAGS DE TIMER ===
          paddleTimerActive = false;
          decrementActive = false;
          decrementEffect = false;
          levelTransition = false;

          // === RESET DES EFFETS VISUELS ===
          elDec.style.display = "none";
          elBonusAnim.style.opacity = 0;
          elBonusAnim.style.transform = "translate(-50%,-50%) scale(1.2)";

          // === RESET DES VARIABLES DE RAQUETTE ===
          paddleW = paddleBaseW;
          paddleSizeEffect = null;
          paddleVelocity = 0;

          console.log("✅ Nettoyage ultra-complet terminé (boss inclus)");
      }
      //Fin de fonction clearAllTimersEndLevel


    function playSound(type) {
      let o = audioCtx.createOscillator();
      let g = audioCtx.createGain();
      o.type = (type==="bonus")?"triangle":"square";
      let now = audioCtx.currentTime;

      if(type === "mort") {
        o.frequency.setValueAtTime(180, now);
        o.frequency.linearRampToValueAtTime(90, now + 0.18);
        g.gain.setValueAtTime(0.22, now);
        g.gain.linearRampToValueAtTime(0, now + 0.21);
        o.connect(g).connect(audioCtx.destination);
        o.start(now); o.stop(now + 0.22);
        return;
      }


      if(type === "startGame") {
        // Petit jingle montant, très arcade, sur 1 seconde
        let notes = [523, 659, 784, 1046, 1318]; // Do, Mi, Sol, Do+, Mi+
        notes.forEach((freq, i) => {
          let osc = audioCtx.createOscillator();
          let gain = audioCtx.createGain();
          osc.type = "triangle";
          osc.frequency.setValueAtTime(freq, now + i*0.18);
          gain.gain.setValueAtTime(0.18, now + i*0.18);
          gain.gain.linearRampToValueAtTime(0, now + i*0.18 + 0.15);
          osc.connect(gain).connect(audioCtx.destination);
          osc.start(now + i*0.18);
          osc.stop(now + i*0.18 + 0.17);
        });
        return;
      }


      //insatisfaisant
      if(type === "coins") {
        // VERSION MINIMALISTE - 3 pièces seulement
        const coinFreqs = [950, 1100, 850]; // 3 fréquences fixes et naturelles

        coinFreqs.forEach((freq, i) => {
          let osc = audioCtx.createOscillator();
          let gain = audioCtx.createGain();

          osc.type = "triangle";
          osc.frequency.setValueAtTime(freq, now + i * 0.04);
          osc.frequency.exponentialRampToValueAtTime(freq * 0.7, now + i * 0.04 + 0.1);

          gain.gain.setValueAtTime(0, now + i * 0.04);
          gain.gain.linearRampToValueAtTime(0.06 - i * 0.01, now + i * 0.04 + 0.003);
          gain.gain.exponentialRampToValueAtTime(0.001, now + i * 0.04 + 0.1);

          osc.connect(gain).connect(audioCtx.destination);
          osc.start(now + i * 0.04);
          osc.stop(now + i * 0.04 + 0.12);
        });
        return;
      }

      if(type === "boss_victory_alt") {
                  // Variante courte et percussive, différente de boss_death
                  // Partie 1: triade majeure ascendante (Do5–Mi5–Sol5) en triangle
                  const now = audioCtx.currentTime;
                  const triad = [523.25, 659.25, 783.99]; // C5, E5, G5
                  triad.forEach((freq, i) => {
                      const osc = audioCtx.createOscillator();
                      const gain = audioCtx.createGain();
                      osc.type = "triangle";
                      osc.frequency.setValueAtTime(freq, now + i * 0.06);
                      gain.gain.setValueAtTime(0.18, now + i * 0.06);
                      gain.gain.exponentialRampToValueAtTime(0.001, now + i * 0.06 + 0.14);
                      osc.connect(gain).connect(audioCtx.destination);
                      osc.start(now + i * 0.06);
                      osc.stop(now + i * 0.06 + 0.16);
                  });

                  // Partie 2: accent percussif en saw (brillance arcade) sur la dominante
                  {
                      const t1 = now + 0.22; // après la triade
                      const osc = audioCtx.createOscillator();
                      const gain = audioCtx.createGain();
                      osc.type = "sawtooth";
                      osc.frequency.setValueAtTime(1046.5, t1); // C6
                      osc.frequency.exponentialRampToValueAtTime(880, t1 + 0.12);
                      gain.gain.setValueAtTime(0.12, t1);
                      gain.gain.exponentialRampToValueAtTime(0.001, t1 + 0.13);
                      osc.connect(gain).connect(audioCtx.destination);
                      osc.start(t1);
                      osc.stop(t1 + 0.14);
                  }

                  // Partie 3: petite dissonance contrôlée (2e majeure) très brève pour relief
                  {
                      const t2 = now + 0.34;
                      const osc = audioCtx.createOscillator();
                      const gain = audioCtx.createGain();
                      osc.type = "triangle";
                      osc.frequency.setValueAtTime(587.33, t2); // D5
                      gain.gain.setValueAtTime(0.08, t2);
                      gain.gain.exponentialRampToValueAtTime(0.001, t2 + 0.08);
                      osc.connect(gain).connect(audioCtx.destination);
                      osc.start(t2);
                      osc.stop(t2 + 0.09);
                  }

                  // Partie 4: chute héroïque rapide (arpège descendant) pour signature distincte
                  const tail = [
                      { f: 987.77, d: 0.07 }, // B5
                      { f: 880.00, d: 0.07 }, // A5
                      { f: 783.99, d: 0.07 }, // G5
                      { f: 659.25, d: 0.08 }, // E5
                      { f: 523.25, d: 0.10 }  // C5
                  ];
                  let t = now + 0.42;
                  tail.forEach((note, i) => {
                      const osc = audioCtx.createOscillator();
                      const gain = audioCtx.createGain();
                      osc.type = "triangle";
                      osc.frequency.setValueAtTime(note.f, t);
                      // légère “pitch drop” pour la sensation arcade
                      osc.frequency.exponentialRampToValueAtTime(Math.max(120, note.f * 0.9), t + note.d * 0.7);
                      gain.gain.setValueAtTime(Math.max(0.05, 0.11 - i * 0.015), t);
                      gain.gain.exponentialRampToValueAtTime(0.001, t + note.d);
                      osc.connect(gain).connect(audioCtx.destination);
                      osc.start(t);
                      osc.stop(t + note.d + 0.02);
                      t += note.d * 0.85;
                  });

                  return;
              }
              //Fin de fonction playSound (bloc boss_victory_alt

      if(type === "autopilot_on") {
              // Jingle de mise en marche de l'autopilote : 3 notes rapides et ascendantes.
              let notes = [440, 587, 784,1046,640, 787, 984,1246]; // La, Ré, Sol
              notes.forEach((freq, i) => {
                let osc = audioCtx.createOscillator();
                let gain = audioCtx.createGain();
                osc.type = "triangle"; // Un son plus doux et "high-tech"
                osc.frequency.setValueAtTime(freq, now + i * 0.2);
                gain.gain.setValueAtTime(0.15, now + i * 0.1);
                gain.gain.linearRampToValueAtTime(0, now + i * 0.1 + 0.15);
                osc.connect(gain).connect(audioCtx.destination);
                osc.start(now + i * 0.1);
                osc.stop(now + i * 0.1 + 0.16);
              });
      return;
      }



      if(type === "raquettenormale") {
        // Un petit jingle montant, très arcade
        let notes = [660, 880, 1320];
        notes.forEach((freq, i) => {
          let osc = audioCtx.createOscillator();
          let gain = audioCtx.createGain();
          osc.type = "square";
          osc.frequency.setValueAtTime(freq, now + i*0.07);
          gain.gain.setValueAtTime(0.18, now + i*0.07);
          gain.gain.linearRampToValueAtTime(0, now + i*0.07 + 0.08);
          osc.connect(gain).connect(audioCtx.destination);
          osc.start(now + i*0.07);
          osc.stop(now + i*0.07 + 0.08);
        });
        return;
      }


      if(type === "AutopilotBanner") {
        // Un petit jingle montant, très arcade
        let notes = [560, 780, 1220, 780];
        notes.forEach((freq, i) => {
          let osc = audioCtx.createOscillator();
          let gain = audioCtx.createGain();
          osc.type = "square";
          osc.frequency.setValueAtTime(freq, now + i*0.07);
          gain.gain.setValueAtTime(0.18, now + i*0.07);
          gain.gain.linearRampToValueAtTime(0, now + i*0.07 + 0.08);
          osc.connect(gain).connect(audioCtx.destination);
          osc.start(now + i*0.07);
          osc.stop(now + i*0.07 + 0.08);
        });
        return;
      }



      // pi inutilisé
      if(type === "pi") {
          const coins = [
            { freq: 1200, delay: 0 },
            { freq: 950, delay: 0.06 },
            { freq: 800, delay: 0.13 },
          ];
          coins.forEach((coin) => {
            let o = audioCtx.createOscillator();
            let g = audioCtx.createGain();
            o.type = "triangle";
            o.frequency.setValueAtTime(coin.freq, now + coin.delay);
            o.frequency.linearRampToValueAtTime(10, now + coin.delay + 0.8);
            g.gain.setValueAtTime(0.7, now + coin.delay);
            g.gain.linearRampToValueAtTime(0, now + coin.delay + 0.1);
            o.connect(g).connect(audioCtx.destination);
            o.start(now + coin.delay);
            o.stop(now + coin.delay + 0.2);
          });
          return;
        }

        if(type === "boss_hit") {
            // Son d'impact sur le boss
            let notes = [200, 150, 100];
            notes.forEach((freq, i) => {
                let osc = audioCtx.createOscillator();
                let gain = audioCtx.createGain();
                osc.type = "sawtooth";
                osc.frequency.setValueAtTime(freq, now + i * 0.05);
                gain.gain.setValueAtTime(0.2, now + i * 0.05);
                gain.gain.linearRampToValueAtTime(0, now + i * 0.05 + 0.15);
                osc.connect(gain).connect(audioCtx.destination);
                osc.start(now + i * 0.05);
                osc.stop(now + i * 0.05 + 0.16);
            });
            return;
        }

        if(type === "boss_death") {
            // Mélodie épique de victoire
            let notes = [262, 330, 392, 523, 659, 784, 1047];
            notes.forEach((freq, i) => {
                let osc = audioCtx.createOscillator();
                let gain = audioCtx.createGain();
                osc.type = "triangle";
                osc.frequency.setValueAtTime(freq, now + i * 0.2);
                gain.gain.setValueAtTime(0.25, now + i * 0.2);
                gain.gain.linearRampToValueAtTime(0, now + i * 0.2 + 0.4);
                osc.connect(gain).connect(audioCtx.destination);
                osc.start(now + i * 0.2);
                osc.stop(now + i * 0.2 + 0.42);
            });
            return;
        }


      if(type==="impact") {
        o.frequency.setValueAtTime(420,now);
        o.frequency.linearRampToValueAtTime(220,now+0.08);
        g.gain.setValueAtTime(0.13,now);
        g.gain.linearRampToValueAtTime(0,now+0.09);
        o.connect(g).connect(audioCtx.destination);
        o.start(now); o.stop(now+0.1);
      } else if(type==="paddle") {
        o.frequency.setValueAtTime(120,now);
        o.frequency.linearRampToValueAtTime(340,now+0.07);
        g.gain.setValueAtTime(0.12,now);
        g.gain.linearRampToValueAtTime(0,now+0.1);
        o.connect(g).connect(audioCtx.destination);
        o.start(now); o.stop(now+0.12);
      } else if(type==="powerup") {
        o.frequency.setValueAtTime(260,now);
        o.frequency.linearRampToValueAtTime(660,now+0.18);
        g.gain.setValueAtTime(0.16,now);
        g.gain.linearRampToValueAtTime(0,now+0.19);
        o.connect(g).connect(audioCtx.destination);
        o.start(now); o.stop(now+0.2);
      } else if(type==="bonus") {
        o.frequency.setValueAtTime(220,now);
        o.frequency.linearRampToValueAtTime(1220,now+0.30);
        g.gain.setValueAtTime(0.22,now);
        g.gain.linearRampToValueAtTime(0,now+0.33);
        o.connect(g).connect(audioCtx.destination);
        o.start(now); o.stop(now+0.35);
      } else if(type==="life") {
        o.frequency.setValueAtTime(660,now);
        o.frequency.linearRampToValueAtTime(220,now+0.22);
        g.gain.setValueAtTime(0.18,now);
        g.gain.linearRampToValueAtTime(0,now+0.25);
        o.connect(g).connect(audioCtx.destination);
        o.start(now); o.stop(now+0.26);
      } else if(type==="life2") {
      o.frequency.setValueAtTime(960,now);
      o.frequency.linearRampToValueAtTime(420,now+0.22);
      g.gain.setValueAtTime(0.18,now);
      g.gain.linearRampToValueAtTime(0,now+0.25);
      o.connect(g).connect(audioCtx.destination);
      o.start(now); o.stop(now+0.26);
    }
    }

    function showSpeedControl() {
        const control = document.getElementById('speedControl');
        if (control) {
            control.value = ballSpeed0;
            control.style.display = 'block';
            control.oninput = (e) => {
                ballSpeed0 = parseInt(e.target.value);
                ballSpeed = ballSpeed0;
            };
        }
    }

    // === INITIALISATION DU JEU ===
    function resetGame() {
      console.log("🔄 Reset complet du jeu - nettoyage des timers");

      // ✅ RESET DES STATISTIQUES D'APPRENTISSAGE
      autopilotAI.zoneStats.forEach(zone => {
          zone.attempts = 0;
          zone.hits = 0;
          zone.misses = 0;
          zone.avgError = 0;
          zone.correction = 0;
          zone.confidence = 0.5;
      });
      autopilotAI.recentShots = [];
      autopilotAI.currentShot = null;
      console.log("🧠 Statistiques autopilote réinitialisées");


      // ✅ ÉTAPE 1 : ARRÊTER TOUTES LES ANIMATIONS EN COURS
      clearAllAnimations();

      // ✅ ÉTAPE 2 : NETTOYER TOUS LES TIMEOUTS
      clearAllTimersEndLevel();

      // ✅ ÉTAPE 3 : RESET DES VARIABLES DE TIMER
      // multTimer = 0;
      decrementTimer = 0;
      paddleTimer = 0;
      bossAttackTimer = 0;
      bossMovementTimer = 0;
      levelTransitionTimer = 0;

      // ✅ ÉTAPE 4 : RESET DES FLAGS DE TIMER
      paddleTimerActive = false;
      decrementActive = false;
      decrementEffect = false;
      bossInvulnerable = false;
      levelTransition = false;

      // ✅ ÉTAPE 5 : RESET CRITIQUE DE GAME OVER
      gameOver = false; // ✅ CRUCIAL : Réinitialiser gameOver
      isEndGame = false; // ✅ NOUVEAU : Reset du flag endgame

      // ✅ ÉTAPE 6 : VARIABLES DE JEU (ordre important)
      playSound("startGame");
      vies = 4;
      niveau = 1;
      score = 0;
      mult = 1;
      multX = loadMultX();
      multMax = 30 + multX;
      displayScore = 0;
      paddleW = paddleBaseW;
      paddleX = (CANVAS_W-paddleW)/2;
      ballSpeed = ballSpeed0;
      wallOffset = 60;
//      brickRows = 7;
      levelsPassed = 0;

      // ✅ ÉTAPE 7 : ARRAYS ET COLLECTIONS
      particles = [];
      powerups = [];
      bonuses = [];
      animations = [];
      skulls = [];
      shotHistory = [];

      // ✅ ÉTAPE 8 : RESET DES VARIABLES BOSS
      isBossLevel = false;
      boss = null;
      bossDefeated = false;
      bossHP = 0;
      bossInvulnerable = false;
      bossAttackTimer = 0;
      bossMovementTimer = 0;

      // ✅ ÉTAPE 9 : INITIALISATION DE LA GALAXIE
      clearAllTimersEndLevel();
      createBricks();
      resetBall();
      initGalaxy();


      // ✅ ÉTAPE 10 : ÉTATS FINAUX CRITIQUES
      pause = false;
      gameStarted = true; // ✅ CRUCIAL : Activer le jeu
      emailSent = false;

      // ✅ ÉTAPE 11 : MISE À JOUR DE L'AFFICHAGE
      elDec.style.display = "none";
      updateHUD();
      MultTMP = mult + multX
      updateMultDisplay(MultTMP);

      // ✅ ÉTAPE 12 : STATISTIQUES
      bricksHit = 0;
      for(let k in bonusesCaptured) bonusesCaptured[k]=0;
      for(let k in powerupsCaptured) powerupsCaptured[k]=0;

      startTime = Date.now();
      elapsedTime = 0;
      document.getElementById('endPanel').style.display = "none";

      console.log("✅ Reset terminé - États finaux:", {
        gameOver: gameOver,
        gameStarted: gameStarted,
        pause: pause,
        ballExists: !!ball
      });
    }
    //Fin de fonction resetGame



    // ✅ NOUVELLE FONCTION : Démarrage contrôlé du jeu
    function startGame() {
        console.log("Démarrage du jeu après clic sur OK");

        try {
            // ✅ NOUVEAU : NETTOYAGE PRÉVENTIF COMPLET
            clearAllAnimations();
            clearAllTimersEndLevel();
            resetGame();

            // ✅ CORRECTION : Vérifier que les éléments DOM existent
            if (!canvas || !ctx) {
                console.error("❌ Canvas non trouvé !");
                return;
            }

            if (!ball) {
                console.error("❌ Balle non initialisée !");
                return;
            }

            // ✅ S'assurer que AudioContext est initialisé
            if (audioCtx.state === 'suspended') {
                audioCtx.resume().then(() => {
                    console.log('🔊 AudioContext activé');
                }).catch(e => {
                    console.warn('⚠️ Problème audio:', e);
                });
            }

            // 2. S'assurer que la boucle n'est pas déjà lancée
            if (gameLoopId) {
                cancelAnimationFrame(gameLoopId);
                gameLoopId = null;
            }

            // 3. Initialiser le panneau de stats
            try {
                updateStatsPanel();
                console.log("✅ Panneau de stats initialisé");
            } catch (statsError) {
                console.warn("⚠️ Erreur panneau de stats:", statsError);
            }

            // 4. Lancer la boucle de jeu
            console.log("🚀 Lancement de la boucle de jeu");
            lastFrame = 0; // ✅ AJOUT : Reset du timer
            gameLoopId = requestAnimationFrame(gameLoop);

            console.log("✅ Jeu démarré avec succès - États:", {
                gameStarted: gameStarted,
                pause: pause,
                gameOver: gameOver,
                ballExists: !!ball
            });

        } catch (error) {
            console.error("❌ Erreur critique de démarrage:", error);

            // ✅ Fallback robuste amélioré
            setTimeout(() => {
                console.log("🔄 Tentative de récupération...");

                // Reset complet des états
                gameStarted = true;
                pause = false;
                gameOver = false;

                // Recréer la balle si nécessaire
                if (!ball) {
                    ball = {x: CANVAS_W/2, y: paddleY-30, r: ballR};
                    ballDX = 5;
                    ballDY = -5;
                }

                // Relancer la boucle
                if (!gameLoopId) {
                    gameLoopId = requestAnimationFrame(gameLoop);
                    console.log("✅ Boucle de récupération lancée");
                }
            }, 1000);
        }
    }


    function isBossLevelCheck() {
        return niveau % 5 === 0; // Boss tous les 5 niveaux : 5, 10, 15, 20, etc.
    }



    function createBoss() {
        isBossLevel = true;
        bossDefeated = false;

        // Stats du boss évoluent avec le niveau
        bossMaxHP = 50 + Math.floor(niveau / 5) * 25;
        bossHP = bossMaxHP;
        bossPhase = 1;
        bossInvulnerable = false;
        bossAttackTimer = 0;
        bossMovementTimer = 0;

        // Position initiale du boss
        boss = {
            x: CANVAS_W / 2 - 60,
            y: 140,
            w: 170,
            h: 80,
            targetX: CANVAS_W / 2 - 60,
            speed: 8 + niveau * 0.5,
            direction: 1,
            lastAttack: 0,
            attackCooldown: Math.max(1500, 2500 - niveau * 40),
            alive: true,
            hitFlash: 0,
            entrancePhase: true,
            entranceY: -100
        };

        // Créer quelques briques protectrices
        createBossShield();
    }


    function createBossShield() {
        bricks = [];

        // ✅ FORMATION DÉFENSIVE RENFORCÉE
        const formations = [
            // Mur de protection principal (plus large)
            {x: boss.x - 180, y: boss.y + 80},
            {x: boss.x - 120, y: boss.y + 80},
            {x: boss.x - 60, y: boss.y + 80},
            {x: boss.x, y: boss.y + 80},
            {x: boss.x + 60, y: boss.y + 80},
            {x: boss.x + 120, y: boss.y + 80},
            {x: boss.x + 180, y: boss.y + 80},

            // Deuxième ligne de protection
            {x: boss.x - 150, y: boss.y + 120},
            {x: boss.x - 90, y: boss.y + 120},
            {x: boss.x - 30, y: boss.y + 120},
            {x: boss.x + 30, y: boss.y + 120},
            {x: boss.x + 90, y: boss.y + 120},
            {x: boss.x + 150, y: boss.y + 120},

            // Troisième ligne (briques spéciales)
            {x: boss.x - 120, y: boss.y + 160},
            {x: boss.x - 30, y: boss.y + 160},
            {x: boss.x - 60, y: boss.y + 160},
            {x: boss.x + 30, y: boss.y + 160},
            {x: boss.x + 120, y: boss.y + 160},

            // Tours de défense latérales
            {x: boss.x - 150, y: boss.y + 40},
            {x: boss.x - 150, y: boss.y + 100},
            {x: boss.x + boss.w + 80, y: boss.y + 40},
            {x: boss.x + boss.w + 80, y: boss.y + 100}
        ];

        formations.forEach((pos, idx) => {
            if (pos.x >= 0 && pos.x + brickW <= CANVAS_W) {
                let specialChance = 0.4; // 50% de chance d'avoir un special
                let isSpecial = Math.random() < specialChance;
                let special = null;

                if (isSpecial) {
                    // ✅ PLUS DE MULTIPLICATEURS DANS LES BRIQUES BOSS
                    let specials = ["💊", "2️⃣", "4️⃣", "🇫🇷"];
//                    let specials = ["💊", "2️⃣", "4️⃣", "8️⃣", "🇫🇷", "❤️‍🔥","🍭"];
                    if (Math.random() < 0.2) specials.push("☠️"); // Quelques skulls
                    special = specials[Math.floor(Math.random() * specials.length)];
                }

                bricks.push({
                    x: pos.x,
                    y: pos.y,
                    w: brickW,
                    h: brickH,
                    finalX: pos.x,
                    finalY: pos.y,
                    colorIdx: (idx < 6) ? 4 : (idx < 11) ? 3 : 2, // Dégradé de couleurs
                    special: special,
                    alive: true,
                    animFrame: 36,
                    animAngle: 0,
                    animating: false,
                    isBossShield: true
                });
            }
        });
    }



    function createBricks() {
      bricks = [];
      isBossLevel = false;
      let specials = [];
//      let AutopilotBanner = false
      let nbSpecials = 11;
      while(specials.length < nbSpecials) {
        let idx = Math.floor(Math.random()*brickRows*brickCols);
        if(!specials.includes(idx)) specials.push(idx);
      }
      let skullsIdx = [];
      while(skullsIdx.length < 2) {
        let idx = Math.floor(Math.random()*brickRows*brickCols);
        if(!skullsIdx.includes(idx)) skullsIdx.push(idx);
      }
      for(let r=0; r<brickRows; r++) {
        for(let c=0; c<brickCols; c++) {
          let idx = r*brickCols+c;
          let special = null;
          if(skullsIdx.includes(idx)) special = "☠️";
          else if(specials.includes(idx)) special = SPECIAL_ICONS[Math.floor(Math.random()*SPECIAL_ICONS.length)];
          let colorIdx = r%BRICK_GRADIENTS.length;
          // Emplacement final
          let finalX = c*(brickW+brickGap)+brickGap+((CANVAS_W-brickCols*(brickW+brickGap))/2);
          let finalY = wallOffset+r*(brickH+brickGap);
          // Apparition depuis le centre, avec angle unique pour chaque brique
          let angle = Math.random() * 3 * Math.PI;
          bricks.push({
            x: CANVAS_W/2,
            y: CANVAS_H/2,
            w: brickW, h: brickH,
            finalX, finalY,
            colorIdx, special, alive:true,
            animFrame: 0,
            animAngle: angle,
            animating: true
          });
        }
      }
    }



    function drawPaddle(ctx,x,y,w,h,r=10){
      const p = new Path2D();
      p.moveTo(x+r, y);
      p.lineTo(x+w-r, y);
      p.arc(x+w-r, y+h/2, r, -Math.PI/2,  Math.PI/2);
      p.lineTo(x+r, y+h);
      p.arc(x+r,   y+h/2, r,  Math.PI/2, -Math.PI/2);
      ctx.fillStyle = '#fff';
      ctx.shadowColor = '#0ff';
      setOptimizedShadowBlur(ctx, 20, "raquette");
//      ctx.shadowBlur  = 20;
      ctx.fill(p);
    }


    function resetBall() {

      setTimeout(() => {   }, 500);
      ball = {x:CANVAS_W/2, y:paddleY-30, r:ballR};
      // ✅ CONSERVATION DE LA VITESSE PROGRESSIVE

//      updateBallSpeed(); // Recalcule la vitesse actuelle

      // ✅ PROGRESSION TRÈS GRADUELLE par niveau
      baseGameSpeed = Math.min(14, 12 + (niveau - 1) * 0.05);
      ballSpeed = baseGameSpeed;

//      let angle = (Math.random()*0.6+0.2)*Math.PI;
//      ballDX = Math.cos(angle)*currentGameSpeed*(Math.random()<0.5?-1:1);
//      ballDY = -Math.abs(Math.sin(angle)*currentGameSpeed);

      let angle = (Math.random()*0.45 + 0.20) * Math.PI; // 0.20π..0.65π
      const v = currentGameSpeed || baseGameSpeed || 10;
      const minSin = 0.12; // évite dy trop faible
      let sx = Math.cos(angle);
      let sy = Math.sin(angle);
      if (Math.abs(sx) < minSin) sx = Math.sign(sx || (Math.random()<0.5?1:-1)) * minSin;
      if (Math.abs(sx) > 0.97) sx = Math.sign(sx) * 0.97; // anti-rasant
      const nx = sx * v * (Math.random()<0.5?-1:1);
      const ny = -Math.abs(Math.sqrt(Math.max(1e-6, v*v - (nx*nx))));
      ballDX = nx;
      ballDY = ny;
      renormalizeBallSpeed(currentGameSpeed, 0.15);

      gameStarted = true; // Flag obligatoire
//      totalBonusPoints = 0;
    }

    function updateHUD() {
      elScore.textContent = score.toString().padStart(9, "0");
      elVies.textContent = "VIES:"+vies;
      elNiveau.textContent = "NIVEAU:"+niveau;
      elMult.textContent = "x" + (mult + multX);


      const elCookies = document.getElementById('cookies');
      if (elCookies) {
          if (cookies > 0) {
            elCookies.textContent = "COOKIES:" + cookies;
            elCookies.style.display = 'inline-block';
          } else {
            elCookies.style.display = 'none';
          }
        }
    }



    function updateMultDisplay(newMult) {

      elMult.textContent = "x" + newMult;
      // Logique de clignotement
      if (newMult > 1) {
        elMult.classList.add("blinking-effect"); // On ajoute la classe pour le faire clignoter
      } else {
        elMult.classList.remove("blinking-effect"); // On la retire s'il revient à x1
      }

      // L'ancien système de "flash" lors du changement est conservé
      if (newMult !== lastMult) {
        elMult.classList.add("flash");
        setTimeout(() => elMult.classList.remove("flash"), 250);
        lastMult = newMult;
      }
   }

    // === CONTRÔLES CLAVIER & SOURIS ===

    document.addEventListener('keydown',e=>{

      if ((e.key==="m" || e.key==="M") && cookies > 0 && !autopilot) {
          panic = 1;
          PanicButon=true;
          --cookies; updateHUD();
          playSound("pi");
      }
      if ((e.key==="*" || e.key==="*") && !autopilot) {
//          ++vies; updateHUD();
          playSound("pi");
      }

      if ((e.key==="n" || e.key==="N") && !autopilot) {
          multX +=1 ; updateHUD();
          saveMultX(multX);
      }
      if ((e.key==="x" || e.key==="X") && !autopilot) {
//          mult +=1 ; updateHUD();
          multTimer +=60 ; updateHUD();
      }
      if ((e.key==="w" || e.key==="W") && !autopilot) {
//          mult -=1 ; updateHUD();
//          multTimer +=60 ; updateHUD();
      }

      // ✅ TOUCHE DEBUG : Z (simple et sans conflit)
      if(e.key==="z" || e.key==="Z") {
          e.preventDefault();
          if (Debug === true) {
              Debug = false;
            } else {
              Debug=true;
              showDebugPopup();
          return;
      }
    }

      // ✅ GESTION DES TOUCHES DE MOUVEMENT
      if(e.code==="ArrowLeft"||e.key==="q"||e.key==="Q") leftDown=true;
      if(e.code==="ArrowRight"||e.key==="d"||e.key==="D") rightDown=true;

      // ✅ GESTION DU SON ET DE LA PAUSE
      if(e.key==="s" || e.key==="S") {
        // Toggle du son (si tu as une fonction pour ça)
      }

      if(e.key==="p" || e.key==="P") {
        pause = !pause; // Toggle de la pause
      }
    });


    // ✅ NOUVEAU CODE (fonctionne partout)
    document.addEventListener('mousemove', e => {
        // Empêche la souris de prendre le contrôle si l'autopilote est actif
        if (autopilot) return;

        // ✅ NOUVEAU : Utiliser pointer lock si disponible
           if (isPointerLocked) {
               // Déjà géré dans initPointerLock()
               return;
           }

           // ✅ CALCUL DES COORDONNÉES DE BASE
            const rect = canvas.getBoundingClientRect();
            const scaleFactor = getCurrentScaleFactor();

            let canvasX = (e.clientX - rect.left) / scaleFactor;

            // ✅ NOUVELLE APPROCHE : Contrainte progressive selon la zone
            if (e.clientX >= rect.left && e.clientX <= rect.right &&
                e.clientY >= rect.top && e.clientY <= rect.bottom) {
                // ✅ SOURIS DANS LE CANVAS : Position normale contrainte
                canvasX = Math.max(0, Math.min(CANVAS_W, canvasX));

            } else {
                // ✅ SOURIS HORS CANVAS : Extension contrôlée des limites

                if (e.clientX < rect.left) {
                    // ✅ SOURIS À GAUCHE DU CANVAS
                    let overshoot = (rect.left - e.clientX) / scaleFactor;
                    canvasX = Math.max(-paddleW, -overshoot * 0.5); // Extension limitée à gauche

                } else if (e.clientX > rect.right) {
                    // ✅ SOURIS À DROITE DU CANVAS
                    let overshoot = (e.clientX - rect.right) / scaleFactor;
                    canvasX = Math.min(CANVAS_W + paddleW, CANVAS_W + overshoot * 0.5); // Extension limitée à droite

                } else {
                    // ✅ SOURIS AU-DESSUS OU EN-DESSOUS : Garder la position X actuelle
                    canvasX = Math.max(0, Math.min(CANVAS_W, canvasX));
                }

                // ✅ SÉCURITÉ ABSOLUE : Limites extrêmes pour éviter les sauts
                canvasX = Math.max(-CANVAS_W, Math.min(CANVAS_W * 2, canvasX));

                if (Debug) {
                    console.log(`🖱️ Souris hors canvas - clientX: ${e.clientX}, canvasX: ${canvasX.toFixed(0)}`);
                }
            }

            // ✅ SYSTÈME DE DÉMULTIPLICATION (version sécurisée)
            if (lastMouseX !== null) {
                let deltaX = canvasX - lastMouseX;

                // ✅ NOUVEAU : Limiter les deltas extrêmes qui causent les sauts
                deltaX = Math.max(-100, Math.min(100, deltaX)); // Limite le delta à ±100 pixels

                let amplifiedDelta = deltaX * mouseSensitivity;
                let targetX = paddleX + paddleW/2 + amplifiedDelta - paddleW/2;

                // ✅ CONTRAINTE FINALE DE LA RAQUETTE
                const limits = getEffectiveCanvasLimits();
                paddleX = Math.max(0, Math.min(limits.width - paddleW, targetX));

            } else {
                // ✅ PREMIÈRE POSITION : Centrer sur la souris
                const limits = getEffectiveCanvasLimits();
                let targetX = canvasX - paddleW / 2;
                paddleX = Math.max(0, Math.min(limits.width - paddleW, targetX));
            }

            // ✅ MISE À JOUR SÉCURISÉE DE LA POSITION PRÉCÉDENTE
            lastMouseX = canvasX;
        });
    //Fin de fonction mousemove_demultiplie


    // ✅ NOUVEAU : Contrôle par molette de souris
    // === CONTRÔLE MOLETTE CORRIGÉ POUR LE RESPONSIVE ===
    canvas.addEventListener('wheel', e => {
        e.preventDefault(); // Empêche le scroll de la page

        // Ne pas contrôler si l'autopilote est actif
        if (autopilot) return;

        // ✅ NOUVEAU : Sensibilité ajustée selon le scale
        const scaleFactor = getCurrentScaleFactor();
        const baseSensitivity = 20;
        const adjustedSensitivity = baseSensitivity * scaleFactor;

        // Calcul du déplacement basé sur la direction de la molette
        let deltaMove = 0;

        if (e.deltaY > 0) {
            // Molette vers le bas = mouvement vers la droite
            deltaMove = adjustedSensitivity;
        } else if (e.deltaY < 0) {
            // Molette vers le haut = mouvement vers la gauche
            deltaMove = -adjustedSensitivity;
        }

        // ✅ NOUVEAU : Limites ajustées selon le scale
        const limits = getEffectiveCanvasLimits();
        paddleX = Math.max(
            0,
            Math.min(limits.width - paddleW, paddleX + deltaMove)
        );
    });
    //Fin de fonction wheel_corrected

  // ☠️ ÉVITEMENT INTELLIGENT DES SKULLS
  function findNearestSkull() {
      let nearest = null;
      let minDanger = Infinity;

      skulls.forEach(skull => {
          if (skull.y < paddleY && skull.y > CANVAS_H * 0.3) {
              let timeToImpact = (paddleY - skull.y) / (skull.speed || 7);
              let dangerLevel = 1 / timeToImpact; // Plus c'est proche, plus c'est dangereux

              if (dangerLevel > 0.1 && dangerLevel < minDanger) {
                  minDanger = dangerLevel;
                  nearest = skull;
              }
          }
      });

      return nearest;
  }

  function calculateSkullAvoidance(skull) {
      let skullX = skull.x;
      let safeDistance = paddleW + 40; // Marge de sécurité

      // Choisir le côté le plus proche et sûr
      let leftSafe = skullX - safeDistance;
      let rightSafe = skullX + safeDistance;

      let currentCenter = paddleX + paddleW/2;

      // Prioriser le côté le plus proche
      if (Math.abs(leftSafe - currentCenter) < Math.abs(rightSafe - currentCenter)) {
          if (leftSafe >= paddleW/2) return leftSafe;
          if (rightSafe <= CANVAS_W - paddleW/2) return rightSafe;
      } else {
          if (rightSafe <= CANVAS_W - paddleW/2) return rightSafe;
          if (leftSafe >= paddleW/2) return leftSafe;
      }

      return null;
  }


    // ✅ FONCTION CENTRALE DE GESTION DE LA VITESSE
    function calculateGameSpeed() {
        // Vitesse de base + bonus niveau + bonus briques cassées
        let progressiveSpeed = baseGameSpeed +
                              (niveau - 1) * speedIncreasePerLevel +
                              bricksHit * speedIncreasePerBrick;

        // Application du multiplicateur autopilote si actif
        if (autopilot) {
            currentGameSpeed = progressiveSpeed * autopilotSpeedMultiplier;
        } else {
            currentGameSpeed = progressiveSpeed;
        }

        // ✅ LIMITATIONS PLUS STRICTES selon le mode
        if (autopilot) {
            currentGameSpeed = Math.min(currentGameSpeed, 13 + niveau * 0.05); // Limite autopilote
        } else {
            currentGameSpeed = Math.min(currentGameSpeed, 15 + niveau * 0.15); // Limite normale
        }

        return currentGameSpeed;
    }

    // ✅ FONCTION DE MISE À JOUR DE LA VITESSE DE LA BALLE
    function updateBallSpeed() {
        let newSpeed = calculateGameSpeed();

        // Conservation de la direction actuelle
        let currentSpeed = Math.sqrt(ballDX * ballDX + ballDY * ballDY);
        if (currentSpeed > 0) {
            let ratio = newSpeed / currentSpeed;
            ballDX *= ratio;
            ballDY *= ratio;
        }

        ballSpeed = newSpeed;

        // ✅ SÉCURITÉ ABSOLUE : Plafond de vitesse global RÉDUIT
        let absoluteMaxSpeed = Math.min(18, 14 + niveau * 0.08); // Progression très lente + plafond à 18
        if (ballSpeed > absoluteMaxSpeed) {
            ballSpeed = absoluteMaxSpeed;
            console.log(`Vitesse limitée à ${absoluteMaxSpeed.toFixed(1)} au niveau ${niveau}`);
        }

        // ✅ Application immédiate de la limitation
        let currentBallSpeed = Math.sqrt(ballDX * ballDX + ballDY * ballDY);
        if (currentBallSpeed > ballSpeed) {
            let ratio = ballSpeed / currentBallSpeed;
            ballDX *= ratio;
            ballDY *= ratio;
        }



    }


    // === SYSTÈME D'OPTIMISATION DYNAMIQUE DES SHADOWBLUR ===

// Configuration des profils de performance pour shadowBlur
const SHADOWBLUR_PROFILES = {
    "high": {
        multiplier: 1.0,     // Valeurs originales
        maxBlur: 40,
        description: "Qualité maximale"
    },
    "medium": {
        multiplier: 0.7,     // Réduction de 30%
        maxBlur: 25,
        description: "Qualité équilibrée"
    },
    "low": {
        multiplier: 0.3,     // Réduction de 60%
        maxBlur: 10,
        description: "Performance maximale"
    },
    "minimal": {
        multiplier: 0.1,     // Réduction de 80%
        maxBlur: 0,
        description: "Performance critique"
    }
};

// Variable globale pour le profil actuel
let currentShadowBlurProfile = "high";
/**
 * Son addictif inspiré du système de récompense de Subway Surfers
 * Plus le multiplicateur augmente, plus l'euphorie sonore devient intense
 */
function playSoundScoreMultiplied(basePoints, multiplier) {
    if (!audioCtx) return;
    let now = audioCtx.currentTime;

    // ✅ CALCUL DU FACTEUR D'EUPHORIE (limité pour éviter la saturation)
    let euphoriaLevel = Math.min(multiplier / 50, 1); // Progression douce sur 8 niveaux
    let numCoins = Math.min(multiplier, basePoints); // Maximum 5 "pièces" simultanées

    // ✅ SON PRINCIPAL : SÉRIE DE "PIÈCES" RAPIDES
    for (let i = 0; i < numCoins; i++) {
        let coinOsc = audioCtx.createOscillator();
        let coinGain = audioCtx.createGain();

        // Fréquences optimisées style Subway Surfers (gamme majeure)
        let coinFreqs = [1047, 1175, 1319, 1568, 1760]; // Do-Ré-Mi-Sol-La aigus
        let coinFreq = coinFreqs[i % coinFreqs.length];

        let startTime = now + i * 0.04; // Très rapide : 30ms entre chaque pièce
        let duration = 0.08 + i * 0.007; // Durée légèrement croissante

        coinOsc.type = "square";
        coinOsc.frequency.setValueAtTime(coinFreq, startTime);
        coinOsc.frequency.exponentialRampToValueAtTime(coinFreq * 0.7, startTime + duration * 0.6);

        // Volume dégressif pour éviter la saturation
        let volume = Math.max(0.04, 0.15 - i * 0.024);
        coinGain.gain.setValueAtTime(volume, startTime);
        coinGain.gain.exponentialRampToValueAtTime(0.001, startTime + duration);

        coinOsc.connect(coinGain).connect(audioCtx.destination);
        coinOsc.start(startTime);
        coinOsc.stop(startTime + duration + 0.01);
    }

    // ✅ BONUS "POWER-UP" SUBWAY SURFERS (mult 4+)
    if (multiplier >= 1) {
        let powerUpDelay = numCoins * 30 + 20; // Juste après les pièces

        setTimeout(() => {
            let powerOsc = audioCtx.createOscillator();
            let powerGain = audioCtx.createGain();
            let powerNow = audioCtx.currentTime;

            powerOsc.type = "square"; // Plus incisif que triangle
            powerOsc.frequency.setValueAtTime(2093, powerNow); // Do7 très aigu
            powerOsc.frequency.exponentialRampToValueAtTime(1047, powerNow + 0.12);

            let powerVolume = 0.08 + euphoriaLevel * 0.04;
            powerGain.gain.setValueAtTime(powerVolume, powerNow);
            powerGain.gain.exponentialRampToValueAtTime(0.001, powerNow + 0.12);

            powerOsc.connect(powerGain).connect(audioCtx.destination);
            powerOsc.start(powerNow);
            powerOsc.stop(powerNow + 0.13);
        }, powerUpDelay);
    }

    // ✅ "ACHIEVEMENT UNLOCK" STYLE SUBWAY SURFERS (mult 7+)
    if (multiplier >= 3) {
        let achievementDelay = numCoins * 30 + 80;

        setTimeout(() => {
            // Triade majeure ascendante ultra-satisfaisante
            let achievementChord = [1047, 1319, 1568]; // Do-Mi-Sol
            let achNow = audioCtx.currentTime;

            achievementChord.forEach((freq, index) => {
                let achOsc = audioCtx.createOscillator();
                let achGain = audioCtx.createGain();

                achOsc.type = "sine"; // Son pur et cristallin
                achOsc.frequency.setValueAtTime(freq, achNow + index * 0.02);
                achOsc.frequency.exponentialRampToValueAtTime(freq * 0.85, achNow + index * 0.02 + 0.15);

                let achVolume = (0.06 - index * 0.01) * (1 + euphoriaLevel * 0.5);
                achGain.gain.setValueAtTime(achVolume, achNow + index * 0.02);
                achGain.gain.exponentialRampToValueAtTime(0.001, achNow + index * 0.02 + 0.15);

                achOsc.connect(achGain).connect(audioCtx.destination);
                achOsc.start(achNow + index * 0.02);
                achOsc.stop(achNow + index * 0.02 + 0.16);
            });
        }, achievementDelay);
    }

    // ✅ "EPIC COMBO" FINALE (mult 12+)
    if (multiplier >= 12) {
        let epicDelay = numCoins * 30 + 180;

        setTimeout(() => {
            // Arpège descendant cristallin (signature Subway Surfers)
            let epicNotes = [2093, 1760, 1568, 1319, 1047]; // Do7→La→Sol→Mi→Do
            let epicNow = audioCtx.currentTime;

            epicNotes.forEach((freq, index) => {
                let epicOsc = audioCtx.createOscillator();
                let epicGain = audioCtx.createGain();

                epicOsc.type = "triangle";
                epicOsc.frequency.setValueAtTime(freq, epicNow + index * 0.025);

                let epicVolume = Math.max(0.03, 0.1 - index * 0.015);
                epicGain.gain.setValueAtTime(epicVolume, epicNow + index * 0.025);
                epicGain.gain.exponentialRampToValueAtTime(0.001, epicNow + index * 0.025 + 0.08);

                epicOsc.connect(epicGain).connect(audioCtx.destination);
                epicOsc.start(epicNow + index * 0.025);
                epicOsc.stop(epicNow + index * 0.025 + 0.09);
            });
        }, epicDelay);
    }

    // ✅ "LEGENDARY COMBO" TRANSCENDANTAL (mult 20+)
        if (multiplier >= 20) {
            let legendaryDelay = numCoins * 30 + 320; // Après l'EPIC COMBO

            setTimeout(() => {
                // Premier arpège : Gamme mixolydienne descendante cristalline
                let legendaryNotes1 = [1976, 1760, 1568, 1397, 1319, 1175, 1047]; // Si→La→Sol→Fa→Mi→Ré→Do
                let legend1Now = audioCtx.currentTime;

                legendaryNotes1.forEach((freq, index) => {
                    let leg1Osc = audioCtx.createOscillator();
                    let leg1Gain = audioCtx.createGain();

                    leg1Osc.type = "sine"; // Son cristallin pur
                    leg1Osc.frequency.setValueAtTime(freq, legend1Now + index * 0.022);

                    // Volume avec crescendo-decrescendo naturel
                    let leg1Volume = 0.04 + Math.sin(index / legendaryNotes1.length * Math.PI) * 0.03;
                    leg1Gain.gain.setValueAtTime(leg1Volume, legend1Now + index * 0.022);
                    leg1Gain.gain.exponentialRampToValueAtTime(0.001, legend1Now + index * 0.022 + 0.1);

                    leg1Osc.connect(leg1Gain).connect(audioCtx.destination);
                    leg1Osc.start(legend1Now + index * 0.022);
                    leg1Osc.stop(legend1Now + index * 0.022 + 0.11);
                });
            }, legendaryDelay);

            // Deuxième arpège superposé : Harmoniques supérieures (mult 25+)
            if (multiplier >= 25) {
                let celestialDelay = numCoins * 30 + 400;

                setTimeout(() => {
                    let celestialNotes = [2349, 2093, 1865, 1760, 1568, 1397, 1319]; // Ré8→Do8→Si7→La7→Sol7→Fa7→Mi7
                    let celestialNow = audioCtx.currentTime;

                    celestialNotes.forEach((freq, index) => {
                        let celOsc = audioCtx.createOscillator();
                        let celGain = audioCtx.createGain();

                        celOsc.type = "triangle"; // Brillance cristalline
                        celOsc.frequency.setValueAtTime(freq, celestialNow + index * 0.03);

                        // Volume très doux pour harmonie parfaite
                        let celVolume = Math.max(0.02, 0.06 - index * 0.008);
                        celGain.gain.setValueAtTime(celVolume, celestialNow + index * 0.03);
                        celGain.gain.exponentialRampToValueAtTime(0.001, celestialNow + index * 0.03 + 0.095);

                        celOsc.connect(celGain).connect(audioCtx.destination);
                        celOsc.start(celestialNow + index * 0.03);
                        celOsc.stop(celestialNow + index * 0.03 + 0.105);
                    });
                }, celestialDelay);
            }
        }

        // ✅ LOG DE DEBUG ÉTENDU
        if (Debug) {
            let comboLevel = multiplier >= 30 ? "GODLIKE" : multiplier >= 25 ? "CELESTIAL" : multiplier >= 20 ? "LEGENDARY" : "EPIC";
            console.log(`🎮 Subway ${comboLevel}: mult=${multiplier}, pièces=${numCoins}, euphorie=${(euphoriaLevel*100).toFixed(0)}%`);
        }

}
//Fin de fonction playSoundScoreMultiplied

  //Fin de fonction playAddictiveChain

function adjustShadowBlurQuality() {
    // ✅ UTILISE TON SYSTÈME EXISTANT
    if (!PERF_CONFIG.enabled) return;

    // Mesure toutes les 300 frames comme ton système actuel
    perfFrameCount++;
    if (perfFrameCount >= PERF_CONFIG.measureIntervalFrames) {
        const now = performance.now();
        const avgFrameTime = (now - perfLastTime) / perfFrameCount;
        const estimatedFPS = 1000 / avgFrameTime;

        // ✅ NOUVEAU : Détermination du profil shadowBlur selon FPS
        let newProfile = currentShadowBlurProfile;

        if (estimatedFPS >= 55) {
            newProfile = "high";     // Performance excellente
        } else if (estimatedFPS >= 45) {
            newProfile = "medium";   // Performance correcte
        } else if (estimatedFPS >= 30) {
            newProfile = "low";      // Performance limite
        } else {
            newProfile = "minimal";  // Performance critique
        }

        // ✅ Changement de profil si nécessaire
        if (newProfile !== currentShadowBlurProfile) {
            currentShadowBlurProfile = newProfile;
            console.log(`🎨 ShadowBlur optimisé: ${SHADOWBLUR_PROFILES[newProfile].description} (FPS: ${estimatedFPS.toFixed(1)})`);
        }

        // Reset des compteurs (comme ton système existant)
        perfFrameCount = 0;
        perfLastTime = now;
    }
}

/**
 * Fonction utilitaire pour appliquer le shadowBlur optimisé
 * À utiliser dans tous tes contextes de rendu
 *
 * @param {CanvasRenderingContext2D} ctx - Le contexte canvas
 * @param {number} originalValue - La valeur shadowBlur originale
 * @param {string} context - Contexte d'utilisation (optionnel, pour debug)
 */
function setOptimizedShadowBlur(ctx, originalValue, context = "") {
    const profile = SHADOWBLUR_PROFILES[currentShadowBlurProfile];

    // Calcul de la valeur optimisée
    let optimizedValue = Math.round(originalValue * profile.multiplier);

    // Application de la limite maximale
    optimizedValue = Math.min(optimizedValue, profile.maxBlur);

    // Valeur minimale de sécurité
    optimizedValue = Math.max(optimizedValue, 0);

    ctx.shadowBlur = optimizedValue;

    // ✅ Debug optionnel
    if (Debug && context) {
        console.log(`ShadowBlur ${context}: ${originalValue} → ${optimizedValue} (profil: ${currentShadowBlurProfile})`);
    }
}

/**
 * Fonction de forçage manuel du profil (pour tests)
 *
 * @param {string} profileName - Nom du profil à forcer
 */
function forceShadowBlurProfile(profileName) {
    if (SHADOWBLUR_PROFILES[profileName]) {
        currentShadowBlurProfile = profileName;
        console.log(`🔧 Profil shadowBlur forcé: ${SHADOWBLUR_PROFILES[profileName].description}`);
    } else {
        console.warn(`❌ Profil shadowBlur inconnu: ${profileName}`);
    }
}
//Fin de fonction forceShadowBlurProfile

function renormalizeBallSpeed(targetSpeed, blend = 0.25) {
if (!isFinite(targetSpeed) || targetSpeed <= 0) targetSpeed = currentGameSpeed || 10;
if (!isFinite(blend) || blend < 0) blend = 0.25;

// Filets de sécurité sur les composantes
if (!isFinite(ballDX)) ballDX = 0;
if (!isFinite(ballDY)) ballDY = -1;

let v = Math.hypot(ballDX, ballDY);
if (!isFinite(v) || v < 1e-6) {
// Recalage d’urgence vertical vers le haut
ballDX = targetSpeed * 0.2 * (Math.random() < 0.5 ? -1 : 1);
ballDY = -Math.sqrt(Math.max(1e-6, targetSpeed * targetSpeed - ballDX * ballDX));
v = Math.hypot(ballDX, ballDY);
if (!isFinite(v) || v < 1e-6) return; // si malgré tout…
}

// 1) Recalage doux vers targetSpeed
const newV = v + (targetSpeed - v) * blend;
const k = newV / v;
if (isFinite(k) && k > 0) {
ballDX *= k;
ballDY *= k;
}

// 2) Anti-horizontalité/verticalité
const v2 = Math.hypot(ballDX, ballDY);
if (!isFinite(v2) || v2 < 1e-6) return;

const minSin = 0.10;
const maxSin = 0.95;

// Empêche trajectoire trop verticale
if (Math.abs(ballDX) < v2 * minSin) {
const signX = Math.sign(ballDX) || (Math.random() < 0.5 ? 1 : -1);
ballDX = signX * v2 * minSin;
ballDY = Math.sign(ballDY || -1) * Math.sqrt(Math.max(1e-6, v2 * v2 - ballDX * ballDX));
}

// Empêche trajectoire trop rasante
if (Math.abs(ballDX) > v2 * maxSin) {
ballDX = Math.sign(ballDX) * v2 * maxSin;
ballDY = Math.sign(ballDY || -1) * Math.sqrt(Math.max(1e-6, v2 * v2 - ballDX * ballDX));
}
} //Fin de fonction renormalizeBallSpeed


    // === LOGIQUE DE MISE À JOUR DU JEU ===

    function update(dt, elapsed_ms) {

      //✅ MISE À JOUR CONDITIONNELLE DE LA GALAXIE
      if (galaxyEnabled) {
          updateGalaxy(dt);
      }


      // --- GESTION AUTOPILOTE & BANDEAU (VERSION CORRIGÉE) ---
      let briquesRestantes = bricks.filter(b => b.alive).length;

      // ✅ NOUVEAU : Spawn automatique du powerup niveau à 2 briques restantes
      if (briquesRestantes == 2) {
          // Vérifier qu'il n'y a pas déjà un powerup niveau actif
          let powerupNiveauExiste = bonuses.some(bonus => bonus.type === "niveau" && !bonus.caught);

            if (!powerupNiveauExiste && autopilot === true) {
              // Créer le powerup de changement de niveau
              let powerupNiveau = {
                  x: Math.random() * (CANVAS_W - 120) + 60, // Position aléatoire
                  y: wallOffset + 30,
                  emoji: "🏖️", // Emoji du powerup niveau
                  points: 0,
                  color: "#A67B5B",
                  type: "niveau",
                  speed: 4 + Math.random() * 2, // Vitesse plus lente pour être visible
                  caught: false
              };

              bonuses.push(powerupNiveau);

              // Son spécial pour signaler l'apparition
              playSound("powerup");

              console.log("🏖️ Powerup de niveau spawné ! Il reste 2 briques.");
          }
      }


      // 1. Logique du bandeau d'avertissement (SIMPLIFIÉE)
      if (!autopilot && !isBossLevel &&
          briquesRestantes > 0 && briquesRestantes <= LancementAutoPilote + countdownRange &&
          briquesRestantes > LancementAutoPilote) {

          let bricksToActivation = briquesRestantes - LancementAutoPilote;
          elAutopilotBanner.textContent = `AUTOPILOT DANS ${bricksToActivation}`;

          if (elAutopilotBanner.style.display !== 'block') {
              playSound("AutopilotBanner");
              elAutopilotBanner.style.display = 'block';
          }

          elAutopilotBanner.classList.remove('flash');
          void elAutopilotBanner.offsetWidth;
          elAutopilotBanner.classList.add('flash');

      } else {
          if (elAutopilotBanner.style.display !== 'none') {
              elAutopilotBanner.style.display = 'none';
          }
      }

      // ✅ APPEL DIRECT ET SIMPLE
      if (document.getElementById('statsPanel')) {
        updateStatsPanel();
      }


      // 2. Activation de l'autopilote (LOGIQUE CORRIGÉE)
      if (briquesRestantes <= LancementAutoPilote && !autopilot && !isBossLevel) {
          autopilot = true;
          leftDown = rightDown = false;

          // ✅ TRANSITION FLUIDE VERS LA VITESSE AUTOPILOTE
          updateBallSpeed(); // Applique immédiatement le multiplicateur autopilote
          playSound("autopilot_on");
      }

      // 3. Désactivation pour les boss (SÉCURISÉE)
      if (isBossLevel && autopilot) {
          autopilot = false;
          updateBallSpeed(); // Retire le multiplicateur autopilote
          leftDown = rightDown = false;
          playSound("raquettenormale");

          // Affichage du message boss
          elAutopilotBanner.textContent = "⚠️ BOSS FIGHT - CONTRÔLE MANUEL ⚠️";
          elAutopilotBanner.style.display = 'block';
          elAutopilotBanner.style.color = '#ff0000';

          setTimeout(() => {
              if (elAutopilotBanner.style.display !== 'none') {
                  elAutopilotBanner.style.display = 'none';
              }
          }, 3000);
      }

      // 4. Retour au manuel si trop de briques (NOUVEAU NIVEAU)
      if (briquesRestantes > LancementAutoPilote && autopilot && !isBossLevel) {
          autopilot = false;
          megaspeed = 1;
      }

//      // GESTION DU MODE PANIC (CORRIGÉE)
      if (panic > 0) {
          if (!autopilot) {
              autopilot = true;
              leftDown = rightDown = false;
          }
      } else if (PanicButon) {
          autopilot = false;
          PanicButon = false;
      }

      // AFFICHAGE DU STATUS AUTOPILOT (CORRIGÉ)
      if (autopilot) {
        elAutopilotStatus.style.display = 'inline-block';
        elAutopilotStatus.classList.add('blinking-effect');
       } else {
        elAutopilotStatus.style.display = 'none';
        elAutopilotStatus.classList.remove('blinking-effect');
      }

      // APPEL DE L'AUTOPILOTE (CONDITION CORRIGÉE)
      if (autopilot && !isBossLevel) { // ✅ AJOUT : !isBossLevel
          autopilotMove(dt);
      } else {
          // Contrôle manuel
          // CONTRÔLE MANUEL (VERSION CORRIGÉE POUR LE RESPONSIVE)
          if (leftDown && !rightDown) {
              paddleAcceleration = Math.min(paddleAcceleration + paddleAccelerationStep, maxPaddleAcceleration);

              // ✅ NOUVEAU : Vitesse ajustée selon le scale
              const scaleFactor = getCurrentScaleFactor();
              const adjustedSpeed = (paddleSpeed + paddleAcceleration) * scaleFactor;

              paddleX = Math.max(0, paddleX - adjustedSpeed * dt);

          } else if (rightDown && !leftDown) {
              paddleAcceleration = Math.min(paddleAcceleration + paddleAccelerationStep, maxPaddleAcceleration);

              // ✅ NOUVEAU : Vitesse et limites ajustées selon le scale
              const scaleFactor = getCurrentScaleFactor();
              const adjustedSpeed = (paddleSpeed + paddleAcceleration) * scaleFactor;
              const limits = getEffectiveCanvasLimits();

              paddleX = Math.min(limits.width - paddleW, paddleX + adjustedSpeed * dt);

          } else {
              paddleAcceleration = 0;
          }
          //Fin de fonction controle_manuel_corrige

      }


      if (decrementActive) {
        // Temps écoulé en secondes réelles
        let elapsed = (performance.now() - decrementStartTime) / 1000;
        let timeLeft = Math.max(0, decrementTimer - elapsed);

        if (timeLeft <= 0) {
          decrementActive = false;
          decrementEffect = false;
          elDec.style.display = "none";
          playSound("raquettenormale");
        }
      }


      let prevX = ball.x, prevY = ball.y;
      let nextX = ball.x + ballDX * dt, nextY = ball.y + ballDY * dt;
      ball.x=nextX; ball.y=nextY;

      // Collisions murs
//      if(ball.x-ball.r<0) {ball.x=ball.r; ballDX=Math.abs(ballDX); playSound("impact");}
//      if(ball.x+ball.r>CANVAS_W) {ball.x=CANVAS_W-ball.r; ballDX=-Math.abs(ballDX); playSound("impact");}

  const WALL_FRICTION = 0.96; // 0.92–0.98 (plus petit = plus de friction)
  if (ball.x - ball.r < 0) {
    ball.x = ball.r;
    ballDX = Math.abs(ballDX) * WALL_FRICTION;
    playSound("impact");
    renormalizeBallSpeed(currentGameSpeed, 0.08);
  }

  if (ball.x + ball.r > CANVAS_W) {
    ball.x = CANVAS_W - ball.r;
    ballDX = -Math.abs(ballDX) * WALL_FRICTION;
    playSound("impact");
    renormalizeBallSpeed(currentGameSpeed, 0.12);
  }

      if(ball.y-ball.r<0) {ball.y=ball.r; ballDY=Math.abs(ballDY); playSound("impact");
        renormalizeBallSpeed(currentGameSpeed, 0.08);
      }


//    if(Math.abs(ballDX)<2) ballDX=(Math.random()<0.5?-1:1)*2;

      if (Math.abs(ballDX) < 1e-3) {
        const v = Math.hypot(ballDX, ballDY) || currentGameSpeed || 8;
        const minSin = 0.10;
        const signX = (Math.random() < 0.5 ? -1 : 1);
        ballDX = signX * v * minSin;
        ballDY = Math.sign(ballDY || -1) * Math.sqrt(Math.max(1e-6, v*v - ballDX*ballDX));
      }

      // --- Collision raquette (version unifiée & stable) ---
      if (ballDY > 0) {
        // Prédiction très courte
        if (!isFinite(ballDX)) ballDX = 0;
        if (!isFinite(ballDY)) ballDY = -Math.abs(currentGameSpeed || 10);

        const nextBallY = ball.y + ballDY * dt;
        const nextBallX = ball.x + ballDX * dt;

        if (!isFinite(nextBallX) || !isFinite(nextBallY)) {
          // Recalage d’urgence avant toute collision/nudge
          ballDX = (currentGameSpeed || 10) * 0.2 * (Math.random() < 0.5 ? -1 : 1);
          ballDY = -Math.abs(currentGameSpeed || 10) * 0.98;
        }

        const willHitY = (nextBallY + ball.r >= paddleY) && (ball.y + ball.r <= paddleY + paddleH);
        const willHitX = (nextBallX + ball.r >= paddleX) && (nextBallX - ball.r <= paddleX + paddleW);

        if (AIM.active && ballDY > 0 && performance.now() < AIM.until) {
        // Garde-fous AIM
        if (typeof AIM.impactRel !== 'number' || !isFinite(AIM.impactRel)) {
        // Valeur de repli neutre (vertical) si l’armement n’a pas encore produit un impactRel crédible
        AIM.impactRel = 0;
        } else {
        // Clamp dur
        AIM.impactRel = Math.max(-1, Math.min(1, AIM.impactRel));
        }
        const desiredCenter = Math.max(
        paddleW/2,
        Math.min(CANVAS_W - paddleW/2, ball.x - AIM.impactRel * (paddleW/2))
        );
        const delta = desiredCenter - (paddleX + paddleW/2);
        const maxNudge = 220 * dt; // douceur
        const nudge = Math.max(-maxNudge, Math.min(maxNudge, delta));
        paddleX = Math.max(0, Math.min(CANVAS_W - paddleW, paddleX + nudge));
        } //Fin de bloc nudge AIM

        //Fin de fonction update (partie AIM nudge)


        if (willHitY && willHitX) {
          // Repositionnement "avant" la raquette pour éviter le tunneling
          ball.y = paddleY - ball.r - 0.5;
          ball.x = Math.max(paddleX + ball.r, Math.min(paddleX + paddleW - ball.r, nextBallX));

          // Impact relatif dans [-1,1] par rapport au centre de la raquette

          const paddleCenter = paddleX + paddleW / 2;
          let impactRel = (ball.x - paddleCenter) / (paddleW / 2);
          impactRel = Math.max(-1, Math.min(1, impactRel));

          // Option: léger tilt pour éviter dy quasi-vertical quand impact≈0
          const aimTilt = 0.0; // peux le passer à 0.05 si tu veux très légèrement biaiser

          // Angle max constant, unifié
          const maxAngle = 4 * Math.PI / 12; // 60°

          if (Math.abs(impactRel) < 0.05) {
            impactRel = 0; // centre vraiment vertical, très stable
          }

          if (!isFinite(ballDX)) ballDX = 0;
          if (!isFinite(ballDY)) ballDY = -Math.abs(currentGameSpeed || 10);
          if (!isFinite(impactRel)) impactRel = 0;
          impactRel = Math.max(-1, Math.min(1, impactRel));

          // Vecteur unifié
          const rebound = computePaddleBounce(ballDX, ballDY, impactRel, maxAngle, aimTilt);

          // Applique le rebond sans booster arbitraire
          ballDX = rebound.dx;
          ballDY = rebound.dy;
          renormalizeBallSpeed(currentGameSpeed, 0.2);


          // Petit son
          playSound("paddle");
        }
      }

      // === MISE À JOUR DU BOSS (VERSION STABILISÉE) ===
      if (isBossLevel && boss && boss.alive) {
          // ✅ GESTION DE L'ENTRÉE SÉCURISÉE
          if (boss.entrancePhase) {
              boss.y += 1; // Vitesse d'entrée réduite
              if (boss.y >= 140) {
                  boss.entrancePhase = false;
                  boss.y = 140;
              }
          } else {
              // ✅ MOUVEMENT HORIZONTAL STABLE
              let moveSpeed = (5 + niveau * 0.2) * dt; // Vitesse très réduite
              boss.x += boss.direction * moveSpeed;

              // ✅ REBONDS SÉCURISÉS
              if (boss.x <= 0) {
                  boss.x = 0;
                  boss.direction = 1;
              } else if (boss.x + boss.w >= CANVAS_W) {
                  boss.x = CANVAS_W - boss.w;
                  boss.direction = -1;
              }

              // ✅ ATTAQUES CONTRÔLÉES
              bossAttackTimer += elapsed_ms;
              if (bossAttackTimer > boss.attackCooldown) {
                  bossAttack();
                  bossAttackTimer = 0;
              }
          }
      }

//      updateGalaxy(dt);


      // === COLLISION AVEC LE BOSS (VERSION SÉCURISÉE) ===
      if (isBossLevel && boss && boss.alive && !bossInvulnerable) {
          // ✅ COLLISION DETECTION AMÉLIORÉE
          let ballRight = ball.x + ball.r;
          let ballLeft = ball.x - ball.r;
          let ballBottom = ball.y + ball.r;
          let ballTop = ball.y - ball.r;

          let bossRight = boss.x + boss.w;
          let bossBottom = boss.y + boss.h;

          if (ballRight > boss.x && ballLeft < bossRight &&
              ballBottom > boss.y && ballTop < bossBottom) {

              // ✅ CALCUL SÉCURISÉ DU REBOND
              let overlapX = Math.min(ballRight - boss.x, bossRight - ballLeft);
              let overlapY = Math.min(ballBottom - boss.y, bossBottom - ballTop);

              if (overlapX < overlapY) {
                  // Collision horizontale
                  ballDX = ball.x < boss.x + boss.w/2 ? -Math.abs(ballDX) : Math.abs(ballDX);
                  ball.x = ball.x < boss.x + boss.w/2 ? boss.x - ball.r : boss.x + boss.w + ball.r;
              } else {
                  // Collision verticale
                  ballDY = ball.y < boss.y + boss.h/2 ? -Math.abs(ballDY) : Math.abs(ballDY);
                  ball.y = ball.y < boss.y + boss.h/2 ? boss.y - ball.r : boss.y + boss.h + ball.r;
              }

              // ✅ DÉGÂTS ET EFFETS (SÉCURISÉS)
              bossHP = Math.max(0, bossHP - 10);
              boss.hitFlash = 10;
              playSound("boss_hit");

              // ✅ INVULNÉRABILITÉ TEMPORAIRE SÉCURISÉE
              bossInvulnerable = true;
              timeoutManager.set('bossInvulnerable', () => {
                  bossInvulnerable = false;
              }, 500);

              // ✅ PARTICULES D'IMPACT
              for (let j = 0; j < 15; j++) {
                  let angle = Math.random() * 2 * Math.PI;
                  let velocity = 3 + Math.random() * 4;
                  particles.push({
                      x: ball.x, y: ball.y,
                      dx: Math.cos(angle) * velocity,
                      dy: Math.sin(angle) * velocity,
                      life: 20, color: "#ff0"
                  });
              }

              // ✅ VÉRIFICATION DE DÉFAITE DU BOSS
              if (bossHP <= 0) {

                // ✅ 1. ARRÊT IMMÉDIAT DE TOUS LES TIMEOUTS BOSS
                    for (let i = 0; i < 100; i++) {
                        timeoutManager.clear(`bossVictory${i}`);
                        timeoutManager.clear(`bossAttack${i}`);
                        timeoutManager.clear(`bossProjectile${i}`);
                        timeoutManager.clear('bossInvulnerable');
                    }

                    // ✅ 2. NETTOYAGE IMMÉDIAT DES PROJECTILES BOSS
                    powerups = powerups.filter(p => p.type !== "boss_projectile");
                    console.log("🧹 Projectiles de boss supprimés");

                    // ✅ 3. RESET COMPLET DES VARIABLES BOSS
                    boss.alive = false;
                    bossDefeated = true;
                    bossInvulnerable = false;
                    bossAttackTimer = 0;
                    bossMovementTimer = 0;

                  playSound("boss_death");

                  // Récompenses

                  score += 20000 * niveau;
                  cookies += 1;
                  vies += 1;

                  // ✅ NOUVEAU : Animation du gain qui monte vers le score
                  showScoreBonusAnim(boss.x + boss.w/2, boss.y + boss.h/2, 20000 * niveau);

                  updateHUD();

                  // Animation de victoire
                  for (let i = 0; i < 30; i++) {
                      timeoutManager.set(`bossVictory${i}`, () => {
                          particles.push({
                              x: boss.x + Math.random() * boss.w,
                              y: boss.y + Math.random() * boss.h,
                              dx: (Math.random() - 0.5) * 8,
                              dy: (Math.random() - 0.5) * 8,
                              life: 50,
                              color: COLORS[Math.floor(Math.random() * COLORS.length)]
                          });
                      }, i * 30);
                  }
              }
          }
      }


      // Collision briques
      for(let i=0;i<bricks.length;i++) {
        let b=bricks[i];
        if(!b.alive) continue;
        if(ball.x+ball.r>b.x && ball.x-ball.r<b.x+b.w && ball.y+ball.r>b.y && ball.y-ball.r<b.y+b.h) {
          b.alive=false;

          if (autopilot && autopilotAI.currentShot && autopilotAI.currentShot.type === "brick_shot") {
              learnFromResult(true, b);
          } else if (autopilot && autopilotAI.currentShot) {
              learnFromResult(false, b);
          }


          bricksHit++; // Incrémentation ici
          // playSound("impact");
          // --- Collision briques (vérification de l'appel) ---
          // Collision briques (vers ligne 1000)

        if (decrementEffect) {
          // Si le malus est actif, on applique la pénalité.
          let penalty = 100 * (mult + multX);
          score -= penalty;
          playSoundScoreMultiplied(1, 1);
          showScoreDecrementAnim(b.x + b.w / 2, b.y + b.h / 2, penalty);
        } else {
          TmpMult=mult+multX
          // Le gain de points normal...
          let brickPoints = 100 * TmpMult;
          score += brickPoints;
          updateStatsPanel();
            playSoundScoreMultiplied(10, TmpMult);
            showScoreBonusAnim(b.x + b.w / 2, b.y + b.h / 2, brickPoints);
        }

          for(let j=0;j<16;j++) {
            let a=Math.random()*2*Math.PI, v=2+Math.random()*3;
            particles.push({x:ball.x,y:ball.y,dx:Math.cos(a)*v,dy:Math.sin(a)*v,life:16,color:COLORS[b.colorIdx%COLORS.length]});
          }
          if(b.special) {
            if(b.special === "☠️") {
              spawnSkull(b);
            } else {
              spawnPowerup(b);
            }
          }

          bricksHit++; // Incrément pour calcul de vitesse
          updateBallSpeed(); // Mise à jour progressive de la vitesse

          // Conservation de la direction pour le rebond
          let dir = Math.atan2(ballDY, ballDX);
          ballDX = Math.cos(dir) * currentGameSpeed;
          ballDY = Math.sin(dir) * currentGameSpeed;

          if(Math.abs(ball.x-(b.x+b.w/2))>Math.abs(ball.y-(b.y+b.h/2))) ballDX*=-1;
          else ballDY*=-1;
          break;
        }
      }

      // --- Boucle de collecte des power-ups (CORRIGÉE DÉFINITIVEMENT) ---
      powerups.forEach(p => {
          // ✅ NOUVEAU : Validation de sécurité pour éviter les crashes
          if (!p || typeof p.y === 'undefined') {
              p.caught = true; // Marquer pour suppression
              return;
          }

          // ✅ MOUVEMENT SÉCURISÉ POUR TOUS LES PROJECTILES
          if (p.type === "boss_projectile") {
              // Mouvement vertical standard
              p.y += p.speed * dt;

              // Mouvement horizontal pour les projectiles en éventail
              if (p.dx && typeof p.dx === 'number') {
                  p.x += p.dx * dt * 0.5; // Vitesse réduite pour l'horizontal
              }

              // ✅ HOMING SÉCURISÉ ET PRÉVISIBLE
              if (p.homing && p.y < paddleY + 100 && p.y > 50) {
                  let targetX = paddleX + paddleW / 2;
                  let deltaX = targetX - p.x;

                  // Vitesse de correction très réduite pour éviter les oscillations
                  let correctionSpeed = Math.min(Math.abs(deltaX) * 0.02, 30 * dt);
                  let direction = deltaX > 0 ? 1 : -1;

                  p.x += direction * correctionSpeed;
              }
          } else {
              // Mouvement normal pour les autres powerups
              p.y += p.speed * dt;
          }

          // ✅ DISPARITION AVEC MARGE ÉTENDUE
          if (p.y > CANVAS_H + 100 || p.x < -100 || p.x > CANVAS_W + 100) {
              p.caught = true;
              return;
          }

          // ✅ COLLISION AMÉLIORÉE ET SÉCURISÉE
          if (p.y + 10 >= paddleY && p.y - 10 <= paddleY + paddleH &&
              p.x + 10 >= paddleX && p.x - 10 <= paddleX + paddleW) {

              p.caught = true;

              // ✅ GESTION DES PROJECTILES DE BOSS (CORRIGÉE)
              if (p.type === "boss_projectile") {
                  // Dégâts au joueur
                  vies = Math.max(0, vies - 1);
                  playSound("mort");

                  // Effet visuel de dégâts
                  for (let j = 0; j < 15; j++) {
                      let a = Math.random() * 2 * Math.PI, v = 4 + Math.random() * 6;
                      particles.push({
                          x: p.x, y: p.y,
                          dx: Math.cos(a) * v, dy: Math.sin(a) * v,
                          life: 20, color: "#f00"
                      });
                  }

                  // ✅ NOUVEAU : Effet de flash rouge sur la raquette
                  timeoutManager.set('paddleDamageFlash', () => {
                    // Rien à faire, juste pour créer un délai visuel
                  }, 200);

                  updateHUD();

                  // Vérifier game over
                  if (vies <= 0) {
                      gameOver = true;
                      setTimeout(() => showEndPanel(), 400);
                  }

                  return; // ✅ IMPORTANT : sortir immédiatement
              }

              // ✅ GESTION DES POWERUPS NORMAUX (inchangée)
              if (decrementEffect) {
                  playSound("mort");
                  let penalty = 1000;
                  score -= penalty;
                  showScoreDecrementAnim(p.x, p.y, penalty);
              } else {
                  playSound("powerup");
                  handleIconImpact({
                      icon: p.icon,
                      x: p.x,
                      y: p.y,
                      size: 20,
                      color: p.color || "#fff",
                      type: p.type
                  });
              }
          }
      });

      // ✅ FILTRAGE SÉCURISÉ
      powerups = powerups.filter(p => p && !p.caught);



      // --- Boucle de collecte des bonus (CORRIGÉE DÉFINITIVEMENT) ---
      bonuses.forEach(b => {
        b.y += b.speed * dt;

        if (b.y > CANVAS_H) b.caught = true;

        if (b.y > paddleY && b.x > paddleX && b.x < paddleX + paddleW && b.y < paddleY + paddleH) {

          if (b.type === "cookie") {
                cookies++; // On ajoute un cookie
                playSound("life2");
          }

          if (b.type === "XultX") {
              multX++;
              saveMultX(multX);
              playSound("life2")
          }

          if (b.type === "cookiex2") {
                cookies++; // On ajoute un cookie
                TmpCook = cookies * 2
                cookies--; // On ajoute un cookie
                cookies = TmpCook ; // On ajoute un cookie
                playSound("life2");
                playSound("life2");
          }
          if (b.type === "vie") {
                vies++; // On ajoute une vie
                playSound("life2");
          }
          if (b.type === "niveau") {
              if (isBossLevel && boss) {
                  boss.alive = false;
                  bossDefeated = true;
                  bossHP = 0;

                }
                bricks.forEach(b => b.alive = false);
                vies++; // On ajoute une vie
                TmpMult=mult+multX
                playSoundScoreMultiplied(10, TmpMult);
                score += 20000 * (TmpMult)
                playSound("boss_death");
          }


          // ✅ AJOUT : Comptage des bonus collectés
          if (bonusesCaptured[b.emoji] !== undefined) {
            bonusesCaptured[b.emoji]++;
          }

          b.caught = true;
          updateHUD();

          bonuses = bonuses.filter(b => !b.caught);

          if (decrementEffect) {
            // Si le malus est actif, on applique la pénalité.
            playSound("mort");
            let penalty = b.points;

            // ** LA CORRECTION EST ICI : "sscore" a été remplacé par "score" **
            score -= penalty;

            showScoreDecrementAnim(b.x, b.y, penalty);

          } else {
              // Sinon, on gagne les points normalement (multiplicateur inclus).
//              playSound("bonus");
              TmpMult=mult+multX+5
              playSoundScoreMultiplied(12, TmpMult);
              playSoundScoreMultiplied(12, TmpMult);
              let finalPoints = b.points * (mult + multX);
              totalBonusPoints += b.points * (mult + multX);
              // ✅ CORRECTION : Ajouter les points immédiatement
              score += finalPoints;
              // Animation visuelle (sans délai pour les points)
              showScoreBonusAnim(b.x, b.y, finalPoints);

          }
        }
      });
      bonuses = bonuses.filter(b => !b.caught);



      // Skulls (☠️)
      skulls.forEach(s=>{
        s.y+=s.speed*dt;
        if(s.y>CANVAS_H) s.caught=true;
        if(s.y>paddleY && s.x>paddleX && s.x<paddleX+paddleW && s.y<paddleY+paddleH) {
          s.caught=true;
          playSound("mort");
          handleIconImpact({
            icon: s.icon,
            x: s.x,
            y: s.y,
            size: 20,
            color: "#fff",
            type: "skull"
          });
          startDecrement();
        }
      });
      skulls = skulls.filter(s=>!s.caught);

      animations.forEach(a => {
        let t = 1 - a.frames/36;
//        let cx = a.x + (CANVAS_W-600 - a.x)*t + Math.sin(t*3)*22;
//        let cy = a.y + (60 - a.y)*t - Math.sin(t*Math.PI)*18;

        let cx = a.x + (a.targetX - a.x) * t;
        let cy = a.y + (a.targetY - a.y) * t;

        ctx.save();
        ctx.translate(cx, cy);
        ctx.rotate(Math.sin(t*5)*0.4);
        ctx.font = a.size + "px "+EMOJI_FONT;
        ctx.globalAlpha = 0.9 - t*0.5;
        ctx.shadowColor = a.color;

//        ctx.shadowBlur = 10 + 10*Math.abs(Math.sin(t*6));
        setOptimizedShadowBlur(ctx, 10 + 10*Math.abs(Math.sin(t*6)), "boss-flash");

        ctx.fillStyle = a.color;
        ctx.fillText(a.icon, 0, 0);
        ctx.shadowBlur=0;
        if (a.frames < 10) {
          for(let k=0;k<8;k++) {
            ctx.save();
            ctx.globalAlpha = 0.18 + 0.12*Math.sin(performance.now()/80 + k);
            ctx.beginPath();
            ctx.arc(a.targetX + Math.cos(k*Math.PI/4)*18, a.targetY + Math.sin(k*Math.PI/4)*18, 3, 0, 2*Math.PI);
            ctx.fillStyle = COLORS[k%COLORS.length];
            ctx.shadowColor = COLORS[k%COLORS.length];

            setOptimizedShadowBlur(ctx, 8, "boss-flash");
//            ctx.shadowBlur = 8;
            ctx.fill();
            ctx.restore();
          }
        }
        if (a.frames < 10) {
          for(let k=0;k<2;k++) {
            ctx.save();
            ctx.globalAlpha = 0.22 + 0.12*Math.sin(performance.now()/80 + k);
            ctx.beginPath();
            ctx.arc(a.targetX, a.targetY, 22+6*k+a.frames*1.2, 0, 2*Math.PI);
            ctx.strokeStyle = k%2===0 ? "#ff0" : "#fff";
            ctx.lineWidth = 1.5+k;
            ctx.shadowColor = k%2===0 ? "#ff0" : "#fff";
//            ctx.shadowBlur = 8;
            setOptimizedShadowBlur(ctx, 8, "boss-flash");
            ctx.stroke();
            ctx.restore();
          }
        }
        ctx.restore();
        a.frames--;
      });
      animations = animations.filter(a => a.frames > 0);

      if (mult > 1) {
        // On décrémente le minuteur en utilisant les secondes réelles.
        multTimer -= elapsed_ms / 1000;

        if (multTimer <= 0) {
          mult = 1;
          multTimer = 0;
        }
      }

      MultTMP = mult + multX
      updateMultDisplay(MultTMP);

      particles.forEach(p=>{
        p.x+=p.dx; p.y+=p.dy; p.life--;
      });
      particles = particles.filter(p=>p.life>0);

      // NOUVEAU MOTEUR D'ANIMATION DU SCORE (Gère correctement les nombres négatifs)
      const scoreDifference = score - displayScore;

      // On anime le score s'il y a un écart significatif (l'animation fluide est conservée)
      if (Math.abs(scoreDifference) > 1) {
        displayScore += scoreDifference * 0.18; // Vitesse de l'animation
        elScore.classList.add("flash");
      } else {
        // Si l'animation est terminée, on s'assure que la valeur est exacte et on arrête le flash.
        displayScore = score;
        elScore.classList.remove("flash");
      }

      // --- NOUVELLE LOGIQUE D'AFFICHAGE ROBUSTE (LA CORRECTION FINALE) ---
      let scoreToDisplay = Math.round(displayScore);

      if (scoreToDisplay >= 0) {
        // Si le score est POSITIF ou nul, on utilise la méthode classique.
        elScore.textContent = scoreToDisplay.toString().padStart(9, "0");
      } else {
        // Si le score est NÉGATIF :
        // 1. On prend la valeur absolue du score (ex: -5000 -> 5000).
        let positiveValue = Math.abs(scoreToDisplay);

        // 2. On la formate sur 8 caractères pour laisser de la place au signe "-".
        let paddedScore = positiveValue.toString().padStart(8, "0");

        // 3. On ajoute manuellement le signe "-" au début.
        elScore.textContent = "-" + paddedScore;
      }


      if(ball.y-ball.r>CANVAS_H) {

        if (autopilot && autopilotAI.currentShot && autopilotAI.currentShot.type === "ball_save") {
            learnFromResult(false);
            console.log("💀 Échec sauvegarde balle - amélioration nécessaire");
        }

        vies--; mult = 1; multTimer = 0;

        playSound("life");

        ballSpeed = ballSpeed0;

        if(vies<=0) {
          gameOver=true;
          elapsedTime = Math.floor((Date.now() - startTime) / 1000);
          setTimeout(()=>showEndPanel(),400);
        }
        else resetBall();
        updateHUD();
      }

      // === CONDITION DE VICTOIRE ÉQUILIBRÉE ===
      // === CONDITION DE VICTOIRE ÉQUILIBRÉE AVEC DÉLAI ===
      levelComplete = false;

      if (isBossLevel) {
          // BOSS : Vérifications complètes et sécurisées
          levelComplete = boss &&
                         !boss.alive &&
                         bossDefeated &&
                         bricks.every(b => !b.alive) &&
                         bossHP <= 0;
//                         ballDX = 0;
//                         ballDY = 0;
      } else {
          // NIVEAU NORMAL : Juste les briques
          levelComplete = bricks.every(b => !b.alive);
      }

      // Arrêt immédiat de la balle si tableau terminé en autopilot
      if (levelComplete && autopilot) {
        ballDX = 0;
        ballDY = 0;
      }

      // ✅ NOUVEAU : Gestion de la transition avec délai
      if (levelComplete && !levelTransition) {

          ballDX = 0;
          ballDY = 0;

          // ✅ 1. DÉMARRER LA TRANSITION
          playSound("coins");
          levelTransition = true;
          levelTransitionTimer = performance.now();

          // ✅ 2. MESSAGE DE TRANSITION SELON LE TYPE DE NIVEAU
          if (isBossLevel) {
            ballDX = 0;
            ballDY = 0;
            playSound("boss_death");
              levelTransitionMessage = `🏆 BOSS VAINCU ! 🏆\n\nNiveau ${niveau + 1} dans 3...`;
          } else {
            ballDX = 0;
            ballDY = 0;
            playSound("victoire_alt");
              levelTransitionMessage = `✅   ❇️NIVEAU ${niveau} TERMINÉ  ✅\n\nProchain niveau dans 3...`;

          }

          // ✅ 3. ARRÊTER LA BALLE TEMPORAIREMENT
          ballDX = 0;
          ballDY = 0;

          console.log(`🎯 Transition démarrée : ${levelTransitionMessage}`);
      }

      // ✅ 4. GESTION DU DÉLAI DE TRANSITION
      if (levelTransition) {
          let elapsed = performance.now() - levelTransitionTimer;
          let secondsLeft = Math.ceil((levelTransitionDelay - elapsed) / 1000);

          // ✅ Mise à jour du message avec compte à rebours
          if (isBossLevel) {
            ballDX = 0;
            ballDY = 0;
            playSound("boss_death");

              levelTransitionMessage = `🏆 BOSS VAINCU 🏆\n\nNiveau ${niveau + 1} dans ${secondsLeft}...`;
              // ✅ CORRECTION : Vies supprimées d'ici - elles sont déjà ajoutées ailleurs
          } else {
            ballDX = 0;
            ballDY = 0;
            playSound("victoire_alt");

              levelTransitionMessage = `✅  NIVEAU ${niveau} TERMINÉ ✅\n\nProchain niveau dans ${secondsLeft}...`;
          }


          // ✅ 5. FIN DE LA TRANSITION - PASSAGE AU NIVEAU SUIVANT
          if (elapsed >= levelTransitionDelay) {
          levelTransition = false;
          levelTransitionMessage = "";
          // Sauvegarde de l'état boss
  const wasIsBossLevel = isBossLevel;

  // Progression du niveau et récompenses
  niveau++;
  changeGalaxyConfiguration();
  playSound("victoire_alt");
  //playSoundScoreMultiplied(12, mult + 12);
  levelsPassed++;
  panic = 0;
  score += 40000 * niveau;
  vies += 1;
  cookies += 1;

  // Offsets et progression du mur
  wallOffset += 3;
  wallOffsetPlus += 3;
  if (wallOffsetPlus >= 10) {
      brickRows = Math.min(12, brickRows + 1);
      wallOffsetPlus = 0;
  }

  // Nettoyage spécifique boss (si on vient d'un boss)
  if (wasIsBossLevel) {
      timeoutManager.clear('bossInvulnerable');
      for (let i = 0; i < 50; i++) {
          timeoutManager.clear(`bossVictory${i}`);
      }
      // Reset complet des variables boss
      isBossLevel = false;
      boss = null;
      bossDefeated = false;
      bossHP = 0;
      bossInvulnerable = false;
      bossAttackTimer = 0;
      bossMovementTimer = 0;
  }

  // ✅ BARRIÈRE SANITAIRE: tout arrêter AVANT de recréer le niveau
  clearAllAnimations(); // stop RAF/psy/particles/animations et timeouts individuels listés
  clearAllTimersEndLevel(); // purge manager + boss + flags effets + UI

  // Création du prochain niveau
  if (niveau % 5 === 0) {
      createBoss();
  } else {
      createBricks();
  }

  // Balle et HUD
  resetBall();
  updateHUD();

  // Bonus initial éventuel (inchangé)
  if (Math.random() < 0.60) {
      spawnBonus();
  }

  console.log(`🚀 Niveau ${niveau} démarré !`);


              // ✅ 8. GESTION DES OFFSETS (ORDRE CORRIGÉ)
              wallOffset += 3;
              wallOffsetPlus += 3;

              if (wallOffsetPlus >= 10) {
                  brickRows = Math.min(12, brickRows + 1);
                  wallOffsetPlus = 0;
              }

              // ✅ 9. NETTOYAGE COMPLET (AVANT LA CRÉATION)
              if (wasIsBossLevel) {
                  // Nettoyage spécifique boss
                  timeoutManager.clear('bossInvulnerable');
                  for (let i = 0; i < 50; i++) {
                      timeoutManager.clear(`bossVictory${i}`);
                  }

                  // Reset des variables boss
                  isBossLevel = false;
                  boss = null;
                  bossDefeated = false;
                  bossHP = 0;
                  bossInvulnerable = false;
                  bossAttackTimer = 0;
                  bossMovementTimer = 0;
              }

              // Nettoyage général
              clearAllTimersEndLevel();

              // ✅ 10. CRÉATION DU PROCHAIN NIVEAU
              if (niveau % 5 === 0) {
                  createBoss();
              } else {
                  createBricks();
              }

              // ✅ 11. FINALISATION
              resetBall();
              updateHUD();

              // ✅ 12. BONUS (PROBABILITÉ ÉQUILIBRÉE)
              if (Math.random() < 0.60) {
                  spawnBonus();
              }

              console.log(`🚀 Niveau ${niveau} démarré !`);
          }
      }

      // ✅ 8. BONUS CONTINU (FRÉQUENCE RÉDUITE POUR ÉVITER LE SPAM)
      if (Math.random() < 0.002 && bonuses.length < 2) { // 0.003 -> 0.002
          spawnBonus();
      }
    }

    // --- Fonctions utilitaires pour powerups, bonus, effets, etc. ---

    function spawnPowerup(b) {
      let x=b.x+b.w/2, y=b.y+b.h/2;
      let icon=b.special, type=null;
      let color="#fff";
      if(icon==="🏳️") type="long";  // ✅ CORRIGÉ
      if(icon==="🏴‍☠️") type="short";
      if(icon==="🍭") type="temps"; // ✅ COHÉRENT maintenant
      if(icon==="1️⃣") type="mult1";  // ✅ CORRIGÉ
      if(icon==="2️⃣") type="mult2";
      if(icon==="4️⃣") type="mult4";
      if(icon==="6️⃣⃣") type="mult6";
      if(icon==="8️⃣") type="mult8";
      if(icon==="🔟") type="mult10";
//      if(icon==="🦁⃣") type="XultX";
      if(icon==="❤️‍🔥") type="huge";
      powerups.push({
        x, y, icon, type, color, speed:6+Math.random()*2, caught:false, drop:true
      });
    }
    //Fin de fonction spawnPowerup


    function spawnSkull(b) {
      let x=b.x+b.w/2, y=b.y+b.h/2;
      skulls.push({
        x, y, icon:"☠️", speed:7+Math.random()*2, caught:false
      });
    }

    // Résout l'impact relatif à produire sur la raquette pour viser un point cible (tx, ty)
    // Hypothèses: rebond immédiat depuis la raquette (y = paddleY - ball.r),
    // trajet balistique simple (ligne droite), pas de murs avant touche cible.
    // Retourne {impactRel, paddleCenterX} ou null si géométrie impossible.
    function solveImpactForTarget(ball, targetX, targetY, paddleY, paddleW) {
      // On veut une direction (angle) telle que depuis (ball.x, paddleY - ball.r)
      // la ligne atteigne (targetX, targetY). dx, dy proportionnels au vecteur.
      const startX = ball.x;
      const startY = paddleY - ball.r;

      const dirX = targetX - startX;
      const dirY = targetY - startY;

      // Target doit être au-dessus
      if (dirY >= -1) return null;

      // L'angle vertical "idéal" autour de la normale vers le haut:
      // newAngle = atan2(dx, -dy) ; exactement ce que fait computePaddleBounce avec rel.
      const desiredAngle = Math.atan2(dirX, -dirY);

      // Inverse de computePaddleBounce: rel = newAngle / maxBounceAngle
      const maxAngle = 4 * Math.PI / 12; //Fin de fonction solveImpactForTarget
      let impactRel = desiredAngle / maxAngle;

      // Si l'angle requis dépasse la capacité de la raquette, on ne peut pas viser directement
      if (impactRel < -1 || impactRel > 1) {
        return null;
      }

      // Convertir impactRel en position de centre de raquette
      // impactRel = (impactPoint - paddleCenter) / (paddleW/2)
      // impactPoint ~= ball.x à l'impact (on impose l’impact sur x ball.x)
      const paddleCenterX = ball.x - impactRel * (paddleW / 2);

      return { impactRel, paddleCenterX };
    } //Fin de fonction solveImpactForTarget


    function startDecrement() {
      decrementTimer = 30; // durée en secondes
      decrementActive = true;
      decrementEffect = true;
      decrementStartTime = performance.now(); // horodatage précis
//      elDec.textContent = "☠️ SCORE - (30s)";
//      elDec.style.display = "block";
    }


    /**
     * Affiche une animation de perte de score à l'écran.
     * VERSION CORRIGÉE : Ne contient plus d'erreurs de syntaxe et vise le compteur de score.
     */
    function showScoreDecrementAnim(x, y, points) {
      // --- Cible de l'animation de perte de points ---
      // On récupère la position du compteur de score pour que l'animation s'y dirige.
      const scoreEl = document.getElementById('score');
      const rect = scoreEl.getBoundingClientRect();
      const canvasRect = canvas.getBoundingClientRect();
      const targetX = rect.left + rect.width / 2 - canvasRect.left;
      const targetY = rect.top + rect.height / 2 - canvasRect.top;

      animations.push({
        icon: "-" + points, // Affiche le montant correct de la pénalité
        x: x,
        y: y,
        size: 24,         // Un peu plus grand pour être bien visible
        targetX: targetX, // Cible le compteur de score (corrigé)
        targetY: targetY, // Cible le compteur de score (corrigé)
        frames: 30,       // Une animation légèrement plus longue
        color: "#ff4444"  // Couleur rouge distinctive pour les malus
      });
    }




    function showScoreBonusAnim(x, y, pts) {
      const scoreEl = document.getElementById('score');
      const rect = scoreEl.getBoundingClientRect();
      const canvasRect = canvas.getBoundingClientRect();
      const targetX = rect.left + rect.width / 2 - canvasRect.left;
      const targetY = rect.top + rect.height / 2 - canvasRect.top;
      animations.push({
        icon: "+" + pts,
        x: x,
        y: y,
        size: 20,
        targetX: targetX,
        targetY: targetY,
        frames: 26,
        color: "#ff0"
      });
    }


    function applyPowerup(p) {

      // ✅ NOUVEAU : Gestion spécifique du powerup TEMPS

        if (p.type === "temps") {
          multMax += 5;
          // ✅ AUGMENTATION MASSIVE DU MULTIPLICATEUR
          let oldMult = mult;
          mult = Math.min(mult + 1, multMax); // Ajoute 11, plafonné à multMax
          // ✅ AJOUT DE TEMPS (cumule avec le temps restant)
          multTimer += 45; // Ajoute toujours 4 minutes
          // ✅ LOG DE VÉRIFICATION
          console.log(`🍭 Powerup TEMPS appliqué ! Mult: ${oldMult} → ${mult}, Timer: ${multTimer}s`);
          // ✅ MISE À JOUR IMMÉDIATE DE L'AFFICHAGE
          updateHUD();
          multiTMP = mult + multX
          updateMultDisplay(multiTMP);

          // ✅ SON SPÉCIAL POUR CE POWERUP PUISSANT
          playSound("bonus");

          return; // ✅ SORTIE IMMÉDIATE pour éviter les autres traitements
        }


      if (p.type === "long") {
          // ✅ ANNULATION de l'effet précédent
          if (paddleSizeEffect !== null) {
              timeoutManager.clear('paddleSize');
          }

          paddleSizeEffect = "long";
          paddleOriginalSize = paddleBaseW; // ✅ Toujours partir de la base
          paddleW = Math.min(320, paddleOriginalSize + 70);

          timeoutManager.set('paddleSize', () => {
              paddleW = paddleOriginalSize; // ✅ Retour à la taille de base
              paddleSizeEffect = null;
              playSound("raquettenormale");
          }, 30000);
      }


      if (p.type === "short") {
          // ✅ ANNULATION de l'effet précédent
          if (paddleSizeEffect !== null) {
              timeoutManager.clear('paddleSize');
          }

          playSound("mort");
          paddleSizeEffect = "short";
          paddleOriginalSize = paddleBaseW; // ✅ Toujours partir de la base
          paddleW = Math.max(50, paddleOriginalSize - 60);

          timeoutManager.set('paddleSize', () => {
              paddleW = paddleOriginalSize; // ✅ Retour à la taille de base
              paddleSizeEffect = null;
              playSound("raquettenormale");
          }, 30000);
      }

      if (p.type && p.type.startsWith("mult")) {
        let val = parseInt(p.type.replace("mult", ""));
        mult = Math.min(mult + val, multMax);
        multTimer += 30; // Si géré par un interval ailleurs, assurez-vous de le clearer si needed
      }

//      if (mult >= 15) {
//        playSoundEuphoria();
//      }

      if (p.type === "cookie") { // Correction : b.type -> p.type (assuming typo)
        cookies++;
        updateHUD();
        playSound("life2");
      }

      if (p.type === "huge") {
          // ✅ ANNULATION de l'effet précédent
          if (paddleSizeEffect !== null) {
              timeoutManager.clear('paddleSize');
          }
          if (paddleHugeTimeout) {
              clearTimeout(paddleHugeTimeout);
              paddleHugeTimeout = null;
          }

          paddleSizeEffect = "huge";
          paddleOriginalSize = paddleBaseW; // ✅ Toujours partir de la base
          paddleTimer = 30;
          paddleTimerActive = true;

          // ✅ CALCUL BASÉ SUR LA TAILLE DE BASE, pas la taille actuelle
          paddleW = Math.min(CANVAS_W - 40, paddleOriginalSize * 2.5);

          paddleHugeTimeout = setTimeout(() => {
              paddleW = paddleOriginalSize; // ✅ Retour à la taille de base
              paddleSizeEffect = null;
              paddleTimerActive = false;
              paddleHugeTimeout = null;
              playSound("raquettenormale");
          }, 30000);

        // Génération de particules (inchangé)
        for (let j = 0; j < 36; j++) {
          let a = Math.random() * 2 * Math.PI, v = 5 + Math.random() * 8;
          particles.push({x: paddleX + paddleW / 2, y: paddleY, dx: Math.cos(a) * v, dy: Math.sin(a) * v, life: 30, color: "#f55"});
        }
      }

    }


    function spawnBonus() {

      let b = BONUS_ICONS[Math.floor(Math.random()*BONUS_ICONS.length)];


      // Rareté multX: seulement 1% de chances d’accepter quand tiré
      if (b.type === "XultX" && Math.random() > 0.05) {
        // On relance une fois proprement sur un autre bonus non-multX
        const others = BONUS_ICONS.filter(x => x.type !== "XultX");
        b = others[Math.floor(Math.random() * others.length)];
      }
      //Fin de filtrage rareté multX

      bonuses.push({
        x: Math.random()*(CANVAS_W-120)+60,
        y: wallOffset+30,
        emoji: b.emoji,
        points: b.points,
        color: b.color,
        type: b.type, // <-- LA LIGNE MANQUANTE EST ICI
        speed: 7+Math.random()*2,
        caught: false

      });
    }


    function handleIconImpact(obj) {
      try {
        // Récupérer l'élément score avec check d'existence
        const scoreEl = document.getElementById('score');
        if (!scoreEl) {
          console.warn("Élément 'score' non trouvé – animation ignorée");
          return; // Sortir tôt pour éviter erreurs
        }

        const rect = scoreEl.getBoundingClientRect();
        const canvasRect = canvas.getBoundingClientRect();

        // Calculer la position cible relative au canvas
        const targetX = rect.left + rect.width / 2 - canvasRect.left;
        const targetY = rect.top + rect.height / 2 - canvasRect.top;

        // Incrémenter le compteur avec check
        if (!powerupsCaptured[obj.type]) powerupsCaptured[obj.type] = 0;
        powerupsCaptured[obj.type]++;

        // Créer l'animation
        let anim = {
          icon: obj.icon,
          x: obj.x,
          y: obj.y,
          size: obj.size,
          targetX: targetX,
          targetY: targetY,
          frames: 36,
          color: obj.color || "#fff"
        };
        animations.push(anim);

        // Gérer le délai avec un timeout annulable si needed (stocké globalement si plusieurs impacts)
        if (impactTimeout) clearTimeout(impactTimeout);
        // ✅ CORRECTION : Timeout séparé pour chaque impact
        let timeoutKey = `impact_${Date.now()}_${Math.random()}`;
        timeoutManager.set(timeoutKey, () => {
          if (obj.points && obj.points > 0) {
            score += obj.points;
          }
          if (obj.type && obj.type !== "skull") {
            applyPowerup(obj);
          }
        }, 400);

      } catch (error) {
        console.error("Erreur dans handleIconImpact :", error);
        // Continuer sans crash pour ne pas bloquer le jeu
      }
    }


    // === SCORE FINAL, TEMPS, STATS, MEILLEUR SCORE ===

    function setBestScore(val) {
      localStorage.setItem("akranoid_best_score", val);
    }

    function startPsychedelicBg() {
      const canvas = document.getElementById('psyCanvas');
      if (!canvas) return;
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      const ctx = canvas.getContext('2d');
      let t = 0;

      function draw() {
        ctx.clearRect(0,0,canvas.width,canvas.height);
        let w = canvas.width, h = canvas.height;
        let cx = w/2, cy = h/2;
        for (let i=0; i<18; i++) {
          let angle = (t*0.03) + i*Math.PI/9;
          let r = 180 + 80*Math.sin(t*0.02+i);
          let x = cx + Math.cos(angle)*r;
          let y = cy + Math.sin(angle)*r;
          let size = 110 + 10*Math.sin(t*0.07+i*1.3);
          let color = `hsl(${(t*4+i*20)%360},95%,60%)`;
          ctx.save();
          ctx.globalAlpha = 0.21 + 0.18*Math.sin(t*0.09+i);
          ctx.translate(x, y);
          ctx.rotate(angle + Math.sin(t*0.04+i)*1.2);
          ctx.beginPath();
          ctx.arc(0, 0, size, 0, 2*Math.PI);
          ctx.fillStyle = color;
          ctx.shadowColor = color;
          setOptimizedShadowBlur(ctx, 40, "bonus");
//          ctx.shadowBlur = 40;
          ctx.fill();
          ctx.restore();
        }
        t++;
        psyAnimId = requestAnimationFrame(draw);
      }
      draw();
    }


    function stopPsychedelicBg() {
        if (typeof psyAnimId !== 'undefined' && psyAnimId) {
            cancelAnimationFrame(psyAnimId);
            psyAnimId = null;
        }
        const canvas = document.getElementById('psyCanvas');
        if (canvas) {
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }
    }

    function bossAttack() {
        if (!boss || !boss.alive || bossInvulnerable) return;

        let attackType = Math.random();

        if (bossPhase === 1) {
            // Phase 1 : Attaques simples
            if (attackType < 0.7) {
                bossFireProjectile();
            } else {
                bossSpawnEnemyBricks();
            }
        } else if (bossPhase === 2) {
            // Phase 2 : Attaques plus variées
            if (attackType < 0.4) {
                bossFireProjectile();
            } else if (attackType < 0.7) {
                bossSpawnEnemyBricks();
            } else {
                bossFireSpread();
            }
        } else {
            // Phase 3 : Attaques dévastatrices
            if (attackType < 0.3) {
                bossFireProjectile();
            } else if (attackType < 0.5) {
                bossFireSpread();
            } else if (attackType < 0.8) {
                bossRainAttack();
            } else {
                bossSpawnSkulls();
            }
        }
    }

    function bossFireProjectile() {
        // ✅ VALIDATION STRICTE
        if (!boss || !boss.alive || bossInvulnerable) return;

        // ✅ PROJECTILE AVEC MOUVEMENT ALÉATOIRE
        let randomAngle = (Math.random() - 0.5) * 0.4; // Variation d'angle ±0.2 radians
        let speedVariation = 8 + Math.random() * 12; // ✅ VITESSE RÉDUITE : entre 8 et 20

        powerups.push({
            x: boss.x + boss.w/2,
            y: boss.y + boss.h + 10,
            icon: "💥",
            type: "boss_projectile",
            color: "#f00",
            speed: speedVariation,
            caught: false,
            drop: true,
            homing: false,
            dx: Math.sin(randomAngle) * speedVariation * 0.3,  // ✅ NOUVEAU : Dérive horizontale aléatoire
            dy: Math.cos(randomAngle) * speedVariation,        // ✅ NOUVEAU : Vitesse verticale variable
            wobble: Math.random() * 2,                         // ✅ NOUVEAU : Facteur d'oscillation
            wobbleSpeed: 0.1 + Math.random() * 0.1,            // ✅ NOUVEAU : Vitesse d'oscillation
            age: 0                                             // ✅ NOUVEAU : Âge du projectile pour animations
        });
        playSound("impact");
    }



    function bossFireSpread() {
        // ✅ VALIDATION STRICTE
        if (!boss || !boss.alive || bossInvulnerable) return;

        // ✅ TIR EN ÉVENTAIL SIMPLIFIÉ
        for (let i = -1; i <= 1; i++) {
            powerups.push({
                x: boss.x + boss.w/2 + i * 25,
                y: boss.y + boss.h + 10,
                icon: "⭐",
                type: "boss_projectile",
                color: "#fa0",
                speed: 35,
                caught: false,
                drop: true,
                homing: false,
                dx: i * 25, // Direction horizontale simple
                dy: 35     // Direction verticale simple
            });
        }
        playSound("powerup");
    }

    function bossRainAttack() {
        // Pluie de projectiles
        for (let i = 0; i < 8; i++) {
            setTimeout(() => {
                powerups.push({
                    x: Math.random() * (CANVAS_W - 40) + 20,
                    y: -20,
                    icon: "💀",
                    type: "boss_projectile",
                    color: "#f0f",
                    speed: 10 + niveau * 0.8,
                    caught: false,
                    drop: true
                });
            }, i * 100);
        }
        playSound("mort");
    }

    function bossSpawnEnemyBricks() {
        // Crée des briques ennemies qui bougent
        let newBrickX = boss.x + (Math.random() - 0.5) * 200;
        newBrickX = Math.max(0, Math.min(CANVAS_W - brickW, newBrickX));

        bricks.push({
            x: newBrickX,
            y: boss.y + boss.h + 20,
            w: brickW,
            h: brickH,
            finalX: newBrickX,
            finalY: boss.y + boss.h + 20,
            colorIdx: 0,
            special: Math.random() < 0.4 ? "☠️" : null,
            alive: true,
            animFrame: 36,
            animAngle: 0,
            animating: false,
            isBossMinion: true,
            moveSpeed: 30,
            moveDirection: Math.random() < 0.5 ? -1 : 1
        });
    }

    function bossSpawnSkulls() {
        // Phase 3 : Spawn direct de skulls
        for (let i = 0; i < 3; i++) {
            skulls.push({
                x: Math.random() * (CANVAS_W - 40) + 20,
                y: boss.y + boss.h,
                icon: "☠️",
                speed: 100 + Math.random() * 50,
                caught: false
            });
        }
        playSound("mort");
    }


    function showEndPanel() {
        // Animation psychédélique
        // ✅ NOUVEAU : Application du scale avant affichage
        applyEndPanelScale();
        document.getElementById('TITRE').innerHTML = "--- GAME OVER ---<br><br>";
        const finalScoreEl = document.getElementById('finalScore');
        finalScoreEl.textContent = "SCORE : " + score.toLocaleString();
        finalScoreEl.classList.add('flashy-score');

        // Statistiques du jeu
        document.getElementById('bricksHit').textContent = "Briques touchées : " + bricksHit;
        document.getElementById('levelsPassed').textContent = "Tableaux passés : " + levelsPassed;
        let min = Math.floor(elapsedTime/60), sec = elapsedTime%60;
        document.getElementById('timePlayed').textContent = "Temps de jeu : " + min + "m " + sec + "s";

        let details = Object.entries(powerupsCaptured)
            .map(([k, v]) => v > 0 ? k + " : " + v : null)
            .filter(Boolean)
            .join("<br>");
        document.getElementById('powerupDetails').innerHTML = "Power-ups capturés :<br><br>" + (details || "Aucun");

        // ✅ NOUVEAU : Gestion des records
        let playerNameSection = document.getElementById('playerNameSection');
        let leaderboardSection = document.getElementById('leaderboardSection');
        let saveScoreBtn = document.getElementById('saveScoreBtn');
        let skipSaveBtn = document.getElementById('skipSaveBtn');
        let playerNameInput = document.getElementById('playerNameInput');

        // Vérifier si c'est un nouveau record
        if (isNewRecord(score)) {
            // ✅ NOUVEAU RECORD : Demander le nom
            playerNameSection.style.display = 'block';
            leaderboardSection.style.display = 'none';

            // Focus sur l'input
            setTimeout(() => {
                playerNameInput.focus();
                playerNameInput.select();
            }, 500);

            // ✅ GESTION DE LA SAISIE
            let scoreSaved = false;

            // Fonction de sauvegarde
            function saveScore() {
                if (scoreSaved) return;
                scoreSaved = true;

                let playerName = playerNameInput.value.trim() || "JOUEUR";
                addScoreToLeaderboard(playerName, score);

                // Masquer la saisie et afficher le classement
                playerNameSection.style.display = 'none';
                leaderboardSection.style.display = 'block';
                displayLeaderboard();

                playSound("bonus"); // Son de confirmation
            }

            // ✅ ÉVÉNEMENTS
            saveScoreBtn.onclick = saveScore;
            skipSaveBtn.onclick = () => {
                if (scoreSaved) return;
                scoreSaved = true;
                playerNameSection.style.display = 'none';
                leaderboardSection.style.display = 'block';
                displayLeaderboard();
            };

            // Sauver avec Entrée
            playerNameInput.onkeypress = (e) => {
                if (e.key === 'Enter') {
                    saveScore();
                }
            };

        } else {
            // ✅ PAS DE RECORD : Afficher directement le classement
            playerNameSection.style.display = 'none';
            leaderboardSection.style.display = 'block';
            displayLeaderboard();
        }

        // Affichage du meilleur score
        sendGameStartEmail();
  //      document.getElementById('bestScore').textContent = "Meilleur score : " + getBestScore().toLocaleString();

        // Afficher le panneau
        document.getElementById('endPanel').style.display = "flex";
        startPsychedelicBg();


    }

    function render() {

        ctx.clearRect(0, 0, CANVAS_W, CANVAS_H);

        // ✅ RENDU CONDITIONNEL DE LA GALAXIE
        if (galaxyEnabled) {
            renderGalaxy(ctx);
        }
        // ✅ RENDU OPTIMISÉ DES BRIQUES (SEUL SYSTÈME ACTIF)

        let fontSize = 50;

        renderBricksOptimized();

        // Rendu des particules
        particles.forEach(p => {
            ctx.save();
            ctx.globalAlpha = p.life / 30;
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, 5, 0, 2 * Math.PI);
            ctx.fill();
            ctx.restore();
        });

        // ✅ RENDU DES POWER-UPS
        powerups.forEach(p => {
            if (p.drop && !p.caught) {
                //fontSize = 50;
                setOptimizedShadowBlur(ctx, 18, "bonus");
                let shadowColor = "#fff";

                if (p.type === "boss_projectile") {
                    fontSize = 80;
                    setOptimizedShadowBlur(ctx, 30, "bonus");
                    shadowColor = p.color || "#f00";
                }

                ctx.font = fontSize + "px " + EMOJI_FONT;
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.shadowColor = shadowColor;
//                ctx.shadowBlur = shadowBlur;
                setOptimizedShadowBlur(ctx, 20, "bonus");
                ctx.fillStyle = p.color || "#fff";
                ctx.fillText(p.icon, p.x, p.y);
                ctx.shadowBlur = 0;
            }
        });

        // Rendu des bonus
        bonuses.forEach(b => {
            if (!b.caught) {
                fontSize =50;
                ctx.font = fontSize + "px " + EMOJI_FONT;
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.shadowColor = b.color;
//                ctx.shadowBlur = 20;
                setOptimizedShadowBlur(ctx, 20, "bonus");
                ctx.fillStyle = b.color;
                ctx.fillText(b.emoji, b.x, b.y);
                ctx.shadowBlur = 0;
            }
        });

        // Rendu des skulls
        skulls.forEach(s => {
            if (!s.caught) {
                ctx.font = fontSize + "px " + EMOJI_FONT;
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.shadowColor = "#fff";
                setOptimizedShadowBlur(ctx, 20, "bonus");
                ctx.fillStyle = "#fff";
                ctx.fillText(s.icon, s.x, s.y);
                ctx.shadowBlur = 0;
            }
        });

        // === RENDU DU BOSS ===
        if (isBossLevel && boss && boss.alive) {
            ctx.save();

            if (boss.entrancePhase) {
                boss.entranceY += 1.2;
                boss.y = boss.entranceY;
                if (boss.y >= 140) {
                    boss.entrancePhase = false;
                    boss.y = 140;
                }
            }

            let healthRatio = Math.max(0, bossHP / bossMaxHP);
            let skullSize = Math.max(80, boss.w * 0.8);

            if (boss.hitFlash > 0) {
                ctx.shadowColor = "#f00";
                setOptimizedShadowBlur(ctx, 35, "boss-flash");
//                ctx.shadowBlur = 35;
                ctx.fillStyle = "#fff";
                boss.hitFlash--;
            } else if (bossInvulnerable) {
                ctx.shadowColor = "#0ff";
//                ctx.shadowBlur = 30;
                setOptimizedShadowBlur(ctx, 30, "boss-flash");
                ctx.fillStyle = "#0ff";
            } else if (healthRatio <= 0.3) {
                ctx.shadowColor = "#f00";
                setOptimizedShadowBlur(ctx, 25, "boss-flash");
//                ctx.shadowBlur = 25;
                ctx.fillStyle = "#f44";
            } else if (healthRatio <= 0.6) {
                ctx.shadowColor = "#f80";
                setOptimizedShadowBlur(ctx, 35, "boss-flash");
//                ctx.shadowBlur = 20;
                ctx.fillStyle = "#fa0";
            } else {
                ctx.shadowColor = "#ff0";
                setOptimizedShadowBlur(ctx, 18, "boss-flash");
//                ctx.shadowBlur = 18;
                ctx.fillStyle = "#fff";
            }

            ctx.font = skullSize + "px " + EMOJI_FONT;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";

            let centerX = boss.x + boss.w / 2;
            let centerY = boss.y + boss.h / 2;

            if (healthRatio <= 0.3) {
                centerX += (Math.random() - 0.5) * 4;
                centerY += (Math.random() - 0.5) * 4;
            }

            let pulseScale = 1 + Math.sin(performance.now() / (200 - bossPhase * 50)) * 0.1;
            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.scale(pulseScale, pulseScale);

            ctx.strokeStyle = "#000";
            ctx.lineWidth = 3;
            ctx.strokeText("☠️", 0, 0);
            ctx.fillText("☠️", 0, 0);

            ctx.restore();
            ctx.restore();
        }

        // === RENDU DU MESSAGE DE TRANSITION ===
        if (levelTransition && levelTransitionMessage) {
            ctx.save();
            ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
            ctx.fillRect(0, 0, CANVAS_W, CANVAS_H);

            ctx.font = "25px Arial, sans-serif";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillStyle = "#FFD700";
            ctx.shadowColor = "#FFD700";
            ctx.shadowBlur = 8;

            let lines = levelTransitionMessage.split('\n');
            let centerY = CANVAS_H / 2;
            let lineHeight = 32;

            lines.forEach((line, index) => {
                let y = centerY + (index - (lines.length - 1) / 2) * lineHeight;
                if (index === lines.length - 1) {
                    let pulse = 1 + Math.sin(performance.now() / 200) * 0.05;
                    ctx.save();
                    ctx.translate(CANVAS_W / 2, y);
                    ctx.scale(pulse, pulse);
                    ctx.fillText(line, 0, 0);
                    ctx.restore();
                } else {
                    ctx.fillText(line, CANVAS_W / 2, y);
                }
            });

            ctx.restore();
        }

        // === RENDU DES ANIMATIONS (UNE SEULE FOIS) ===
        animations.forEach(a => {
            let t = 1 - a.frames / 36;
            let cx = a.x + (a.targetX - a.x) * t;
            let cy = a.y + (a.targetY - a.y) * t;

            ctx.save();
            ctx.translate(cx, cy);
            ctx.rotate(Math.sin(t * 5) * 0.4);

            let isTextAnimation = a.icon.toString().startsWith('+') || a.icon.toString().startsWith('-');
            ctx.font = a.size + "px " + (isTextAnimation ? FONT : EMOJI_FONT);

            ctx.globalAlpha = 0.9 - t * 0.5;
            ctx.shadowColor = a.color;
            ctx.shadowBlur = 10 + 10 * Math.abs(Math.sin(t * 6));
            ctx.fillStyle = a.color;
            ctx.fillText(a.icon, 0, 0);
            ctx.shadowBlur = 0;

            if (a.frames < 10) {
                for (let k = 0; k < 8; k++) {
                    ctx.save();
                    ctx.globalAlpha = 0.18 + 0.12 * Math.sin(performance.now() / 80 + k);
                    ctx.beginPath();
                    ctx.arc(a.targetX + Math.cos(k * Math.PI / 4) * 18, a.targetY + Math.sin(k * Math.PI / 4) * 18, 3, 0, 2 * Math.PI);
                    ctx.fillStyle = COLORS[k % COLORS.length];
                    ctx.shadowColor = COLORS[k % COLORS.length];
                    ctx.shadowBlur = 8;
                    ctx.fill();
                    ctx.restore();
                }

                for (let k = 0; k < 2; k++) {
                    ctx.save();
                    ctx.globalAlpha = 0.22 + 0.12 * Math.sin(performance.now() / 80 + k);
                    ctx.beginPath();
                    ctx.arc(a.targetX, a.targetY, 22 + 6 * k + a.frames * 1.2, 0, 2 * Math.PI);
                    ctx.strokeStyle = k % 2 === 0 ? "#ff0" : "#fff";
                    ctx.lineWidth = 1.5 + k;
                    ctx.shadowColor = k % 2 === 0 ? "#ff0" : "#fff";
                    ctx.shadowBlur = 8;
                    ctx.stroke();
                    ctx.restore();
                }
            }

            ctx.restore();
            a.frames--;
        });
        animations = animations.filter(a => a.frames > 0);

        // === RENDU DE LA RAQUETTE ===
        ctx.save();
        ctx.shadowColor = "#0ff";
        setOptimizedShadowBlur(ctx, 10, "raquette"); // ✅ Valeur
//        ctx.shadowBlur = 10;
        ctx.fillStyle = "#fff";
        ctx.fillRect(paddleX, paddleY, paddleW, paddleH);
        ctx.restore();

        // === RENDU DE LA BALLE ===
        ctx.save();
        ctx.shadowColor = "#f0f";
        setOptimizedShadowBlur(ctx, 18, "raquette"); // ✅ Valeur
//        ctx.shadowBlur = 18;
        ctx.fillStyle = "#ff0";
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.r, 0, 2 * Math.PI);
        ctx.fill();
        ctx.restore();
    }

    // === LANCEMENT DU JEU ===

    // Panneau d'explication des bonus
    document.addEventListener('DOMContentLoaded', function() {
        console.log("DOM chargé - Initialisation du jeu");

        // ✅ NOUVEAU : Initialiser le système de capture de souris
        const pointerLockSupported = initPointerLock();
        if (!pointerLockSupported) {
          console.log("📝 Utilisation du système de mapping étendu");
        }

        initializeCopyright();

        // Application au chargement et redimensionnement
        window.addEventListener('load', applyResponsiveScale);
        window.addEventListener('resize', applyResponsiveScale);

        // ✅ NOUVEAU : Application du scale optimal
        applyResponsiveScale();

        // Charger multX depuis le storage (sécurité au démarrage) puis rafraîchir HUD
        multX = loadMultX();
        updateHUD();
        updateMultDisplay(mult + multX);
        //Fin d’insertion pré-bonusPanel

        // ✅ NOUVEAU : Afficher le panneau de bonus au démarrage
        document.getElementById('bonusPanel').style.display = 'flex';

//        // ✅ NOUVEAU : Masquer le panneau de stats au démarrage
//        const statsPanel = document.getElementById('statsPanel');
//        if (statsPanel) statsPanel.style.display = 'none';

        // ✅ DÉTECTION MOBILE (fusionnée dans le même addEventListener)
        if (isMobileDevice()) {
            console.log('📱 Appareil mobile détecté');

            // Afficher les contrôles mobiles
            const mobileControls = document.getElementById('mobileControls');
            if (mobileControls) {
                mobileControls.style.display = 'flex';
            }

            // ... reste du code mobile ...
        } else {
            console.log('🖥️ Appareil desktop détecté');
        }

        // ✅ GESTION DU BOUTON OK (MODIFIÉE)
        document.getElementById('closeBonusPanel').onclick = function() {
            document.getElementById('bonusPanel').style.display = 'none';
            const statsPanel = document.getElementById('statsPanel');
            if (statsPanel) statsPanel.style.display = 'block';
            playBonusPanelJingle();

            // ✅ NOUVEAU : Lancer le jeu seulement maintenant
            startGame();
            pause = false;
        };
    });

    function isMobileDevice() {
        return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    }

    // ✅ FONCTION MANQUANTE : Récupération IP publique
    async function getPublicIP() {
        const services = [
            'https://api.ipify.org?format=json',
            'https://httpbin.org/ip',
            'https://api.myip.com',
            'https://ipapi.co/json'
        ];

        for (let service of services) {
            try {
                console.log(`🌐 Tentative de récupération IP via ${service}`);

                const response = await fetch(service, {
                    method: 'GET',
                    timeout: 3000,
                    signal: AbortSignal.timeout ? AbortSignal.timeout(3000) : undefined
                });

                if (response.ok) {
                    const data = await response.json();

                    // Extraction de l'IP selon le format du service
                    let ip = null;
                    if (data.ip) ip = data.ip;           // ipify.org et httpbin.org
                    else if (data.origin) ip = data.origin; // httpbin.org (format alternatif)
                    else if (data.query) ip = data.query;   // ip-api.com

                    if (ip && ip.match(/^\d+\.\d+\.\d+\.\d+$/)) {
                        console.log(`✅ IP publique récupérée : ${ip}`);
                        return ip;
                    }
                }
            } catch (error) {
                console.warn(`❌ Erreur service ${service}:`, error.message);
            }
        }

        console.warn('⚠️ Impossible de récupérer l\'IP publique - fallback activé');
        return 'IP non disponible';
    }


    function diagnosticGame() {
        console.log("=== DIAGNOSTIC DU JEU ===");
        console.log("gameStarted:", gameStarted);
        console.log("pause:", pause);
        console.log("gameOver:", gameOver);
        console.log("ball existe:", !!ball);
        console.log("canvas existe:", !!canvas);
        console.log("gameLoopId:", gameLoopId);
        console.log("Elements DOM:");
        console.log("- statsPanel:", !!document.getElementById('statsPanel'));
        console.log("- bricksStats:", !!document.getElementById('bricksStats'));
        console.log("- bonusPanel:", !!document.getElementById('bonusPanel'));

        // Auto-correction des problèmes détectés
        if (!gameStarted || pause || gameOver) {
            console.log("🔧 Correction automatique des états...");
            gameStarted = true;
            pause = false;
            gameOver = false;

            if (!gameLoopId) {
                gameLoopId = requestAnimationFrame(gameLoop);
                console.log("🔧 Boucle de jeu relancée");
            }
        }

        console.log("=== FIN DIAGNOSTIC ===");
    }

    // ✅ FONCTION AUDIO (EN DEHORS DE DOMContentLoaded)
    function playBonusPanelJingle() {
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        const notes = [
            {freq: 523, duration: 0.18}, // Do
            {freq: 659, duration: 0.18}, // Mi
            {freq: 784, duration: 0.18}, // Sol
            {freq: 988, duration: 0.18}, // Si
            {freq: 1046, duration: 0.18}, // Do+
            {freq: 784, duration: 0.18}, // Sol
            {freq: 659, duration: 0.18}, // Mi
            {freq: 523, duration: 0.26}  // Do (longue)
        ];

        let time = ctx.currentTime;
        notes.forEach((note, i) => {
            let osc = ctx.createOscillator();
            let gain = ctx.createGain();
            osc.type = "triangle";
            osc.frequency.setValueAtTime(note.freq, time);
            gain.gain.setValueAtTime(0.16, time);
            gain.gain.linearRampToValueAtTime(0, time + note.duration);
            osc.connect(gain).connect(ctx.destination);
            osc.start(time);
            osc.stop(time + note.duration);
            time += note.duration * 0.95;
        });
    }

    // ✅ FONCTION DE DEBUG (EN DEHORS DE DOMContentLoaded)
    // ✅ FONCTION DE DEBUG (EN DEHORS DE DOMContentLoaded)
    function showDebugPopup() {
        // Récupère les variables clés
        const debugData = {
            "État de pause": pause,
            "Jeu démarré": gameStarted,
            "Jeu terminé": gameOver,
            "Vies restantes": vies,
            "Niveau actuel": niveau,
            "Score actuel": score,
            "Position de la balle (x, y)": ball ? `${ball.x}, ${ball.y}` : "Balle non initialisée",
            "Vitesse de la balle (DX, DY)": `${ballDX}, ${ballDY}`,
            "Vitesse de la balle (globale)": ballSpeed,
            "Position de la raquette (x)": paddleX,
            "Largeur de la raquette": paddleW,
            "Autopilote activé": autopilot,
            "Cookies disponibles": cookies,
            "Briques restantes": bricks.filter(b => b.alive).length,
            "Power-ups actifs": powerups.length,
            "Bonus actifs": bonuses.length,
            "Skulls actifs": skulls.length,
            "Animations en cours": animations.length,
            "Particules": particles.length,
            "GameLoop ID": gameLoopId
        };

        // Crée le contenu HTML de la pop-up
        let content = '<div id="dragHandle" style="cursor: move; background: rgba(255,255,255,0.2); padding: 10px; text-align: center; font-weight: bold;">Débogage (Déplaçable)</div>';
        content += '<table style="width:100%; border-collapse: collapse;">';
        for (const [key, value] of Object.entries(debugData)) {
            content += `<tr><td style="border:1px solid #ccc; padding:5px; font-weight:bold;">${key}</td><td style="border:1px solid #ccc; padding:5px;">${value}</td></tr>`;
        }
        content += '</table><button onclick="this.parentElement.style.display=\'none\';">Fermer</button>';

        // Crée ou met à jour la pop-up
        let popup = document.getElementById('debugPopup');
        if (!popup) {
            popup = document.createElement('div');
            popup.id = 'debugPopup';
            popup.style.cssText = `
                position: fixed; top: calc(50% - 200px); left: calc(50% + 400px);
                transform: translate(-50%, -50%); background: rgba(0,0,0,0.8);
                color: #fff; padding: 20px; border-radius: 10px; z-index: 5000;
                max-height: 80vh; overflow-y: auto; box-shadow: 0 0 20px #0ff;
            `;
            document.body.appendChild(popup);

            // Ajout du drag
            let offsetX = 0, offsetY = 0, isDragging = false;

            popup.addEventListener('mousedown', function(e) {
                if (e.target.id === 'dragHandle') {
                    isDragging = true;
                    offsetX = e.clientX - popup.getBoundingClientRect().left;
                    offsetY = e.clientY - popup.getBoundingClientRect().top;
                }
            });

            document.addEventListener('mousemove', function(e) {
                if (isDragging) {
                    popup.style.left = `${e.clientX - offsetX}px`;
                    popup.style.top = `${e.clientY - offsetY}px`;
                    popup.style.transform = 'none';
                }
            });

            document.addEventListener('mouseup', function() {
                isDragging = false;
            });
        }
        popup.innerHTML = content;
        popup.style.display = 'block';
    }

    // ✅ OPTIMISATIONS SPÉCIFIQUES NOUVELLE FENÊTRE” jusqu’à la fin du script où on voit aussi une balise “<script> … </script>” recollée par erreur. Supprime tout ce bloc et colle ceci à la place, une seule fois.
    window.addEventListener('load', function() {
      document.title = `🎮 Brick Blitz Elysium - Niveau ${niveau} | Score: ${score.toLocaleString()}`;

      if (typeof updateHUD === "function") {
        const originalUpdateHUD = updateHUD;
        updateHUD = function() {
          originalUpdateHUD.call(this);
          document.title = `🎮 Brick Blitz Elysium - Niveau ${niveau} | Score: ${score.toLocaleString()}`;
        };
      }

      window.addEventListener('beforeunload', function(e) {
        try {
          if (typeof gameStarted !== "undefined" && typeof gameOver !== "undefined" && gameStarted && !gameOver) {
            e.preventDefault();
            e.returnValue = 'Voulez-vous vraiment quitter le jeu en cours ?';
          }
        } catch (_) {}
      });

      window.focus();
    }); //Fin de fonction window.load




</html>
