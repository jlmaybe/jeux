<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>p ELYSIUM</title>
  <link href="https://fonts.googleapis.com/css?family=Press+Start+2P" rel="stylesheet">
  <style>



  /* âœ… OPTIMISATION POUR NOUVELLE FENÃŠTRE */


  {
      margin: 0 !important;
      padding: 0 !important;
      box-sizing: border-box;
  }

  html, body {
    margin: 5;
    padding: 5;
    background: #000;
    overflow: hidden; /* âœ… DÃ‰SACTIVE COMPLÃˆTEMENT L'ASCENSEUR */
    height: 100vh; /* âœ… HAUTEUR FIXE au lieu de min-height */
  }


  /* âœ… CONTENEUR PRINCIPAL CENTRÃ‰ */
  body {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      height: 100vh; /* âœ… CHANGÃ‰ : hauteur exacte sans dÃ©passement */
      padding: 5; /* âœ… SUPPRIMÃ‰ : plus de padding qui crÃ©e des marges */
      margin: 5; /* âœ… AJOUT : supprime les marges par dÃ©faut */
      max-width: 100vw;
      overflow: hidden; /* âœ… COHÃ‰RENT : pas de scroll */
  }


  /* === AJUSTEMENT DU TITRE === */
  #title {
      font-family: 'Press Start 2P', monospace;
      font-size: 2.5em;
      letter-spacing: 0.2em;
      text-shadow: 0 0 15px #0ff, 0 0 40px #ff0, 0 0 150px #f0f;
      margin-top: 0; /* âœ… CHANGÃ‰ : de -10px Ã  0 */
      padding: 0 0 10px 0; /* âœ… CHANGÃ‰ : supprime le padding du haut, garde un peu en bas */
      font-weight: bold;
      filter: brightness(1.4);
      text-align: center;
      width: 100%;
      position: relative;
      left: 0;
      top: 0;
      transform: none;
      pointer-events: none;
      user-select: none;
      z-index: 20;
      white-space: nowrap;
      overflow: hidden;
  }



  /* === AJUSTEMENT DU HUD === */
  #hud {
      position: relative;
      left: 50%; /* âœ… NOUVEAU : Position au centre */
      top: 0;
      transform: translateX(-50%); /* âœ… NOUVEAU : Correction du centrage exact */
      width: 100%;
      max-width: 1140px;
      margin: 10px 0; /* âœ… CHANGÃ‰ : margin vertical seulement, pas de centrage auto */
      text-align: center;
      font-family: 'Press Start 2P', monospace;
      color: #fff;
      pointer-events: none;
      z-index: 10;
      user-select: none;
      background: linear-gradient(260deg, #0ff 0%, #f0f 50%, #ff0 100%);
      box-shadow: 0 0 20px #0ff, 0 0 40px #f0f;
      border-radius: 12px;
      padding: 8px 0 6px 0;
  }



  /* âœ… CORRECTION : Ajouter #cookies au sÃ©lecteur */
  #score, #vies, #niveau, #mult, #cookies {
    font-family: 'Press Start 2P', monospace;
    font-size:1.1em;
    margin:0 30px;
    display:inline-block;
    text-shadow:0 0 9px #0ff, 0 0 9px #f0f;
    text-align: right;
    vertical-align:top;
    color: #fff;
    letter-spacing: 2px;
    transition: filter 0.2s, font-size 0.15s, color 0.15s;
  }

    #score.flash, #mult.flash {
      font-family: 'Press Start 2P', monospace;
      filter: brightness(1) drop-shadow(0 0 15px #ff0);
      /* âœ… SUPPRIMÃ‰ : font-size:1.3em; pour Ã©viter le redimensionnement */
      color: #ff0;
      /* âœ… NOUVEAU : Effet visuel alternatif sans changement de taille */
      text-shadow:
        0 0 12px #ff0,
        0 0 24px #ff0,
        0 0 36px #fff,
        0 0 48px #fff;
      transform: scale(1.02); /* âœ… LÃ©gÃ¨re mise Ã  l'Ã©chelle qui n'affecte pas le layout */
      transform-origin: center center;
    }


    #bonus-anim {
      font-family: 'Press Start 2P', monospace;
      position:absolute; left:50%; top:50%; font-size:20px;
      pointer-events:none; opacity:0; transform:translate(-50%,-50%) scale(1.2);
      text-shadow:0 0 32px #fff, 0 0 64px #f0f, 0 0 128px #0ff;
      transition:opacity 0.4s, transform 0.4s;
      z-index:100;
    }
    #decrement-timer {

      position: absolute;
      left: 0; right: 0;
      font-family: 'Press Start 2P', monospace;
      font-size: 1em;
      color: #ff4444;
      text-shadow: 0 0 12px #fff, 0 0 24px #f00;
      z-index: 50;
      pointer-events: none;
      user-select: none;
      display: none;
      background: rgba(0,0,0,0.7);
      padding: 4px 10px;
      border-radius: 8px;
      text-align: center;
      top: 0;
    }

    /* === CONTAINER DE COUPLAGE GAMECANVAS + STATSPANEL === */
    .game-canvas-container {
      display: flex;
      align-items: flex-start; /* Alignement parfait en hauteur */
      gap: 15px; /* âœ… EXACTEMENT 15px entre canvas et panel */
      justify-content: center;
      position: relative;
      margin: 20px auto 0; /* Centrage et marge supÃ©rieure */
      width: fit-content; /* S'adapte au contenu */
    }

    /* === GAMECANVAS DANS LE CONTAINER === */
    #gameCanvas {
      display: block;
      margin: 0; /* âœ… SUPPRIMÃ‰ : tous les margins/positions manuels */
      background: #111;
      box-shadow: 0 0 40px #0ff, 0 0 80px #f0f;
      border-radius: 12px;
      /* âœ… SUPPRIMÃ‰ : position, left, top - maintenant gÃ©rÃ© par flex */
      flex-shrink: 0; /* EmpÃªche la compression */
      cursor: none !important;
    }

    /* === STATSPANEL COUPLÃ‰ AU CANVAS === */
    #statsPanel {
      /* âœ… NOUVEAU : Plus de position fixed - maintenant dans le flux */
      position: static !important;

      /* âœ… DIMENSIONS IDENTIQUES AU CANVAS */
      width: 250px !important;
      height: 900px !important; /* âœ… EXACTEMENT comme le canvas */
      max-height: 900px !important;
      min-height: 900px !important;

      /* âœ… STYLES VISUELS CONSERVÃ‰S */
      background: #111;
      box-shadow: 0 0 40px #0ff, 0 0 80px #f0f;
      border-radius: 12px;
      z-index: 5;
      overflow-y: auto;
      overflow-x: hidden;
      box-sizing: border-box !important;

      /* âœ… FLEX : Pas de compression ni d'expansion */
      flex-shrink: 0;
      flex-grow: 0;

      /* âœ… SUPPRIMÃ‰ : left, top, transform - maintenant gÃ©rÃ© par flex */
    }

    #bonusPanel {
      font-family: 'Press Start 2P', monospace;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      /* âœ… DIMENSIONS FIXES DE RÃ‰FÃ‰RENCE (comme le game-main-container) */
      width: 600px;
      height: 800px;

      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 2000;

      font-size: 0.8rem;
      box-sizing: border-box;
      overflow: hidden;

      /* âœ… STYLES VISUELS CONSERVÃ‰S */
      border-radius: 18px;
      box-shadow:
        0 0 40px rgba(0, 255, 255, 0.8),
        0 0 80px rgba(255, 0, 255, 0.6),
        0 0 120px rgba(255, 255, 0, 0.4),
        inset 0 0 30px rgba(0, 255, 255, 0.2);
    }


  /* âœ… ARRIÃˆRE-PLAN AVEC PULSATION VISIBLE */
  #bonusPanel::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    z-index: -1;

    //background: rgba(0, 0, 0, 0.85);
    Background: rgba(0, 0, 0, 0.40);
    border-radius: 18px;

    box-shadow:
      0 0 60px rgba(0, 255, 255, 1),
      0 0 120px rgba(255, 0, 255, 0.8),
      0 0 180px rgba(255, 255, 0, 0.6);

    animation: haloStaticPulse 2s ease-in-out infinite alternate;
  }

  /* âœ… HALO EXTERNE ROTATIF ULTRA-VISIBLE */
  #bonusPanel::after {
    content: '';
    position: absolute;
    top: -20px;
    left: -20px;
    right: -20px;
    bottom: -20px;
    z-index: -2;

    /* âœ… NOUVEAU : Gradient en forme de rayons pour rotation visible */
    background: conic-gradient(
      from 0deg,
      rgba(0, 255, 255, 1) 0%,     /* Cyan intense - rayon 1 */
      transparent 5%,
      rgba(255, 0, 255, 1) 15%,    /* Magenta intense - rayon 2 */
      transparent 20%,
      rgba(255, 255, 0, 1) 30%,    /* Jaune intense - rayon 3 */
      transparent 35%,
      rgba(0, 255, 0, 1) 45%,      /* Vert intense - rayon 4 */
      transparent 50%,
      rgba(255, 165, 0, 1) 60%,    /* Orange intense - rayon 5 */
      transparent 65%,
      rgba(138, 43, 226, 1) 75%,   /* Violet intense - rayon 6 */
      transparent 80%,
      rgba(0, 255, 255, 1) 90%,    /* Retour cyan - rayon 7 */
      transparent 95%,
      rgba(255, 0, 255, 1) 100%    /* Magenta final - rayon 8 */
    );

    border-radius: 35px;

    /* âœ… ANIMATION PLUS RAPIDE ET VISIBLE */
    animation: haloRotate 3s linear infinite;

    /* âœ… BLUR RÃ‰DUIT pour voir la rotation */
    filter: blur(6px);
  }

  /* âœ… ANIMATIONS OPTIMISÃ‰ES POUR LA VISIBILITÃ‰ */
  @keyframes haloRotate {
    0% {
      transform: rotate(0deg) scale(1);
      filter: blur(6px);
    }
    25% {
      transform: rotate(90deg) scale(1.03);
      filter: blur(4px);
    }
    50% {
      transform: rotate(180deg) scale(1);
      filter: blur(6px);
    }
    75% {
      transform: rotate(270deg) scale(1.03);
      filter: blur(4px);
    }
    100% {
      transform: rotate(360deg) scale(1);
      filter: blur(6px);
    }
  }

  @keyframes haloStaticPulse {
    0% {
      opacity: 0.8;
      transform: scale(0.98);
      box-shadow:
        0 0 60px rgba(0, 255, 255, 1),
        0 0 120px rgba(255, 0, 255, 0.8),
        0 0 180px rgba(255, 255, 0, 0.6);
    }
    50% {
      opacity: 1;
      transform: scale(1.02);
      box-shadow:
        0 0 80px rgba(0, 255, 255, 1),
        0 0 160px rgba(255, 0, 255, 1),
        0 0 240px rgba(255, 255, 0, 0.8);
    }
    100% {
      opacity: 0.9;
      transform: scale(1);
      box-shadow:
        0 0 70px rgba(0, 255, 255, 1),
        0 0 140px rgba(255, 0, 255, 0.9),
        0 0 210px rgba(255, 255, 0, 0.7);
    }
  }

  /* âœ… EFFET HOVER RENFORCÃ‰ */
  #bonusPanel:hover::before {
    animation-duration: 1s; /* Pulsation plus rapide au survol */
    background: rgba(0, 0, 0, 0.9);
  }

  #bonusPanel:hover::after {
    animation-duration: 1.5s; /* Rotation plus rapide au survol */
    filter: blur(3px); /* Halo plus net */
    transform: scale(0.70); /* LÃ©gÃ¨rement plus grand */
  }

  #bonusPanel:hover {
    box-shadow:
      0 0 80px rgba(0, 255, 255, 1),
      0 0 160px rgba(255, 0, 255, 0.9),
      0 0 240px rgba(255, 255, 0, 0.8),
      inset 0 0 50px rgba(0, 255, 255, 0.4);
  }



/* === CONTAINER PRINCIPAL RESPONSIVE === */
.game-main-container {
  position: relative;
  width: 1200px;
  height: 1000px;
  margin: 0 auto;
  transform-origin: center top;
  transition: transform 0.3s ease;
  /* âœ… Le scale sera calculÃ© dynamiquement par JavaScript */
}


    .bonus-panel-content {
//      background: rgba(30, 40, 60, 0.99);
      background: rgba(30, 40, 60, 0.75);
      color: #fff;
      border-radius: clamp(12px, 2vw, 18px);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.45);

      /* âœ… NOUVEAU : Padding responsive mais sans crÃ©er de dÃ©bordement */
      padding: clamp(20px, 5vw, 40px) clamp(25px, 6vw, 45px) clamp(15px, 4vw, 35px) clamp(25px, 6vw, 45px);

      font-family: 'Press Start 2P', monospace;
      text-align: left;

      /* âœ… SUPPRIMÃ‰ : overflow-y: auto pour Ã©liminer l'ascenseur interne */
      /* âœ… SUPPRIMÃ‰ : height: 100% qui forÃ§ait le scroll */
      width: 100%;
      max-width: 100%;

      /* âœ… NOUVEAU : Taille de police lÃ©gÃ¨rement plus grande */
      font-size: clamp(0.6em, 1.8vw, 0.85em); /* âœ… AUGMENTÃ‰ pour meilleure lisibilitÃ© */

      /* âœ… NOUVEAU : Espacement des lignes optimisÃ© */
      line-height: clamp(1.4, 2vw, 1.8);
      box-sizing: border-box;

      /* âœ… NOUVEAU : Disposition naturelle sans contrainte de hauteur */
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
    }

    /* Animation de clignotement gÃ©nÃ©rique et rÃ©utilisable */
    .blinking-effect {
      animation: blink-animation 1s step-end infinite;
    }
    @keyframes blink-animation {
      50% {
        opacity: 0;
      }
    }


    /* âœ… NOUVEAU : Ã‰lÃ©ments internes responsive */
    /* âœ… NOUVEAU : Ã‰lÃ©ments internes optimisÃ©s pour la nouvelle taille */
  .bonus-panel-content h2 {
    text-align: center;
    color: #FFD700;
    margin-top: 0;
    margin-bottom: clamp(12px, 4vw, 25px); /* âœ… AUGMENTÃ‰ proportionnellement */

    font-size: clamp(0.9em, 2.4vw, 1.3em); /* âœ… AUGMENTÃ‰ : de 2vw Ã  2.4vw */
    letter-spacing: clamp(1px, 0.4vw, 3px); /* âœ… AUGMENTÃ‰ */
    text-shadow: 1px 2px 0 #222;
  }

  .bonus-panel-content h3 {
    text-align: center;
    color: #FFE000;
    margin-top: 0;
    margin-bottom: clamp(10px, 2.5vw, 20px); /* âœ… AUGMENTÃ‰ */

    font-size: clamp(0.4em, 1.2vw, 0.6em); /* âœ… AUGMENTÃ‰ : de 1vw Ã  1.2vw */
    letter-spacing: clamp(1px, 0.25vw, 2.5px);
    text-shadow: 1px 5px 0 #122;
  }

  .bonus-panel-content ul {
    list-style: none;
    padding: 0;
    margin-bottom: clamp(15px, 4vw, 30px); /* âœ… AUGMENTÃ‰ */
  }

  .bonus-panel-content li {
    margin-bottom: clamp(8px, 2vw, 16px); /* âœ… AUGMENTÃ‰ : de 1.5vw Ã  2vw */
    display: flex;
    align-items: center;
    font-size: clamp(0.55em, 1.6vw, 0.95em); /* âœ… AUGMENTÃ‰ : de 1.3vw Ã  1.6vw */
  }

  .bonus-emoji {
    font-size: clamp(1em, 2.4vw, 1.5em); /* âœ… AUGMENTÃ‰ : de 2vw Ã  2.4vw */
    margin-right: clamp(10px, 2.5vw, 18px); /* âœ… AUGMENTÃ‰ */
    filter: drop-shadow(0 0 6px #0ff);

    /* âœ… NOUVELLE TAILLE minimale */
    min-width: clamp(20px, 3.5vw, 30px); /* âœ… AUGMENTÃ‰ */
    display: inline-block;
    text-align: center;
  }

  #closeBonusPanel {
    display: block;
    margin: clamp(8px, 2.5vw, 15px) auto 0; /* âœ… AUGMENTÃ‰ */
    padding: clamp(10px, 2.5vw, 16px) clamp(25px, 6vw, 45px); /* âœ… AUGMENTÃ‰ */

    background: linear-gradient(90deg, #FFD700 45%, #FF6F00 100%);
    color: #222;
    border: none;
    border-radius: clamp(8px, 2vw, 12px); /* âœ… AUGMENTÃ‰ */

    font-family: 'Press Start 2P', monospace;
    font-size: clamp(0.7em, 1.8vw, 1.2em); /* âœ… AUGMENTÃ‰ : de 1.5vw Ã  1.8vw */
    letter-spacing: clamp(1px, 0.4vw, 2.5px);
    cursor: pointer;

    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
    transition: background 0.2s, transform 0.1s;
  }

  #closeBonusPanel:hover {
    background: linear-gradient(90deg, #FFEC80 45%, #FF9F00 100%);
    transform: scale(clamp(1.03, 1.08, 1.12)); /* âœ… AUGMENTÃ‰ : hover plus marquÃ© */
  }

    /* Panneau de fin */
    #endPanel {
      font-family: 'Press Start 2P', monospace;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);

      /* âœ… DIMENSIONS FIXES DE RÃ‰FÃ‰RENCE (comme les autres panneaux) */
      width: 900px;
      height: 700px;

      display: none; /* CachÃ© par dÃ©faut */
      align-items: center;
      justify-content: center;
      flex-direction: column;
      z-index: 3000;

      /* âœ… STYLES VISUELS CONSERVÃ‰S */
      background: rgba(0,0,0,0.94);
      border-radius: 15px;
      box-shadow: 0 0 50px rgba(0, 255, 255, 0.3);
      border: 2px solid rgba(255, 255, 255, 0.1);
      overflow: hidden;
      box-sizing: border-box;
    }

    /* âœ… SUPPRIME TOUS LES @media DU END PANEL ! */

    #endPanel .score-final {
      color:#FFD700;
      font-size: clamp(1.8em, 3vw, 2.2em); /* âœ… RÃ‰DUIT ET RESPONSIVE */
      text-shadow:0 0 25px #ff0,0 0 50px #f0f; /* âœ… RÃ‰DUIT */
      margin-bottom: clamp(14px, 2.5vw, 18px); /* âœ… RESPONSIVE */
      text-align:center;
    }

    #endPanel .stat {
      color:#fff;
      font-size: clamp(0.9em, 1.5vw, 1em); /* âœ… RÃ‰DUIT ET RESPONSIVE */
      margin-bottom: clamp(12px, 2vw, 14px); /* âœ… RESPONSIVE */
      text-align:center;
      line-height: 1.4; /* âœ… NOUVEAU : Meilleur espacement */
    }

    #endPanel .best-score {
      color:#FFD700;
      font-size: clamp(0.9em, 1.5vw, 1em); /* âœ… RÃ‰DUIT ET RESPONSIVE */
      margin-bottom: clamp(14px, 2.5vw, 16px); /* âœ… RESPONSIVE */
      text-align:center;
    }

    #endPanel button {
      padding: clamp(10px, 2vw, 12px) clamp(30px, 5vw, 35px); /* âœ… RESPONSIVE */
      font-size: clamp(0.9em, 1.4vw, 1em); /* âœ… RÃ‰DUIT ET RESPONSIVE */
      border-radius: clamp(7px, 1.5vw, 9px); /* âœ… RESPONSIVE */
      background:linear-gradient(90deg,#FFD700 45%,#FF6F00 100%);
      border:none;
      color:#222;
      font-family:'Press Start 2P',monospace;
      margin-top: clamp(12px, 2.5vw, 16px); /* âœ… RESPONSIVE */
      cursor:pointer;
      transition: transform 0.1s ease; /* âœ… NOUVEAU : Animation hover */
    }

    #endPanel button:hover {
      background: linear-gradient(90deg, #FFEC80 45%, #FF9F00 100%);
      transform: scale(1.05); /* âœ… EFFET HOVER AJUSTÃ‰ */
    }

    /* âœ… NOUVEAU : Ajustements pour le leaderboard dans endPanel */
    #leaderboardSection {
      max-height: clamp(350px, 60vh, 450px) !important; /* âœ… HAUTEUR RESPONSIVE */
      overflow: hidden !important; /* âœ… COHÃ‰RENT avec les autres panneaux */
      margin-top: clamp(15px, 3vw, 20px); /* âœ… MARGE RESPONSIVE */
    }

    #leaderboardList table {
      font-size: clamp(0.6em, 1.2vw, 0.8em) !important; /* âœ… TAILLE AJUSTÃ‰E */
      line-height: 1.3 !important; /* âœ… ESPACEMENT OPTIMISÃ‰ */
    }

    #leaderboardList td {
      padding: clamp(6px, 1.5vw, 8px) clamp(3px, 1vw, 4px) !important; /* âœ… PADDING RESPONSIVE */
    }

    /* âœ… NOUVEAU : Ajustements pour la saisie du nom */
    #playerNameSection input {
      font-size: clamp(0.9em, 1.4vw, 1em) !important; /* âœ… TAILLE AJUSTÃ‰E */
      padding: clamp(8px, 1.5vw, 10px) !important; /* âœ… PADDING RESPONSIVE */
      width: clamp(160px, 25vw, 200px) !important; /* âœ… LARGEUR RESPONSIVE */
    }

    #playerNameSection button {
      font-size: clamp(0.8em, 1.2vw, 0.9em) !important; /* âœ… BOUTONS PLUS PETITS */
      padding: clamp(8px, 1.5vw, 10px) clamp(15px, 3vw, 20px) !important; /* âœ… PADDING AJUSTÃ‰ */
    }

    #psyCanvas {
      position: absolute;
      top: 0; left: 0; width: 100%; height: 100%;
      z-index: 1;
      pointer-events: none;
    }

    #autopilot-status {
      display: none; /* CachÃ© par dÃ©faut */
      font-family: 'Press Start 2P', monospace;
      font-size: 1.1em; /* MÃªme taille que le score */
      margin-left: 25px; /* Espace par rapport au score */

      color: #0ff; /* Couleur cyan, pour un look "high-tech" */
      text-shadow: 0 0 8px #0ff, 0 0 16px #0ff, 0 0 24px #fff;

      /* Animation de clignotement */
      animation: blink-effect 1s step-end infinite;
    }

    /* DÃ©finition de l'animation de clignotement */
    @keyframes blink-effect {
      50% {
        opacity: 0;
      }
    }

    #psyOverlay {
      position: relative;
      z-index: 2;
      width: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
    }


    .stats-panel-content {
      padding: 20px 15px;
      font-family: 'Press Start 2P', monospace;
      color: #fff;
      font-size: 0.7em;
    }

    .stats-panel-content h3 {
      text-align: center;
      color: #FFD700;
      margin: 0 0 20px 0;
      font-size: 1.1em;
      letter-spacing: 2px;
      text-shadow: 0 0 10px #FFD700;
    }

    .stats-section {
      margin-bottom: 20px;
      border-bottom: 1px solid rgba(0, 255, 255, 0.3);
      padding-bottom: 15px;
    }

    .stats-section:last-child {
      border-bottom: none;
    }

    .stats-section h4 {
      color: #0ff;
      margin: 0 0 10px 0;
      font-size: 0.8em;
      text-shadow: 0 0 8px #0ff;
      letter-spacing: 1px;
    }

    .stats-item {
      display: flex;
      justify-content: space-between;
      margin-bottom: 5px;
      font-size: 0.75em;
    }

    .stats-item-label {
      color: #fff;
      flex: 1;
    }

    .stats-item-value {
      color: #ff0;
      font-weight: bold;
      text-shadow: 0 0 6px #ff0;
    }

    .stats-emoji {
      font-family: 'Apple Color Emoji', 'Segoe UI Emoji', 'Noto Color Emoji', monospace;
      margin-right: 8px;
      filter: drop-shadow(0 0 4px #0ff);
    }

    /* Indicateur de danger pour les skulls */
    .danger-indicator {
      color: #f44 !important;
      animation: dangerBlink 1s infinite;
    }

    @keyframes dangerBlink {
      0%, 50% { opacity: 1; }
      51%, 100% { opacity: 0.3; }
    }

    /* Indicateur positif pour les multiplicateurs */
    .positive-indicator {
      color: #0f0 !important;
      text-shadow: 0 0 8px #0f0 !important;
    }

    .flashy-score {
      color: #ff0; /* Jaune vif par dÃ©faut */
      color: #FFD700;
      text-shadow: 0 0 10px #0ff, 0 0 20px #f0f, 0 0 40px #ff0, 0 0 80px #f0f;
      font-weight: bold;
      animation: flashyColor 0.5s infinite alternate;
    }

    @keyframes flashyColor {
      0%   { color: #ff0; text-shadow: 0 0 10px #0ff, 0 0 40px #f0f; }
      25%  { color: #0ff; text-shadow: 0 0 10px #ff0, 0 0 40px #f0f; }
      50%  { color: #f0f; text-shadow: 0 0 10px #ff0, 0 0 40px #0ff; }
      75%  { color: #ff00cc; text-shadow: 0 0 10px #ff0, 0 0 40px #0ff; }
      100% { color: #ff0; text-shadow: 0 0 10px #0ff, 0 0 40px #f0f; }
    }
    /* Style du bandeau d'alerte pour l'autopilote */
    #autopilot-banner {
      display: none; /* CachÃ© par dÃ©faut */
      position: absolute;
      left: 45%;
      top: 35%;
      transform: translate(-50%, -50%);
      padding: 12px 30px;

      font-family: 'Press Start 2P', monospace;
      font-size: 1em; /* Grande taille pour Ãªtre bien visible */
      color: #FFD700; /* Couleur or, classique */

      background: rgba(20, 10, 40, 0.65); /* Fond plus transparent (0.85 -> 0.65) */
        border: 4px solid rgba(255, 0, 255, 0.5); /* Bordure plus transparente */
        border-radius: 12px;
        box-shadow: 0 0 20px rgba(255, 0, 255, 0.5), /* Ombres externes plus douces */

      text-align: center;
      text-shadow: 0 0 10px #ff0, 0 0 20px #f0f;
      white-space: nowrap; /* EmpÃªche le texte de passer Ã  la ligne */
      z-index: 0; /* S'assure qu'il est au-dessus du jeu */

      user-select: none; /* EmpÃªche la sÃ©lection du texte */
      pointer-events: none; /* Permet aux clics de passer Ã  travers */
    }

    /* Animation de "flash" pour attirer l'attention */
    #autopilot-banner.flash {
      animation: banner-flash 0.3s ease-in-out;
    }

    @keyframes banner-flash {
      0%   { transform: translate(-50%, -50%) scale(1.05); filter: brightness(1.5); }
      100% { transform: translate(-50%, -50%) scale(1); filter: brightness(1); }
    }

  </style>
</head>

<body>
  <!-- âœ… NOUVEAU : Container principal scalable -->
  <div class="game-main-container">
    <div id="title">BRICK BLITZ ELYSIUM</div>

    <div id="hud">
      <span id="vies">VIE(S):3</span>
      <span id="cookies">COOKIE(S):0</span>
      <span id="niveau">NIVEAU(X):1</span>
      <span id="mult">x1</span>
      <span id="score">000000000</span>
      <span id="autopilot-status">AUTOPILOT</span>
    </div>

    <div id="bonus-anim"></div>
    <div id="decrement-timer"></div>

    <!-- âœ… NOUVEAU : Container de couplage Canvas + StatsPanel -->
    <div class="game-canvas-container">
      <canvas id="gameCanvas" width="875" height="900"></canvas>

      <div id="statsPanel">
        <div class="stats-panel-content">
          <h3>STATISTIQUES</h3>

          <div class="stats-section">
            <h4>BRIQUES</h4>
            <div id="bricksStats"></div>
          </div>

          <div class="stats-section">
            <h4>BONUS</h4>
            <div id="bonusesStats"></div>
          </div>

          <div class="stats-section">
            <h4>POWER-UPS</h4>
            <div id="powerupsStats"></div>
          </div>

          <div class="stats-section">
            <h4>Ã‰TAT DU JEU</h4>
            <div id="gameStateStats"></div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- âœ… FIN du container principal scalable -->

  <!-- âœ… Ã‰lÃ©ments qui restent HORS du scaling -->
  <div id="autopilot-banner"></div>

  <!-- Panneau d'explication des bonus -->
  <div id="bonusPanel">
    <div class="bonus-panel-content">
      <h2>BONUS</h2>
      <ul>
        <li><span class="bonus-emoji">ğŸ’ ğŸŒ ğŸ‡ ğŸŒ¸</span> <b>500 pts Petit bonus de score</li>
        <li><span class="bonus-emoji">ğŸ“</span> <b>1000 pts Bonus de score</li>
        <li><span class="bonus-emoji">ğŸ²</span> <b>1500 pts Bonus fleuri</li>
        <li><span class="bonus-emoji">ğŸ›¸ ğŸ‰</span> <b>2000 pts Super bonus</li>
        <li><span class="bonus-emoji">ğŸ‘</span> <b>5000 pts MÃ©ga bonus</li>
        <li><span class="bonus-emoji">ğŸ’</span> <b>8000 pts Bonus de score</li>
        <li><span class="bonus-emoji">ğŸ’Š</span> <b>15000 pts MÃ©ga bonus</li>
        <h2>POWER-UPS</h2>
        <li><span class="bonus-emoji">ğŸ³ï¸</span> <b>Raquette longue</b> <span class="bonus-emoji">ğŸ´â€â˜ ï¸</span> <b>Raquette courte</b> <span class="bonus-emoji">â¤ï¸â€ğŸ”¥</span> <b>Raquette gÃ©ante</b></li>
        <li><span class="bonus-emoji">1ï¸âƒ£ 2ï¸âƒ£ 4ï¸âƒ£ 8ï¸âƒ£ </span> <b>Multiplicateurs de score pendant 30s</li>
        <li><span class="bonus-emoji">ğŸª</span> <b>Cookies  Bouton panique (M)</li>
        <li><span class="bonus-emoji">ğŸŒˆ</span> <b>Vie      Une vie</li>
        <li><span class="bonus-emoji">ğŸ–ï¸</span> <b>Niveau   Niveau suivant</li>
        <li><span class="bonus-emoji">â˜ ï¸</span>  <b>Malus    Score en dÃ©crÃ©mentation pendant 30s</li>
      </ul>
      <h2>ACTIONS</h2>
      <li><span class="bonus-emoji">M</span>Bouton panique  <span class="bonus-emoji">P</span>Pause <span class="bonus-emoji">S</span>Son Marche/ArrÃªt <span class="bonus-emoji">z</span>Variables</li>
      <ul>
      <button id="closeBonusPanel">OK</button>
      <li><span></span></li>
      <h3>(c) jean-luc faisans 2025     v1.01</h3>
    </div>
  </div>

  <!-- Panneau de fin de partie -->
  <div id="endPanel">
    <canvas id="psyCanvas"></canvas>
    <div id="psyOverlay">
      <div class="score-final" id="TITRE"></div>
      <div class="score-final" id="finalScore"></div>

      <!-- âœ… NOUVEAU : Formulaire de saisie du nom -->
      <div id="playerNameSection" style="display: none;">
        <div style="color: #fff; font-size: 1.2em; margin: 20px 0; text-align: center;">
          ğŸ† NOUVEAU RECORD ! ğŸ†
        </div>
        <div style="color: #FFD700; font-size: 1em; margin-bottom: 15px; text-align: center;">
          Entrez votre nom :
        </div>
        <input type="text" id="playerNameInput" maxlength="12"
               style="padding: 10px; font-size: 1.1em; font-family: 'Press Start 2P', monospace;
                      text-align: center; background: #222; color: #fff; border: 2px solid #0ff;
                      border-radius: 5px; margin-bottom: 15px; width: 200px;"
               placeholder="JOUEUR">
        <br>
        <button id="saveScoreBtn" style="padding: 10px 20px; font-size: 1em;
                font-family: 'Press Start 2P', monospace; background: linear-gradient(90deg, #FFD700 45%, #FF6F00 100%);
                color: #222; border: none; border-radius: 5px; cursor: pointer; margin-right: 10px;">
          SAUVER
        </button>
        <button id="skipSaveBtn" style="padding: 10px 20px; font-size: 1em;
                font-family: 'Press Start 2P', monospace; background: #666;
                color: #fff; border: none; border-radius: 5px; cursor: pointer;">
          PASSER
        </button>
      </div>

      <!-- âœ… NOUVEAU : Tableau des meilleurs scores -->
      <div id="leaderboardSection" style="display: none; margin-top: 20px; max-height: 500px; overflow-y: auto;">
        <div style="color: #FFD700; font-size: 1.2em; margin-bottom: 15px; text-align: center;">
          ğŸ¥‡ TOP 10 ğŸ¥‡
        </div>
          <br>
        <div id="leaderboardList"></div>
        <br>  <br>
      </div>

      <div class="stat" id="levelsPassed"></div>
      <div class="stat" id="bricksHit"></div>
      <div class="stat" id="timePlayed"></div>
      <div class="stat" id="powerupDetails"></div>
      <div class="best-score" id="bestScore"></div>
      <button onclick="closeEndPanel()">OK</button>
    </div>
  </div>

</body>


  <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/@emailjs/browser@4/dist/email.min.js"></script>


  <script>

    // === CONSTANTES GLOBALES ===

    const COLORS = ["#0ff", "#f0f", "#ff0", "#0f0", "#fff"];
    const BRICK_GRADIENTS = [
      ["#0ff", "#0cf"],
      ["#f0f", "#c0f"],
      ["#ff0", "#fc0"],
      ["#0f0", "#0c8"],
      ["#fff", "#aaa"]
    ];
    const SPECIAL_ICONS = ["ğŸ³ï¸â€âš§ï¸","ğŸ´â€â˜ ï¸","1ï¸âƒ£","2ï¸âƒ£","4ï¸âƒ£","8ï¸âƒ£","â¤ï¸â€ğŸ”¥"];
    const BONUS_ICONS = [
      {emoji:"ğŸ’", points:500, color:"#f06"},
      {emoji:"ğŸ“", points:1000, color:"#f44"},
      {emoji:"ğŸ›¸", points:2000, color:"#0ff"},
      {emoji:"ğŸ‘", points:5000, color:"#fa8"},
      {emoji:"ğŸŒ¸", points:500, color:"#f9f"},
      {emoji:"ğŸ’", points:8000, color:"#f44"},
      {emoji:"ğŸ‰", points:2000, color:"#0ff"},
      {emoji:"ğŸ’Š", points:15000, color:"#fa8"},
      {emoji:"ğŸ²", points:15000, color:"#f9f"},
      {emoji:"ğŸ‡", points:2000, color:"#94f"},
      {emoji:"ğŸª", points:0, color:"#A67B5B", type:"cookie"},
      {emoji:"ğŸŒˆ", points:0, color:"#A67B5B", type:"vie"},
      {emoji:"ğŸ–", points:0, color:"#A67B5B", type:"niveau"},
      {emoji:"ğŸŒ", points:500, color:"#ff4"},
    ];

    const FONT = "Press Start 2P, monospace";
    const EMOJI_FONT = "'Apple Color Emoji', 'Segoe UI Emoji', 'Noto Color Emoji', 'Press Start 2P', monospace";
    const CANVAS_W = 875, CANVAS_H = 900;

    // === VARIABLES D'Ã‰TAT DU JEU ===

    // Ligne corrigÃ©e
    let vies = 4, niveau = 1, score = 0, displayScore = 0;
    let mult = 1, multTimer = 0, multMax = 40, lastMult = 1;
    let bricks = [], particles = [], powerups = [], bonuses = [], animations = [];
    brickCols = 14;
    let wallOffset = 50;
    let brickW = 61, brickH = 28; brickGap = 2;
    let paddleW = 150, paddleH = 18, paddleY = CANVAS_H-60;
    let paddleX = (CANVAS_W-paddleW)/2, paddleSpeed = 13;

    let ballSpeed0 = 12; // IMPORTANT : avant son utilisation
    let LancementAutoPilote = 5;
    let brickRows = 8; //et autour de la ligne 700
    let isEndGame = false;
    let ball = null, ballSpeed = ballSpeed0, ballR = 13;
    let ballDX = 0, ballDY = 0;
    let leftDown = false, rightDown = false;
    let lastFrame = 0, gameOver = false, pause = false;
    let bonusAnimTimeout = null;
    let paddleHugeTimeout = null;
    let decrementTimer = 0;
    let decrementActive = false;
    let decrementEffect = false;
    let levelsPassed = 0;
    let paddleAcceleration = 0;
    const maxPaddleAcceleration = 15;   // AccÃ©lÃ©ration maximale (ajuste selon le feeling)
    const paddleAccelerationStep = 1.02; // Vitesse d'accÃ©lÃ©ration (ajuste selon le feeling)
    let paddleBaseW = 150; // Taille de base de la raquette
    let decrementStartTime = 0;
    let gameStarted = false;
    let autopilot = false;
    let aimingError = 0;      // AJOUT : MÃ©morise l'erreur de placement du coup prÃ©cÃ©dent.
    let desiredPaddleX = 0;   // AJOUT : Stocke la position cible calculÃ©e par l'IA.
    let AutopilotBanner = false
    let panic = false
    let PanicButon = false
    let cookies = 0;
    let wallOffsetPlus =0;
    let megaspeed=1
    let gameLoopId = null; // Ajouter en haut du fichier
    let longTimeout = null;
    let shortTimeout = null;
    let impactTimeout = null;
    let paddleVelocity = 0;
    let Debug = false;
    let wheelVelocity = 0;
    let skulls = [];
    let shotHistory = [];
    let lastTargetBrick = null;
    let lastPaddleTarget = 0;
    let paddleSizeEffect = null;
    let paddleOriginalSize = paddleBaseW;
    let dernierUtilisateur = null;

    // === VARIABLE DE SENSIBILITÃ‰ SOURIS ===
    let mouseSensitivity = 1.1; // âœ… NOUVEAU : Facteur de dÃ©multiplication (1.8x plus sensible)
    let lastMouseX = null; // âœ… NOUVEAU : Position prÃ©cÃ©dente de la souris pour calcul du delta
    //Fin de variables sensibilitÃ© souris

// === VARIABLES GALAXIE Ã‰VOLUTIVES ===
let galaxyParticles = [];
let galaxyTime = 0;
let galaxyCenter = { x: CANVAS_W/2, y: CANVAS_H/2 };
let galaxyRadius = 300;
let galaxyParticleCount = 150; // Nombre de pixels lumineux
let galaxyColorScheme = 0; // SchÃ©ma de couleur actuel (0-4)
let galaxySpacing = 1.0; // Multiplicateur d'espacement (0.7-1.5)
let galaxyRotationMode = 0; // Mode de rotation (0-2)

let targetVelocity = 0;
let adaptiveCompensation = 0;
let compensationStep = 5;

let isBossLevel = false;
let boss = null;
let bossPhase = 1;
let bossMaxHP = 100;
let bossHP = 100;
let bossInvulnerable = false;
let bossAttackTimer = 0;
let bossMovementTimer = 0;
let bossDefeated = false;
let psyAnimId = null;
let emailSent = false; // Pour Ã©viter les envois multiples
let gameSessionId = null; // ID unique de la session de jeu
let levelComplete = false;

let gyroControls = {
    active: false,
    supported: false,
    permission: false,
    sensitivity: 1.5,
    deadZone: 3
};

let frameCount = 0;
let lastPerformanceCheck = 0;

const EMAILJS_CONFIG = {
    publicKey: "S4SodZJrD9Ftqor5s",
    serviceId: "service_z3kyzle",
    templateId: "template_7x60gk8",
    toEmail: "jlmaybe1024@gmail.com", // âœ… AJOUT : Email de destination
    enabled: true // âœ… AJOUT : PossibilitÃ© de dÃ©sactiver facilement
};

let gyroActive = false;
let gyroSupported = false;
let gyroPermission = false;
let touchStartX = 0;
let touchStartY = 0;
let isTouching = false;
let touchControlZone = null; // 'left', 'right', ou null

// === SYSTÃˆME DE QUALITÃ‰ DYNAMIQUE ===
let renderQuality = "medium"; // "high", "medium", "low"
let performanceFrames = 0;
let performanceStart = 0;

let baseGameSpeed = 12;
let currentGameSpeed = 12;
let levelSpeedBonus = 0;
let brickSpeedBonus = 0;
let speedIncreasePerBrick = 0.001; // âœ… RÃ‰DUIT de 0.02 Ã  0.008 (60% plus lent)
let speedIncreasePerLevel = 0.05;   // âœ… RÃ‰DUIT de 1.2 Ã  0.6 (50% plus lent)
let autopilotSpeedMultiplier = 1.04; // âœ… RÃ‰DUIT de 1.15 Ã  1.08 (seulement 8% plus rapide)

// === VARIABLES DE TRANSITION DE NIVEAU ===
let levelTransition = false;
let levelTransitionTimer = 0;
let levelTransitionMessage = "";
let levelTransitionDelay = 5000; // 4 secondes en millisecondes


let bricksHit = 0;
let powerupsCaptured = {
  "long": 0,
  "short": 0,
  "mult1": 0,
  "mult2": 0,
  "mult4": 0,
  "mult8": 0,
  "huge": 0,
  "skull": 0
};

let bonusesCaptured = {
  "ğŸ’": 0,   // +500 pts
  "ğŸ“": 0,   // +1000 pts
  "ğŸ›¸": 0,   // +2000 pts
  "ğŸ‘": 0,   // +5000 pts
  "ğŸŒ¸": 0,   // +500 pts
  "ğŸ’": 0,   // +8000 pts
  "ğŸ‰": 0,   // +2000 pts
  "ğŸ’Š": 0,   // +15000 pts
  "ğŸ²": 0,   // +15000 pts
  "ğŸ‡": 0,   // +2000 pts
  "ğŸª": 0,   // Cookie(s)
  "ğŸŒˆ": 0,   // Vie(s)
  "ğŸŒ": 0    // +500 pts
};

let startTime = null;
let elapsedTime = 0;


// Variables manquantes pour le systÃ¨me de qualitÃ©
let particleCountMax = 80; // Pour ajuster la qualitÃ©


    // === GESTIONNAIRE CENTRALISÃ‰ DES TIMEOUTS ===
    const timeoutManager = {
        timeouts: new Map(),

        set(key, callback, delay) {
            this.clear(key);
            const id = setTimeout(() => {
                callback();
                this.timeouts.delete(key);
            }, delay);
            this.timeouts.set(key, id);
        },

        clear(key) {
            if (this.timeouts.has(key)) {
                clearTimeout(this.timeouts.get(key));
                this.timeouts.delete(key);
            }
        },

        clearAll() {
            for (let id of this.timeouts.values()) {
                clearTimeout(id);
            }
            this.timeouts.clear();
        }
    };

    const countdownRange = 10; // Le compte Ã  rebours commence 5 briques AVANT l'activation.
    const TimerBonus = 15

    // === NOUVELLES VARIABLES STATISTIQUES ===
    bricksHit = 0;
    powerupsCaptured = {
      "long": 0,
      "short": 0,
      "mult1": 0,
      "mult2": 0,
      "mult4": 0,
      "mult8": 0,
      "huge": 0,
      "skull": 0
    };
    startTime = null;
    elapsedTime = 0;

    // === ACCÃˆS DOM ===

    const canvas = document.getElementById('gameCanvas');
    const elAutopilotBanner = document.getElementById('autopilot-banner');
    const ctx = canvas.getContext('2d');
    const elScore = document.getElementById('score');
    const elVies = document.getElementById('vies');
    const elNiveau = document.getElementById('niveau');
    const elBonusAnim = document.getElementById('bonus-anim');
    const elMult = document.getElementById('mult');
    const elDec = document.getElementById('decrement-timer');
    const elAutopilotStatus = document.getElementById('autopilot-status');
    // === AUDIO : Effets sonores simples arcade ===
    const audioCtx = new(window.AudioContext||window.webkitAudioContext)();

    // === SYSTÃˆME DE SCALE PROPORTIONNEL POUR END PANEL ===
    function calculateEndPanelScale() {
        const panelWidth = 900;   // Largeur de rÃ©fÃ©rence
        const panelHeight = 700;  // Hauteur de rÃ©fÃ©rence

        // Dimensions disponibles dans la fenÃªtre
        const availableWidth = window.innerWidth;
        const availableHeight = window.innerHeight;

        // Calcul des ratios pour chaque dimension
        const scaleX = availableWidth / panelWidth;
        const scaleY = availableHeight / panelHeight;

        // On prend le plus petit ratio pour que TOUT rentre
        // avec une marge de sÃ©curitÃ© de 8% (un peu moins que le bonus panel)
        const optimalScale = Math.min(scaleX, scaleY) * 0.92;

        // Limites de sÃ©curitÃ©
        return Math.max(0.3, Math.min(1.3, optimalScale));
    }

    function applyEndPanelScale() {
        const endPanel = document.querySelector('#endPanel');
        if (endPanel) {
            const scale = calculateEndPanelScale();
            endPanel.style.transform = `translate(-50%, -50%) scale(${scale})`;

            console.log(`ğŸ End Panel scale: ${scale.toFixed(3)} (fenÃªtre: ${window.innerWidth}Ã—${window.innerHeight})`);
        }
    }
    //Fin de fonction applyEndPanelScale

    function adjustRenderQuality() {
        performanceFrames++;

        if (performanceFrames > 120 ) { // Test toutes les 2 secondes
            let avgFrameTime = (performance.now() - performanceStart) / 120;
            let estimatedFPS = 1000 / avgFrameTime;

            // âœ… ADAPTATION AUTOMATIQUE DE LA QUALITÃ‰
            if (estimatedFPS < 25) {
                renderQuality = "low";
                brickCacheRadius = 0; // Coins moins arrondis = plus rapide

              } else if (estimatedFPS < 35) {
                  renderQuality = "medium";
                  brickCacheRadius = 1;

                } else if (estimatedFPS < 40) {
                    renderQuality = "medium";
                    brickCacheRadius = 2;

            } else if (estimatedFPS < 45) {
                renderQuality = "medium";
                brickCacheRadius = 3;
            } else {
                renderQuality = "high";
                brickCacheRadius = 6; // Coins bien arrondis
            }

            // âœ… RECRÃ‰ER LE CACHE avec le nouveau rayon
            brickShapeCache = null;

            console.log(`ğŸ¯ QualitÃ© ajustÃ©e: ${renderQuality} (FPS: ${estimatedFPS.toFixed(1)}, rayon: ${brickCacheRadius})`);

            // Reset du compteur
            performanceFrames = 0;
            performanceStart = performance.now();
        } else if (performanceFrames === 1) {
            performanceStart = performance.now();
        }
    }
    //Fin de fonction adjustRenderQuality

    // === SYSTÃˆME DE SCALE PROPORTIONNEL POUR BONUS PANEL ===
    function calculateBonusPanelScale() {
        const panelWidth = 600;   // Largeur de rÃ©fÃ©rence
        const panelHeight = 800;  // Hauteur de rÃ©fÃ©rence

        // Dimensions disponibles dans la fenÃªtre
        const availableWidth = window.innerWidth;
        const availableHeight = window.innerHeight;

        // Calcul des ratios pour chaque dimension
        const scaleX = availableWidth / panelWidth;
        const scaleY = availableHeight / panelHeight;

        // On prend le plus petit ratio pour que TOUT rentre
        // avec une marge de sÃ©curitÃ© de 10% (plus conservatrice que le jeu)
        const optimalScale = Math.min(scaleX, scaleY) * 0.9;

        // Limites de sÃ©curitÃ©
        return Math.max(0.4, Math.min(1.2, optimalScale));
    }

    function applyBonusPanelScale() {
        const bonusPanel = document.querySelector('#bonusPanel');
        if (bonusPanel) {
            const scale = calculateBonusPanelScale();
            bonusPanel.style.transform = `translate(-50%, -50%) scale(${scale})`;

            console.log(`ğŸ Bonus Panel scale: ${scale.toFixed(3)} (fenÃªtre: ${window.innerWidth}Ã—${window.innerHeight})`);
        }
    }
    //Fin de fonction applyBonusPanelScale



    function clearAllAnimations() {
      // ArrÃªter la boucle principale
      if (gameLoopId) {
        cancelAnimationFrame(gameLoopId);
        gameLoopId = null;
      }

      // ArrÃªter l'animation psychÃ©dÃ©lique
      if (psyAnimId) {
        cancelAnimationFrame(psyAnimId);
        psyAnimId = null;
      }

      console.log("Toutes les animations ont Ã©tÃ© nettoyÃ©es");
    }

    // === INITIALISATION DE LA GALAXIE ===
    // === INITIALISATION DE LA GALAXIE (VERSION AMÃ‰LIORÃ‰E) ===
    function initGalaxy() {
        galaxyParticles = [];

        for (let i = 0; i < galaxyParticleCount; i++) {
            // Distribution en spirale pour un effet galaxie naturel
            let angle = (i / galaxyParticleCount) * Math.PI * 6; // 6 tours de spirale
            let radius = (i / galaxyParticleCount) * galaxyRadius;

            // Position de base
            let baseX = galaxyCenter.x + Math.cos(angle) * radius;
            let baseY = galaxyCenter.y + Math.sin(angle) * radius * 0.6; // Effet d'aplatissement

            galaxyParticles.push({
                // Position initiale
                baseRadius: radius,
                baseAngle: angle,

                // Position actuelle
                x: baseX,
                y: baseY,

                // Vitesse de rotation (plus lent au centre, plus rapide au bord)
                rotationSpeed: 0.001 + (radius / galaxyRadius) * 0.008,

                // âœ… TAILLES RÃ‰DUITES : Plus petites et plus variÃ©es
                size: 0.5 + Math.random() * 1.2, // âœ… RÃ‰DUIT : de 1-3.5 Ã  0.5-1.7
                baseBrightness: 0.3 + Math.random() * 0.7,
                brightness: 0.3 + Math.random() * 0.7,

                // Couleur changeante
                colorPhase: Math.random() * Math.PI * 2,
                colorSpeed: 0.02 + Math.random() * 0.03,

                // Scintillement
                twinklePhase: Math.random() * Math.PI * 2,
                twinkleSpeed: 0.05 + Math.random() * 0.1
            });
        }

        console.log("ğŸŒŒ Galaxie initialisÃ©e avec", galaxyParticleCount, "Ã©toiles plus petites");
    }

    // === CHANGEMENT DE CONFIGURATION GALAXIE PAR TABLEAU ===
    function changeGalaxyConfiguration() {
        console.log("ğŸŒ  Changement de configuration de la galaxie pour nouveau tableau");

        // âœ… 1. VARIATION DU NOMBRE D'Ã‰TOILES
        let minStars = Math.max(80, 120 - niveau * 2); // Moins d'Ã©toiles dans les niveaux avancÃ©s
        let maxStars = Math.min(200, 140 + niveau * 3); // Plus d'Ã©toiles possibles avec progression
        galaxyParticleCount = minStars + Math.floor(Math.random() * (maxStars - minStars));

        // âœ… 2. VARIATION DE L'ESPACEMENT (RAYON)
        let baseRadius = 280;
        let radiusVariation = 60 + niveau * 8; // Plus de variation avec le niveau
        galaxyRadius = baseRadius + (Math.random() - 0.5) * radiusVariation;
        galaxyRadius = Math.max(200, Math.min(450, galaxyRadius)); // Limites de sÃ©curitÃ©

        // âœ… 3. VARIATION DE L'ESPACEMENT ENTRE Ã‰TOILES
        galaxySpacing = 0.8 + Math.random() * 0.6; // Entre 0.8x et 1.4x l'espacement normal

        // âœ… 4. CHANGEMENT DU SCHÃ‰MA DE COULEURS
        galaxyColorScheme = Math.floor(Math.random() * 5);

        // âœ… 5. CHANGEMENT DU MODE DE ROTATION
        galaxyRotationMode = Math.floor(Math.random() * 3);

        // âœ… 6. RÃ‰INITIALISATION AVEC NOUVELLE CONFIG
        initGalaxy();

        // âœ… 7. LOG DES CHANGEMENTS
        console.log(`âœ¨ Nouvelle galaxie: ${galaxyParticleCount} Ã©toiles, rayon ${galaxyRadius.toFixed(0)}, schÃ©ma couleur ${galaxyColorScheme}`);
    }

    // === MISE Ã€ JOUR DE LA GALAXIE ===
    function updateGalaxy(dt) {
        galaxyTime += dt * 0.01; // Temps global pour animations synchronisÃ©es

        galaxyParticles.forEach(particle => {
            // âœ… ROTATION : Chaque particule tourne autour du centre
            particle.baseAngle += particle.rotationSpeed * dt;

            // âœ… POSITION MISE Ã€ JOUR avec effet de spirale dynamique
            let dynamicRadius = particle.baseRadius + Math.sin(galaxyTime + particle.colorPhase) * 10;
            particle.x = galaxyCenter.x + Math.cos(particle.baseAngle) * dynamicRadius;
            particle.y = galaxyCenter.y + Math.sin(particle.baseAngle) * dynamicRadius * 0.6; // Aplatissement galaxie

            // âœ… COULEUR CHANGEANTE (cycle RGB)
            particle.colorPhase += particle.colorSpeed * dt;

            // âœ… SCINTILLEMENT
            particle.twinklePhase += particle.twinkleSpeed * dt;
            particle.brightness = particle.baseBrightness + Math.sin(particle.twinklePhase) * 0.3;
            particle.brightness = Math.max(0.1, Math.min(1, particle.brightness));
        });
    }

    // === RENDU DE LA GALAXIE ===
    // === RENDU DE LA GALAXIE AVEC VARIATIONS ===
    function renderGalaxy(ctx) {
        ctx.save();

        galaxyParticles.forEach(particle => {
            // âœ… CALCUL DE LA COULEUR SELON LE SCHÃ‰MA ACTUEL
            let hue, saturation, lightness;

            switch(galaxyColorScheme) {
                case 0: // SchÃ©ma classique (cyan/magenta/jaune)
                    hue = (particle.colorPhase * 57.3) % 360;
                    if (hue < 60) {
                        hue = 45 + Math.sin(particle.colorPhase) * 15; // Jaune-orange
                    } else if (hue < 180) {
                        hue = 180 + Math.sin(particle.colorPhase * 1.3) * 30; // Cyan
                    } else {
                        hue = 300 + Math.sin(particle.colorPhase * 0.8) * 20; // Magenta
                    }
                    break;

                case 1: // SchÃ©ma "Feu" (rouge/orange/jaune)
                    hue = 15 + Math.sin(particle.colorPhase * 1.5) * 25; // 0-40Â° (rouge-orange-jaune)
                    break;

                case 2: // SchÃ©ma "OcÃ©an" (bleu/cyan/vert)
                    hue = 180 + Math.sin(particle.colorPhase * 1.2) * 60; // 120-240Â° (vert-cyan-bleu)
                    break;

                case 3: // SchÃ©ma "Violet" (violet/rose/bleu)
                    hue = 270 + Math.sin(particle.colorPhase * 0.9) * 45; // 225-315Â° (bleu-violet-rose)
                    break;

                case 4: // SchÃ©ma "Arc-en-ciel" (toutes les couleurs)
                    hue = (particle.colorPhase * 57.3 + galaxyTime * 2) % 360;
                    break;
            }

            saturation = 80 + Math.sin(particle.colorPhase * 0.7) * 15; // 65-95%
            lightness = 45 + particle.brightness * 35; // 45-80%

            let color = `hsl(${hue}, ${saturation}%, ${lightness}%)`;

            // âœ… RENDU DU PIXEL LUMINEUX (taille rÃ©duite)
            ctx.globalAlpha = particle.brightness * 0.8;
            ctx.fillStyle = color;
            ctx.shadowColor = color;
            ctx.shadowBlur = particle.size * 3; // âœ… HALO RÃ‰DUIT : *3 au lieu de *4

            // Particule principale
            ctx.beginPath();
            ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
            ctx.fill();

            // âœ… EFFET D'Ã‰TOILE RÃ‰DUIT pour les plus grosses particules
            if (particle.size > 1.2) { // âœ… SEUIL AJUSTÃ‰ : 1.2 au lieu de 2
                ctx.globalAlpha = particle.brightness * 0.4;
                ctx.strokeStyle = color;
                ctx.lineWidth = 0.4; // âœ… TRAIT PLUS FIN
                ctx.shadowBlur = particle.size * 1.5; // âœ… HALO RÃ‰DUIT

                // Traits d'Ã©toile plus petits
                let starSize = particle.size * 1.5; // âœ… RÃ‰DUIT : *1.5 au lieu de *2
                ctx.beginPath();
                ctx.moveTo(particle.x - starSize, particle.y);
                ctx.lineTo(particle.x + starSize, particle.y);
                ctx.moveTo(particle.x, particle.y - starSize);
                ctx.lineTo(particle.x, particle.y + starSize);
                ctx.stroke();
            }
        });

        ctx.shadowBlur = 0; // Reset du blur
        ctx.restore();
    }

    function closeEndPanel() {
      console.log("Fermeture du panneau de fin");

      // âœ… NOUVEAU : Reset des sections de score
      document.getElementById('playerNameSection').style.display = 'none';
      document.getElementById('leaderboardSection').style.display = 'none';
      document.getElementById('playerNameInput').value = '';

      document.getElementById('endPanel').style.display = "none";
      document.getElementById('statsPanel').style.display = 'block'; // âœ… AJOUT

      stopPsychedelicBg();

      // âœ… SÃ‰QUENCE SIMPLIFIÃ‰E
      resetGame(); // Ceci va mettre gameStarted = true et pause = false

      console.log("RedÃ©marrage du jeu - Ã‰tats:", {
        gameStarted: gameStarted,
        pause: pause,
        gameOver: gameOver
      });
    }



    function updateStatsPanel() {
      // âœ… VÃ‰RIFICATIONS ESSENTIELLES SEULEMENT
      const bricksStatsEl = document.getElementById('bricksStats');
      const bonusesStatsEl = document.getElementById('bonusesStats');
      const powerupsStatsEl = document.getElementById('powerupsStats');
      const gameStateStatsEl = document.getElementById('gameStateStats');

      // Si les Ã©lÃ©ments n'existent pas, on sort sans faire de bruit
      if (!bricksStatsEl || !bonusesStatsEl || !powerupsStatsEl ||
          !gameStateStatsEl) {
        return;
      }

      // âœ… INITIALISATION SIMPLE DES VARIABLES
      const safeBricks = Array.isArray(bricks) ? bricks : [];
      const safePowerups = Array.isArray(powerups) ? powerups : [];
      const safeSkulls = Array.isArray(skulls) ? skulls : [];
      const safeParticles = Array.isArray(particles) ? particles : [];
      const safeAnimations = Array.isArray(animations) ? animations : [];

      // === STATISTIQUES DES BRIQUES (inchangÃ©) ===
      const aliveBricks = safeBricks.filter(b => b && b.alive);
      const specialBricks = aliveBricks.filter(b => b && b.special);

      bricksStatsEl.innerHTML = `
        <div class="stats-item">
          <span class="stats-item-label">ğŸ§± Restantes:</span>
          <span class="stats-item-value">${aliveBricks.length}/${safeBricks.length}</span>
        </div>
        <div class="stats-item">
          <span class="stats-item-label">âœ¨ SpÃ©ciales:</span>
          <span class="stats-item-value">${specialBricks.length}</span>
        </div>
        <div class="stats-item">
          <span class="stats-item-label">ğŸ’¥ CassÃ©es:</span>
          <span class="stats-item-value">${bricksHit || 0}</span>
        </div>
      `;

      // === STATISTIQUES DES BONUS COLLECTÃ‰S (NOUVEAU) ===
      let bonusesHtml = '';
      let totalBonuses = 0;
      let totalBonusPoints = 0;

      // âœ… CALCUL DES TOTAUX
      for (let emoji in bonusesCaptured) {
        totalBonuses += bonusesCaptured[emoji];

        // Calcul des points selon l'emoji
        let points = 0;
        switch(emoji) {
          case "ğŸ’": case "ğŸŒ¸": case "ğŸŒ": points = 500; break;
          case "ğŸ“": points = 1000; break;
          case "ğŸ›¸": case "ğŸ‰": case "ğŸ‡": points = 2000; break;
          case "ğŸ‘": points = 5000; break;
          case "ğŸ’": points = 8000; break;
          case "ğŸ’Š": case "ğŸ²": points = 15000; break;
          case "ğŸª": points = 0; break; // Cookies ne donnent pas de points
          case "ğŸŒˆ": points = 0; break; // Vie ne donnent pas de points
        }
        totalBonusPoints += bonusesCaptured[emoji] * points;

        // Affichage si collectÃ©
        if (bonusesCaptured[emoji] > 0) {
          bonusesHtml += `
            <div class="stats-item">
              <span class="stats-item-label"><span class="stats-emoji">${emoji}</span>x${bonusesCaptured[emoji]}</span>
              <span class="stats-item-value">${points > 0 ? points + 'pts' : 'cookie'}</span>
            </div>
          `;
        }
      }

      // En-tÃªte avec totaux
      let bonusesHeader = `
        <div class="stats-item">
          <span class="stats-item-label">ğŸ“Š Total:</span>
          <span class="stats-item-value positive-indicator">${totalBonuses}</span>
        </div>
        <div class="stats-item">
          <span class="stats-item-label">ğŸ’° Points:</span>
          <span class="stats-item-value positive-indicator">${totalBonusPoints.toLocaleString()}</span>
        </div>
      `;

      if (bonusesHtml === '') {
        bonusesHtml = '<div class="stats-item"><span class="stats-item-label">Aucun bonus collectÃ©</span></div>';
      }

      bonusesStatsEl.innerHTML = bonusesHeader + bonusesHtml;

      // === STATISTIQUES DES POWER-UPS COLLECTÃ‰S (NOUVEAU) ===
      let powerupsHtml = '';
      let totalPowerups = 0;

      // âœ… CALCUL DES TOTAUX POWER-UPS
      const powerupNames = {
        "long": "ğŸ³ï¸ Raquette longue",
        "short": "ğŸ´â€â˜ ï¸ Raquette courte",
        "mult1": "1ï¸âƒ£ Multiplicateur x2",
        "mult2": "2ï¸âƒ£ Multiplicateur x3",
        "mult4": "4ï¸âƒ£ Multiplicateur x4",
        "mult8": "8ï¸âƒ£ Multiplicateur x8",
        "huge": "â¤ï¸â€ğŸ”¥ Raquette gÃ©ante",
        "skull": "â˜ ï¸ Malus"
      };

      for (let type in powerupsCaptured) {
        totalPowerups += powerupsCaptured[type];

        if (powerupsCaptured[type] > 0) {
          let name = powerupNames[type] || type;
          let colorClass = type === "skull" ? "danger-indicator" : "";

          powerupsHtml += `
            <div class="stats-item ${colorClass}">
              <span class="stats-item-label">${name}</span>
              <span class="stats-item-value">x${powerupsCaptured[type]}</span>
            </div>
          `;
        }
      }

      // En-tÃªte avec total
      let powerupsHeader = `
        <div class="stats-item">
          <span class="stats-item-label">ğŸ“Š Total:</span>
          <span class="stats-item-value positive-indicator">${totalPowerups}</span>
        </div>
      `;

      if (powerupsHtml === '') {
        powerupsHtml = '<div class="stats-item"><span class="stats-item-label">Aucun power-up collectÃ©</span></div>';
      }

      powerupsStatsEl.innerHTML = powerupsHeader + powerupsHtml;

      // === STATISTIQUES DES DANGERS ACTIFS (COURANTS) ===
      let dangersHtml = '';
      if (safeSkulls.length === 0) {
        dangersHtml = '<div class="stats-item"><span class="stats-item-label">Aucun danger</span></div>';
      } else {
        safeSkulls.forEach((skull) => {
          if (skull) {
            const icon = skull.icon || 'â˜ ï¸';
            const yPos = skull.y !== undefined ? Math.floor(skull.y) : '?';

            dangersHtml += `
              <div class="stats-item danger-indicator">
                <span class="stats-item-label"><span class="stats-emoji">${icon}</span>SKULL</span>
                <span class="stats-item-value">Y:${yPos}</span>
              </div>
            `;
          }
        });
      }

//      dangersStatsEl.innerHTML = dangersHtml;

      // === Ã‰TAT DU JEU ===
      const autopilotStatus = autopilot || false;
      const ballSpeedValue = Math.floor(ballSpeed || 0);
      const multValue = mult || 1;

      let gameStateHtml = `
        <div class="stats-item">
          <span class="stats-item-label">ğŸ¯ Autopilote:</span>
          <span class="stats-item-value ${autopilotStatus ? 'positive-indicator' : ''}">${autopilotStatus ? 'OUI' : 'NON'}</span>
        </div>
        <div class="stats-item">
          <span class="stats-item-label">âš¡ Vitesse balle:</span>
          <span class="stats-item-value">${ballSpeedValue}</span>
        </div>
        <div class="stats-item">
          <span class="stats-item-label">ğŸš€ Multiplicateur:</span>
          <span class="stats-item-value ${multValue > 1 ? 'positive-indicator' : ''}">x${multValue}</span>
        </div>
      `;

      // âœ… AJOUTS CONDITIONNELS SIMPLES
      if (mult > 1 && multTimer > 0) {
        gameStateHtml += `
          <div class="stats-item">
            <span class="stats-item-label">â±ï¸ Timer mult:</span>
            <span class="stats-item-value positive-indicator">${Math.ceil(multTimer)}s</span>
          </div>
        `;
      }

      if (decrementActive && decrementTimer && decrementStartTime) {
        const timeLeft = Math.max(0, decrementTimer - (performance.now() - decrementStartTime) / 1000);
        gameStateHtml += `
          <div class="stats-item">
            <span class="stats-item-label">â˜ ï¸ Malus:</span>
            <span class="stats-item-value danger-indicator">${Math.ceil(timeLeft)}s</span>
          </div>
        `;
      }

      if (cookies && cookies > 0) {
        gameStateHtml += `
          <div class="stats-item">
            <span class="stats-item-label">ğŸª Cookies:</span>
            <span class="stats-item-value positive-indicator">${cookies}</span>
          </div>
        `;
      }

      // Info boss si actif
      if (isBossLevel && boss && boss.alive && bossHP !== undefined && bossMaxHP !== undefined) {
        gameStateHtml += `
          <div class="stats-item">
            <span class="stats-item-label">â˜ ï¸ Boss HP:</span>
            <span class="stats-item-value danger-indicator">${bossHP}/${bossMaxHP}</span>
          </div>
        `;
      }

      gameStateStatsEl.innerHTML = gameStateHtml;
    }

    // === SYSTÃˆME DE SCALE PROPORTIONNEL UNIVERSEL ===
    function calculateOptimalScale() {
        const containerWidth = 1200;
        const containerHeight = 1000;

        // Dimensions disponibles dans la fenÃªtre
        const availableWidth = window.innerWidth;
        const availableHeight = window.innerHeight;

        // Calcul des ratios pour chaque dimension
        const scaleX = availableWidth / containerWidth;
        const scaleY = availableHeight / containerHeight;

        // On prend le plus petit ratio pour que TOUT rentre
        // avec une marge de sÃ©curitÃ© de 5%
        const optimalScale = Math.min(scaleX, scaleY) * 0.95;

        // Limites de sÃ©curitÃ© (Ã©viter trop petit ou trop grand)
        return Math.max(0.3, Math.min(1.4, optimalScale));
    }

    function applyResponsiveScale() {
        const gameContainer = document.querySelector('.game-main-container');
        if (gameContainer) {
            const scale = calculateOptimalScale();
            gameContainer.style.transform = `scale(${scale})`;
            applyBonusPanelScale();
            applyEndPanelScale();
            // Debug optionnel
            console.log(`ğŸ“ Scale appliquÃ©: ${scale.toFixed(3)} (fenÃªtre: ${window.innerWidth}Ã—${window.innerHeight})`);
        }
    }


    // âœ… FONCTION D'ENVOI D'EMAIL AVEC IP PUBLIQUE
    async function sendGameStartEmail() {

        // Ã‰viter les envois multiples
        if (emailSent) return;

        // VÃ©rifications de base
        if (typeof emailjs === 'undefined') {
            console.warn('âš ï¸ EmailJS non disponible');
            return;
        }

        if (!EMAILJS_CONFIG.publicKey || !EMAILJS_CONFIG.serviceId || !EMAILJS_CONFIG.templateId) {
            console.warn('âš ï¸ Configuration EmailJS incomplÃ¨te');
            return;
        }

        try {
            // GÃ©nÃ©rer un ID unique pour cette session de jeu
            gameSessionId = 'game_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);

            console.log('ğŸ” RÃ©cupÃ©ration de l\'IP publique...');

            // âœ… NOUVEAU : RÃ©cupÃ©ration de l'IP publique (avec timeout)
            let publicIP = 'RÃ©cupÃ©ration en cours...';
            try {
                // Lancer la rÃ©cupÃ©ration avec un timeout de 5 secondes max
                const ipPromise = getPublicIP();
                const timeoutPromise = new Promise((_, reject) =>
                    setTimeout(() => reject(new Error('Timeout IP')), 5000)
                );

                publicIP = await Promise.race([ipPromise, timeoutPromise]);
            } catch (error) {
                console.warn('âŒ Timeout ou erreur IP:', error.message);
                publicIP = 'Non disponible (timeout)';
            }

            console.log('âœ… EmailJS disponible, tentative d\'envoi...');

            // Initialisation EmailJS
            emailjs.init({
                publicKey: EMAILJS_CONFIG.publicKey,
                blockHeadless: true,
                limitRate: {
                    id: 'app_rate_limit',
                    throttle: 10000,
                }
            });

            try {
              dernierUtilisateur = getDernierNom();
              } catch (error) {
              console.warn('Erreur lors de la rÃ©cupÃ©ration du dernier nom:', error);
            }

            // âœ… PARAMÃˆTRES Ã‰TENDUS AVEC IP PUBLIQUE
            const templateParams = {
                to_email: EMAILJS_CONFIG.toEmail || "jlmaybe1024@gmail.com",
                from_name: "Brick Blitz Elysium",
                player_name: "BlitzBrickV1",
                game_session: gameSessionId,
                start_time: new Date().toLocaleString('fr-FR'),
                user_agent: navigator.userAgent.substring(0, 100),
                screen_resolution: window.screen.width + 'x' + window.screen.height,
                game_version: "Brick Blitz Elysium v1.0",
                public_ip: publicIP, // âœ… NOUVEAU : IP publique

                // âœ… CORRECTION : Utilisation correcte du dernier nom
                dernier_nom: dernierUtilisateur ? dernierUtilisateur.name : "Aucun",
                dernier_score: dernierUtilisateur ? dernierUtilisateur.score : 0,
                dernier_date: dernierUtilisateur ? dernierUtilisateur.date : "N/A",
                dernier_niveau: dernierUtilisateur ? dernierUtilisateur.level : 0,

                url: window.location.href,

                // âœ… MESSAGE ENRICHI AVEC L'IP PUBLIQUE
                message: `ğŸ® Nouvelle session de jeu dÃ©marrÃ©e !

    ğŸ“Š DÃ©tails techniques :
    â€¢ Joueur : BlitzBrickV1
    â€¢ Session : ${gameSessionId}
    â€¢ Heure : ${new Date().toLocaleString('fr-FR')}
    â€¢ IP publique : ${publicIP}
    â€¢ Navigateur : ${navigator.userAgent.substring(0, 50)}...
    â€¢ RÃ©solution : ${window.screen.width}x${window.screen.height}
    â€¢ URL : ${window.location.href}

    ğŸš€ Bon jeu !`
            };

            console.log('ğŸ“§ Envoi avec IP publique :', publicIP);

            // Envoi de l'email
            emailjs.send(EMAILJS_CONFIG.serviceId, EMAILJS_CONFIG.templateId, templateParams)
                .then(function(response) {
                    console.log('âœ… Email envoyÃ© avec succÃ¨s (IP incluse):', response.status);
                    emailSent = true;
                })
                .catch(function(error) {
                    console.error('âŒ Erreur dÃ©taillÃ©e envoi email:', error);

                    // Diagnostics spÃ©cifiques
                    if (error.status === 422) {
                        console.error('ğŸ’¡ SOLUTION : VÃ©rifiez le template EmailJS et ajoutez {{public_ip}}');
                    } else if (error.status === 400) {
                        console.error('ğŸ’¡ SOLUTION : VÃ©rifiez les nouveaux paramÃ¨tres du template');
                    } else {
                        console.error('ğŸ’¡ SOLUTION : VÃ©rifiez la connexion et rÃ©essayez');
                    }
                });

        } catch (error) {
            console.error('âŒ Erreur critique dans sendGameStartEmail:', error);
            console.warn('ğŸ’¡ Email dÃ©sactivÃ© pour cette session');
        }
    }

    // === CACHE DE FORMES ARRONDIES POUR PERFORMANCE ===
    let brickShapeCache = null;
    let brickCacheRadius = 6;

    function createBrickShapeCache() {
        // CrÃ©e un Path2D rÃ©utilisable pour toutes les briques
        brickShapeCache = new Path2D();

        const x = 0, y = 0;
        const w = brickW, h = brickH;
        const r = brickCacheRadius;

        // Construction du chemin une seule fois
        brickShapeCache.moveTo(x + r, y);
        brickShapeCache.lineTo(x + w - r, y);
        brickShapeCache.arcTo(x + w, y, x + w, y + h, r);
        brickShapeCache.arcTo(x + w, y + h, x, y + h, r);
        brickShapeCache.arcTo(x, y + h, x, y, r);
        brickShapeCache.arcTo(x, y, x + w, y, r);
        brickShapeCache.closePath();
    }

    function drawRoundedBrick(ctx, x, y, fillStyle, strokeStyle = null) {
        // Performance : cache crÃ©Ã© seulement si nÃ©cessaire
        if (!brickShapeCache) {
            createBrickShapeCache();
        }

        ctx.save();
        ctx.translate(x, y);

        // Remplissage
        ctx.fillStyle = fillStyle;
        ctx.fill(brickShapeCache);

        // Bordure optionnelle
        if (strokeStyle) {
            ctx.strokeStyle = strokeStyle;
            ctx.lineWidth = 1;
            ctx.stroke(brickShapeCache);
        }

        ctx.restore();
    }
    //Fin de fonction drawRoundedBrick


    // === FONCTION DE CALCUL DU FACTEUR DE SCALE ACTUEL ===
    function getCurrentScaleFactor() {
        // RÃ©cupÃ¨re le container principal
        const gameContainer = document.querySelector('.game-main-container');
        if (!gameContainer) return 1;

        // RÃ©cupÃ¨re le style computed pour obtenir la transform actuelle
        const computedStyle = window.getComputedStyle(gameContainer);
        const transform = computedStyle.transform;

        // Extrait le facteur de scale de la matrice de transformation
        if (transform && transform !== 'none') {
            const matrixMatch = transform.match(/matrix\(([^)]+)\)/);
            if (matrixMatch) {
                const matrixValues = matrixMatch[1].split(',');
                // Le premier Ã©lÃ©ment de la matrice est le facteur de scale X
                return parseFloat(matrixValues[0]) || 1;
            }
        }

        // Fallback : calcul basÃ© sur la largeur de la fenÃªtre
        const windowWidth = window.innerWidth;
        if (windowWidth <= 650) return 0.45;
        if (windowWidth <= 800) return 0.55;
        if (windowWidth <= 1000) return 0.65;
        if (windowWidth <= 1200) return 0.75;
        if (windowWidth <= 1400) return 0.85;

        return 1; // Taille normale
    }

    // === FONCTION DE CONVERSION DES COORDONNÃ‰ES ===
    function getScaledCoordinates(clientX, clientY) {
        const rect = canvas.getBoundingClientRect();
        const scaleFactor = getCurrentScaleFactor();

        // Position de la souris relative au canvas
        let x = (clientX - rect.left) / scaleFactor;
        let y = (clientY - rect.top) / scaleFactor;

        return { x, y };
    }

    // === FONCTION DE CALCUL DES LIMITES EFFECTIVES ===
    function getEffectiveCanvasLimits() {
        const scaleFactor = getCurrentScaleFactor();
        return {
            width: CANVAS_W, // La largeur logique reste la mÃªme
            height: CANVAS_H, // La hauteur logique reste la mÃªme
            scaleFactor: scaleFactor
        };
    }
    //Fin de fonction getEffectiveCanvasLimits

    // âœ… NOUVEAU SYSTÃˆME DE SCORES MULTIPLES
    function getBestScore() {
      return parseInt(localStorage.getItem("akranoid_best_score") || "0");
    }
    function setBestScore(val) {
      localStorage.setItem("akranoid_best_score", val);
    }

    function getLeaderboard() {
        try {
            let data = localStorage.getItem("arkanoid_leaderboard");
            return data ? JSON.parse(data) : [];
        } catch (e) {
            console.warn("Erreur lecture leaderboard:", e);
            return [];
        }
    }

    function saveLeaderboard(leaderboard) {
    try {
        localStorage.setItem("arkanoid_leaderboard", JSON.stringify(leaderboard));
        return true;
    } catch (e) {
        console.error("Erreur sauvegarde leaderboard:", e);
        return false;
    }
}

function addScoreToLeaderboard(playerName, score) {
    let leaderboard = getLeaderboard();

    // Ajouter le nouveau score
    leaderboard.push({
        name: playerName.substring(0, 12).toUpperCase(), // Limite Ã  12 caractÃ¨res
        score: score,
        date: new Date().toLocaleDateString(),
        level: niveau,
        timestamp: Date.now()
    });

    // Trier par score dÃ©croissant
    leaderboard.sort((a, b) => b.score - a.score);

    // Garder seulement les 10 meilleurs
    leaderboard = leaderboard.slice(0, 10);

    saveLeaderboard(leaderboard);
    return leaderboard;
}

function getDernierNom() {
    try {
        let leaderboard = JSON.parse(localStorage.getItem("arkanoid_leaderboard") || '[]');

        if (leaderboard.length === 0) {
            console.log("Aucun score enregistrÃ©");
            return null;
        }

        // Trier par timestamp pour avoir le plus rÃ©cent
        let sorted = leaderboard.sort((a, b) => b.timestamp - a.timestamp);
        let dernier = sorted[0];

        console.log("Dernier nom donnÃ©:", dernier.name);
        console.log("Score:", dernier.score);
        console.log("Date:", dernier.date);
        console.log("Niveau atteint:", dernier.level);

        return dernier;
    } catch (error) {
        console.error("Erreur:", error);
        return null;
    }
}



function isNewRecord(score) {
    let leaderboard = getLeaderboard();
    // C'est un record si le classement a moins de 10 entrÃ©es OU si le score est meilleur que le 10Ã¨me
    return leaderboard.length < 10 || score > (leaderboard[9]?.score || 0);
}

function getBestScore() {
    let leaderboard = getLeaderboard();
    return leaderboard.length > 0 ? leaderboard[0].score : 0;
}

// âœ… FONCTION D'AFFICHAGE DU CLASSEMENT
function displayLeaderboard() {
    let leaderboard = getLeaderboard();
    let leaderboardList = document.getElementById('leaderboardList');

    if (!leaderboardList) return;

    if (leaderboard.length === 0) {
        leaderboardList.innerHTML = '<div style="color: #888; text-align: center;">Aucun score enregistrÃ©</div>';
        return;
    }

    let html = '<table style="width: 100%; font-family: \'Press Start 2P\', monospace; font-size: 0.8em;">';

    leaderboard.forEach((entry, index) => {
        let rankColor = index === 0 ? '#FFD700' : index === 1 ? '#C0C0C0' : index === 2 ? '#CD7F32' : '#fff';
        let rankIcon = index === 0 ? 'ğŸ¥‡' : index === 1 ? 'ğŸ¥ˆ' : index === 2 ? 'ğŸ¥‰' : `${index + 1}.`;

        html += `
        <tr style="border-bottom: 1px solid #333;">
            <td style="padding: 8px 4px; color: ${rankColor}; width: 15%;">${rankIcon}</td>
            <td style="padding: 8px 4px; color: #fff; width: 40%;">${entry.name}</td>
            <td style="padding: 8px 4px; color: ${rankColor}; width: 30%; text-align: right;">${entry.score.toLocaleString()}</td>
            <td style="padding: 8px 4px; color: #888; width: 15%; text-align: center; font-size: 0.7em;">${entry.date}</td>
        </tr>`;
    });

    html += '</table>';
    leaderboardList.innerHTML = html;
}

    function closeEndPanel2() {
        console.log("Fermeture du panneau de fin"); // DÃ©bogage
        document.getElementById('endPanel').style.display = "none";
        clearAllAnimations();
        stopPsychedelicBg();

        // RÃ©initialiser avant de relancer
        // resetGame();
        gameStarted = true; // Changez Ã  true si nÃ©cessaire pour activer la boucle
        pause = false;
        resetGame();
        // console.log("Ã‰tats rÃ©initialisÃ©s - gameStarted:", gameStarted);
        // Relancer la boucle
        if (gameLoopId) cancelAnimationFrame(gameLoopId); // ArrÃªter toute boucle prÃ©cÃ©dente
        gameLoopId = requestAnimationFrame(gameLoop);
        // console.log("Boucle relancÃ©e");
    }

    function gameLoop(ts) {


      if (!lastFrame) lastFrame = ts;
      let elapsed_ms = ts - lastFrame;
      let dt = Math.max(0.4, Math.min(2.0, elapsed_ms / 16.7));

      if (!gameStarted) {
          gameLoopId = requestAnimationFrame(gameLoop);
          return;
      }

      // âœ… NOUVEAU : Ajustement dynamique de la qualitÃ©
      adjustRenderQuality();

      // âœ… CALIBRATION SIMPLE ET EFFICACE
          frameCount++;
          if (frameCount === 60) { // Test aprÃ¨s 60 frames seulement
              let avgFrameTime = (performance.now() - lastPerformanceCheck) / 60;
              let estimatedFPS = 1000 / avgFrameTime;

              // Ajustement automatique simple
              if (estimatedFPS < 30) ballSpeed0 = 7;
              else if (estimatedFPS < 45) ballSpeed0 = 8;
              else if (estimatedFPS < 55) ballSpeed0 = 10;
              else ballSpeed0 = 15;

              ballSpeed = ballSpeed0; // Applique immÃ©diatement
              console.log(`FPS: ${estimatedFPS.toFixed(1)}, vitesse ajustÃ©e: ${ballSpeed0}`);
          } else if (frameCount === 1) {
              lastPerformanceCheck = performance.now();
          }

      if (Debug === true) {
        showDebugPopup();
      }

// -------------------------------------------------------------
// IA Perplexity â€“ mod jeu â€“ 18-07-2025
// Applique le coefficient megaspeed quand lâ€™autopilote est actif
// -------------------------------------------------------------
// âœ… SYSTÃˆME SIMPLIFIÃ‰ - La vitesse est gÃ©rÃ©e directement dans la balle
// Plus besoin de timescale, la vitesse est dans ballDX/ballDY


      lastFrame = ts;

      if (!pause && !gameOver) {
        update(dt, elapsed_ms);
      }

      render();

      // Stocker l'ID pour pouvoir l'annuler
      gameLoopId = requestAnimationFrame(gameLoop);
    }

    function clearAllTimersEndLevel() {
        console.log("ğŸ§¹ Nettoyage complet des timers de fin de niveau");

        // === NETTOYAGE DES TIMEOUTS CLASSIQUES ===
        if (bonusAnimTimeout) {
            clearTimeout(bonusAnimTimeout);
            bonusAnimTimeout = null;
        }
        if (paddleHugeTimeout) {
            clearTimeout(paddleHugeTimeout);
            paddleHugeTimeout = null;
        }
        if (longTimeout) {
            clearTimeout(longTimeout);
            longTimeout = null;
        }
        if (shortTimeout) {
            clearTimeout(shortTimeout);
            shortTimeout = null;
        }
        if (impactTimeout) {
            clearTimeout(impactTimeout);
            impactTimeout = null;
        }

        // === NETTOYAGE COMPLET DU TIMEOUT MANAGER ===
        timeoutManager.clearAll(); // âœ… NOUVEAU : Nettoie TOUS les timeouts gÃ©rÃ©s

        // === REMISE Ã€ ZÃ‰RO DES TIMERS ===
        // multTimer = 0;
        decrementTimer = 0;
        paddleTimer = 0;
        bossAttackTimer = 0;
        bossMovementTimer = 0;

        // === RESET DES FLAGS DE TIMER ===
        paddleTimerActive = false;
        decrementActive = false;
        decrementEffect = false;
        bossInvulnerable = false;

        // === RESET DES EFFETS VISUELS ===
        elDec.style.display = "none";
        updateMultDisplay(1); // Reset multiplicateur visuel
        elBonusAnim.style.opacity = 0;
        elBonusAnim.style.transform = "translate(-50%,-50%) scale(1.2)";

        // === RESET DES TAILLES DE RAQUETTE ===
        paddleW = paddleBaseW; // âœ… IMPORTANT : Retour Ã  la taille de base
        paddleSizeEffect = null;

        // === RESET DES MULTIPLICATEURS ===
        // mult = 1;

        // === RESET DES VARIABLES DE TRANSITION ===
        levelTransition = false;
        levelTransitionTimer = 0;
        levelTransitionMessage = "";

        console.log("âœ… Variables de transition remises Ã  zÃ©ro");
    }



    function playSound(type) {
      let o = audioCtx.createOscillator();
      let g = audioCtx.createGain();
      o.type = (type==="bonus")?"triangle":"square";
      let now = audioCtx.currentTime;

      if(type === "mort") {
        o.frequency.setValueAtTime(180, now);
        o.frequency.linearRampToValueAtTime(90, now + 0.18);
        g.gain.setValueAtTime(0.22, now);
        g.gain.linearRampToValueAtTime(0, now + 0.21);
        o.connect(g).connect(audioCtx.destination);
        o.start(now); o.stop(now + 0.22);
        return;
      }


      if(type === "startGame") {
        // Petit jingle montant, trÃ¨s arcade, sur 1 seconde
        let notes = [523, 659, 784, 1046, 1318]; // Do, Mi, Sol, Do+, Mi+
        notes.forEach((freq, i) => {
          let osc = audioCtx.createOscillator();
          let gain = audioCtx.createGain();
          osc.type = "triangle";
          osc.frequency.setValueAtTime(freq, now + i*0.18);
          gain.gain.setValueAtTime(0.18, now + i*0.18);
          gain.gain.linearRampToValueAtTime(0, now + i*0.18 + 0.15);
          osc.connect(gain).connect(audioCtx.destination);
          osc.start(now + i*0.18);
          osc.stop(now + i*0.18 + 0.17);
        });
        return;
      }


      //insatisfaisant
      if(type === "coins") {
        // VERSION MINIMALISTE - 3 piÃ¨ces seulement
        const coinFreqs = [950, 1100, 850]; // 3 frÃ©quences fixes et naturelles

        coinFreqs.forEach((freq, i) => {
          let osc = audioCtx.createOscillator();
          let gain = audioCtx.createGain();

          osc.type = "triangle";
          osc.frequency.setValueAtTime(freq, now + i * 0.04);
          osc.frequency.exponentialRampToValueAtTime(freq * 0.7, now + i * 0.04 + 0.1);

          gain.gain.setValueAtTime(0, now + i * 0.04);
          gain.gain.linearRampToValueAtTime(0.06 - i * 0.01, now + i * 0.04 + 0.003);
          gain.gain.exponentialRampToValueAtTime(0.001, now + i * 0.04 + 0.1);

          osc.connect(gain).connect(audioCtx.destination);
          osc.start(now + i * 0.04);
          osc.stop(now + i * 0.04 + 0.12);
        });
        return;
      }



      if(type === "autopilot_on") {
              // Jingle de mise en marche de l'autopilote : 3 notes rapides et ascendantes.
              let notes = [440, 587, 784,1046,640, 787, 984,1246]; // La, RÃ©, Sol
              notes.forEach((freq, i) => {
                let osc = audioCtx.createOscillator();
                let gain = audioCtx.createGain();
                osc.type = "triangle"; // Un son plus doux et "high-tech"
                osc.frequency.setValueAtTime(freq, now + i * 0.2);
                gain.gain.setValueAtTime(0.15, now + i * 0.1);
                gain.gain.linearRampToValueAtTime(0, now + i * 0.1 + 0.15);
                osc.connect(gain).connect(audioCtx.destination);
                osc.start(now + i * 0.1);
                osc.stop(now + i * 0.1 + 0.16);
              });
      return;
      }



      if(type === "raquettenormale") {
        // Un petit jingle montant, trÃ¨s arcade
        let notes = [660, 880, 1320];
        notes.forEach((freq, i) => {
          let osc = audioCtx.createOscillator();
          let gain = audioCtx.createGain();
          osc.type = "square";
          osc.frequency.setValueAtTime(freq, now + i*0.07);
          gain.gain.setValueAtTime(0.18, now + i*0.07);
          gain.gain.linearRampToValueAtTime(0, now + i*0.07 + 0.08);
          osc.connect(gain).connect(audioCtx.destination);
          osc.start(now + i*0.07);
          osc.stop(now + i*0.07 + 0.08);
        });
        return;
      }


      if(type === "AutopilotBanner") {
        // Un petit jingle montant, trÃ¨s arcade
        let notes = [560, 780, 1220, 780];
        notes.forEach((freq, i) => {
          let osc = audioCtx.createOscillator();
          let gain = audioCtx.createGain();
          osc.type = "square";
          osc.frequency.setValueAtTime(freq, now + i*0.07);
          gain.gain.setValueAtTime(0.18, now + i*0.07);
          gain.gain.linearRampToValueAtTime(0, now + i*0.07 + 0.08);
          osc.connect(gain).connect(audioCtx.destination);
          osc.start(now + i*0.07);
          osc.stop(now + i*0.07 + 0.08);
        });
        return;
      }



      // pi inutilisÃ©
      if(type === "pi") {
          const coins = [
            { freq: 1200, delay: 0 },
            { freq: 950, delay: 0.06 },
            { freq: 800, delay: 0.13 },
          ];
          coins.forEach((coin) => {
            let o = audioCtx.createOscillator();
            let g = audioCtx.createGain();
            o.type = "triangle";
            o.frequency.setValueAtTime(coin.freq, now + coin.delay);
            o.frequency.linearRampToValueAtTime(10, now + coin.delay + 0.8);
            g.gain.setValueAtTime(0.7, now + coin.delay);
            g.gain.linearRampToValueAtTime(0, now + coin.delay + 0.1);
            o.connect(g).connect(audioCtx.destination);
            o.start(now + coin.delay);
            o.stop(now + coin.delay + 0.2);
          });
          return;
        }

        if(type === "boss_hit") {
            // Son d'impact sur le boss
            let notes = [200, 150, 100];
            notes.forEach((freq, i) => {
                let osc = audioCtx.createOscillator();
                let gain = audioCtx.createGain();
                osc.type = "sawtooth";
                osc.frequency.setValueAtTime(freq, now + i * 0.05);
                gain.gain.setValueAtTime(0.2, now + i * 0.05);
                gain.gain.linearRampToValueAtTime(0, now + i * 0.05 + 0.15);
                osc.connect(gain).connect(audioCtx.destination);
                osc.start(now + i * 0.05);
                osc.stop(now + i * 0.05 + 0.16);
            });
            return;
        }

        if(type === "boss_death") {
            // MÃ©lodie Ã©pique de victoire
            let notes = [262, 330, 392, 523, 659, 784, 1047];
            notes.forEach((freq, i) => {
                let osc = audioCtx.createOscillator();
                let gain = audioCtx.createGain();
                osc.type = "triangle";
                osc.frequency.setValueAtTime(freq, now + i * 0.2);
                gain.gain.setValueAtTime(0.25, now + i * 0.2);
                gain.gain.linearRampToValueAtTime(0, now + i * 0.2 + 0.4);
                osc.connect(gain).connect(audioCtx.destination);
                osc.start(now + i * 0.2);
                osc.stop(now + i * 0.2 + 0.42);
            });
            return;
        }


      if(type==="impact") {
        o.frequency.setValueAtTime(420,now);
        o.frequency.linearRampToValueAtTime(220,now+0.08);
        g.gain.setValueAtTime(0.13,now);
        g.gain.linearRampToValueAtTime(0,now+0.09);
        o.connect(g).connect(audioCtx.destination);
        o.start(now); o.stop(now+0.1);
      } else if(type==="paddle") {
        o.frequency.setValueAtTime(120,now);
        o.frequency.linearRampToValueAtTime(340,now+0.07);
        g.gain.setValueAtTime(0.12,now);
        g.gain.linearRampToValueAtTime(0,now+0.1);
        o.connect(g).connect(audioCtx.destination);
        o.start(now); o.stop(now+0.12);
      } else if(type==="powerup") {
        o.frequency.setValueAtTime(260,now);
        o.frequency.linearRampToValueAtTime(660,now+0.18);
        g.gain.setValueAtTime(0.16,now);
        g.gain.linearRampToValueAtTime(0,now+0.19);
        o.connect(g).connect(audioCtx.destination);
        o.start(now); o.stop(now+0.2);
      } else if(type==="bonus") {
        o.frequency.setValueAtTime(220,now);
        o.frequency.linearRampToValueAtTime(1220,now+0.30);
        g.gain.setValueAtTime(0.22,now);
        g.gain.linearRampToValueAtTime(0,now+0.33);
        o.connect(g).connect(audioCtx.destination);
        o.start(now); o.stop(now+0.35);
      } else if(type==="life") {
        o.frequency.setValueAtTime(660,now);
        o.frequency.linearRampToValueAtTime(220,now+0.22);
        g.gain.setValueAtTime(0.18,now);
        g.gain.linearRampToValueAtTime(0,now+0.25);
        o.connect(g).connect(audioCtx.destination);
        o.start(now); o.stop(now+0.26);
      } else if(type==="life2") {
      o.frequency.setValueAtTime(960,now);
      o.frequency.linearRampToValueAtTime(420,now+0.22);
      g.gain.setValueAtTime(0.18,now);
      g.gain.linearRampToValueAtTime(0,now+0.25);
      o.connect(g).connect(audioCtx.destination);
      o.start(now); o.stop(now+0.26);
    }
    }

    function showSpeedControl() {
        const control = document.getElementById('speedControl');
        if (control) {
            control.value = ballSpeed0;
            control.style.display = 'block';
            control.oninput = (e) => {
                ballSpeed0 = parseInt(e.target.value);
                ballSpeed = ballSpeed0;
            };
        }
    }

    // === INITIALISATION DU JEU ===
    function resetGame() {
      playSound("startGame");

      vies = 4; niveau = 1; score = 0; mult = 1; multTimer = 0; lastMult = 1;
      displayScore = 0;
      paddleW = paddleBaseW; paddleX = (CANVAS_W-paddleW)/2;
      ballSpeed = ballSpeed0; gameOver = false;
      wallOffset = 60; brickRows = 8;levelsPassed = 0;

      compensationStep = 5;
      shotHistory = [];
      lastTargetBrick = null;

      clearAllTimersEndLevel();
      createBricks();
      resetBall();

      // âœ… NOUVEAU : Initialisation de la galaxie
      initGalaxy();

      // âœ… ORDRE CORRIGÃ‰ : Ã‰tat du jeu Ã  la fin
      pause = false;
      gameStarted = true;
      emailSent = false;

      paddleW = paddleBaseW;
      particles = []; powerups = []; bonuses = []; animations = [];
      paddleTimer = 0; paddleTimerActive = false;
      decrementTimer = 0; decrementActive = false; decrementEffect = false;
      elDec.style.display = "none";
      updateHUD();
      updateMultDisplay(mult);

      // Statistiques
      bricksHit = 0;
      for(let k in bonusesCaptured) bonusesCaptured[k]=0;
      for(let k in powerupsCaptured) powerupsCaptured[k]=0;

      startTime = Date.now();
      elapsedTime = 0;
      document.getElementById('endPanel').style.display = "none";

    }

    // âœ… NOUVELLE FONCTION : DÃ©marrage contrÃ´lÃ© du jeu
    function startGame() {
        console.log("DÃ©marrage du jeu aprÃ¨s clic sur OK");

        try {
            // 1. RÃ©initialiser complÃ¨tement
            resetGame();

            // âœ… CORRECTION : VÃ©rifier que les Ã©lÃ©ments DOM existent
            if (!canvas || !ctx) {
                console.error("âŒ Canvas non trouvÃ© !");
                return;
            }

            if (!ball) {
                console.error("âŒ Balle non initialisÃ©e !");
                return;
            }

            // âœ… S'assurer que AudioContext est initialisÃ©
            if (audioCtx.state === 'suspended') {
                audioCtx.resume().then(() => {
                    console.log('ğŸ”Š AudioContext activÃ©');
                }).catch(e => {
                    console.warn('âš ï¸ ProblÃ¨me audio:', e);
                });
            }

            // 2. S'assurer que la boucle n'est pas dÃ©jÃ  lancÃ©e
            if (gameLoopId) {
                cancelAnimationFrame(gameLoopId);
                gameLoopId = null;
            }

            // 3. Initialiser le panneau de stats
            try {
                updateStatsPanel();
                console.log("âœ… Panneau de stats initialisÃ©");
            } catch (statsError) {
                console.warn("âš ï¸ Erreur panneau de stats:", statsError);
            }

            // 4. Lancer la boucle de jeu
            console.log("ğŸš€ Lancement de la boucle de jeu");
            lastFrame = 0; // âœ… AJOUT : Reset du timer
            gameLoopId = requestAnimationFrame(gameLoop);

            console.log("âœ… Jeu dÃ©marrÃ© avec succÃ¨s - Ã‰tats:", {
                gameStarted: gameStarted,
                pause: pause,
                gameOver: gameOver,
                ballExists: !!ball
            });

        } catch (error) {
            console.error("âŒ Erreur critique de dÃ©marrage:", error);

            // âœ… Fallback robuste amÃ©liorÃ©
            setTimeout(() => {
                console.log("ğŸ”„ Tentative de rÃ©cupÃ©ration...");

                // Reset complet des Ã©tats
                gameStarted = true;
                pause = false;
                gameOver = false;

                // RecrÃ©er la balle si nÃ©cessaire
                if (!ball) {
                    ball = {x: CANVAS_W/2, y: paddleY-30, r: ballR};
                    ballDX = 5;
                    ballDY = -5;
                }

                // Relancer la boucle
                if (!gameLoopId) {
                    gameLoopId = requestAnimationFrame(gameLoop);
                    console.log("âœ… Boucle de rÃ©cupÃ©ration lancÃ©e");
                }
            }, 1000);
        }
    }


    function isBossLevelCheck() {
        return niveau % 5 === 0; // Boss tous les 5 niveaux : 5, 10, 15, 20, etc.
    }



    function createBoss() {
        isBossLevel = true;
        bossDefeated = false;

        // Stats du boss Ã©voluent avec le niveau
        bossMaxHP = 50 + Math.floor(niveau / 5) * 25;
        bossHP = bossMaxHP;
        bossPhase = 1;
        bossInvulnerable = false;
        bossAttackTimer = 0;
        bossMovementTimer = 0;

        // Position initiale du boss
        boss = {
            x: CANVAS_W / 2 - 60,
            y: 140,
            w: 170,
            h: 80,
            targetX: CANVAS_W / 2 - 60,
            speed: 8 + niveau * 0.5,
            direction: 1,
            lastAttack: 0,
            attackCooldown: Math.max(1500, 2500 - niveau * 40),
            alive: true,
            hitFlash: 0,
            entrancePhase: true,
            entranceY: -100
        };

        // CrÃ©er quelques briques protectrices
        createBossShield();
    }


    function createBossShield() {
        bricks = [];

        // âœ… FORMATION DÃ‰FENSIVE RENFORCÃ‰E
        const formations = [
            // Mur de protection principal (plus large)
            {x: boss.x - 120, y: boss.y + 80},
            {x: boss.x - 60, y: boss.y + 80},
            {x: boss.x, y: boss.y + 80},
            {x: boss.x + 60, y: boss.y + 80},
            {x: boss.x + 120, y: boss.y + 80},
            {x: boss.x + 180, y: boss.y + 80},

            // DeuxiÃ¨me ligne de protection
            {x: boss.x - 90, y: boss.y + 120},
            {x: boss.x - 30, y: boss.y + 120},
            {x: boss.x + 30, y: boss.y + 120},
            {x: boss.x + 90, y: boss.y + 120},
            {x: boss.x + 150, y: boss.y + 120},

            // TroisiÃ¨me ligne (briques spÃ©ciales)
            {x: boss.x - 60, y: boss.y + 160},
            {x: boss.x + 30, y: boss.y + 160},
            {x: boss.x + 120, y: boss.y + 160},

            // Tours de dÃ©fense latÃ©rales
            {x: boss.x - 150, y: boss.y + 40},
            {x: boss.x - 150, y: boss.y + 100},
            {x: boss.x + boss.w + 80, y: boss.y + 40},
            {x: boss.x + boss.w + 80, y: boss.y + 100}
        ];

        formations.forEach((pos, idx) => {
            if (pos.x >= 0 && pos.x + brickW <= CANVAS_W) {
                let specialChance = 0.4; // 40% de chance d'avoir un special
                let isSpecial = Math.random() < specialChance;
                let special = null;

                if (isSpecial) {
                    // âœ… PLUS DE MULTIPLICATEURS DANS LES BRIQUES BOSS
                    let specials = ["1ï¸âƒ£", "2ï¸âƒ£", "4ï¸âƒ£", "8ï¸âƒ£", "ğŸ³ï¸", "â¤ï¸â€ğŸ”¥"];
                    if (Math.random() < 0.3) specials.push("â˜ ï¸"); // Quelques skulls
                    special = specials[Math.floor(Math.random() * specials.length)];
                }

                bricks.push({
                    x: pos.x,
                    y: pos.y,
                    w: brickW,
                    h: brickH,
                    finalX: pos.x,
                    finalY: pos.y,
                    colorIdx: (idx < 6) ? 4 : (idx < 11) ? 3 : 2, // DÃ©gradÃ© de couleurs
                    special: special,
                    alive: true,
                    animFrame: 36,
                    animAngle: 0,
                    animating: false,
                    isBossShield: true
                });
            }
        });
    }



    function createBricks() {
      bricks = [];
      isBossLevel = false;
      let specials = [];
      let AutopilotBanner = false
      let nbSpecials = 10;
      while(specials.length < nbSpecials) {
        let idx = Math.floor(Math.random()*brickRows*brickCols);
        if(!specials.includes(idx)) specials.push(idx);
      }
      let skullsIdx = [];
      while(skullsIdx.length < 2) {
        let idx = Math.floor(Math.random()*brickRows*brickCols);
        if(!skullsIdx.includes(idx)) skullsIdx.push(idx);
      }
      for(let r=0; r<brickRows; r++) {
        for(let c=0; c<brickCols; c++) {
          let idx = r*brickCols+c;
          let special = null;
          if(skullsIdx.includes(idx)) special = "â˜ ï¸";
          else if(specials.includes(idx)) special = SPECIAL_ICONS[Math.floor(Math.random()*SPECIAL_ICONS.length)];
          let colorIdx = r%BRICK_GRADIENTS.length;
          // Emplacement final
          let finalX = c*(brickW+brickGap)+brickGap+((CANVAS_W-brickCols*(brickW+brickGap))/2);
          let finalY = wallOffset+r*(brickH+brickGap);
          // Apparition depuis le centre, avec angle unique pour chaque brique
          let angle = Math.random() * 3 * Math.PI;
          bricks.push({
            x: CANVAS_W/2,
            y: CANVAS_H/2,
            w: brickW, h: brickH,
            finalX, finalY,
            colorIdx, special, alive:true,
            animFrame: 0,
            animAngle: angle,
            animating: true
          });
        }
      }
    }



    function drawPaddle(ctx,x,y,w,h,r=10){
      const p = new Path2D();
      p.moveTo(x+r, y);
      p.lineTo(x+w-r, y);
      p.arc(x+w-r, y+h/2, r, -Math.PI/2,  Math.PI/2);
      p.lineTo(x+r, y+h);
      p.arc(x+r,   y+h/2, r,  Math.PI/2, -Math.PI/2);
      ctx.fillStyle = '#fff';
      ctx.shadowColor = '#0ff';
      ctx.shadowBlur  = 20;
      ctx.fill(p);
    }

    // === FONCTION POUR DESSINER DES RECTANGLES ARRONDIS ===
    function drawRoundedRect(ctx, x, y, width, height, radius = 8) {
        if (width < 2 * radius) radius = width / 2;
        if (height < 2 * radius) radius = height / 2;

        ctx.beginPath();
        ctx.moveTo(x + radius, y);
        ctx.arcTo(x + width, y, x + width, y + height, radius);
        ctx.arcTo(x + width, y + height, x, y + height, radius);
        ctx.arcTo(x, y + height, x, y, radius);
        ctx.arcTo(x, y, x + width, y, radius);
        ctx.closePath();
    }
    //Fin de fonction drawRoundedRect

    function resetBall() {

      setTimeout(() => {   }, 500);
      ball = {x:CANVAS_W/2, y:paddleY-30, r:ballR};
      // âœ… CONSERVATION DE LA VITESSE PROGRESSIVE

//      updateBallSpeed(); // Recalcule la vitesse actuelle

      // âœ… PROGRESSION TRÃˆS GRADUELLE par niveau
      baseGameSpeed = Math.min(14, 12 + (niveau - 1) * 0.05);
      ballSpeed = baseGameSpeed;

      let angle = (Math.random()*0.6+0.2)*Math.PI;
      ballDX = Math.cos(angle)*currentGameSpeed*(Math.random()<0.5?-1:1);
      ballDY = -Math.abs(Math.sin(angle)*currentGameSpeed);
      gameStarted = true; // Flag obligatoire
    }

    function updateHUD() {
      elScore.textContent = score.toString().padStart(9, "0");
      elVies.textContent = "VIES:"+vies;
      elNiveau.textContent = "NIVEAU:"+niveau;
      elMult.textContent = "x" + mult;



      const elCookies = document.getElementById('cookies');
      if (elCookies) {
          if (cookies > 0) {
            elCookies.textContent = "COOKIES:" + cookies;
            elCookies.style.display = 'inline-block';
          } else {
            elCookies.style.display = 'none';
          }
        }
    }



    function updateMultDisplay(newMult) {

      elMult.textContent = "x" + newMult;
      // Logique de clignotement
      if (newMult > 1) {
        elMult.classList.add("blinking-effect"); // On ajoute la classe pour le faire clignoter
      } else {
        elMult.classList.remove("blinking-effect"); // On la retire s'il revient Ã  x1
      }

      // L'ancien systÃ¨me de "flash" lors du changement est conservÃ©
      //if (newMult !== lastMult) {
      //  elMult.classList.add("flash");
      //  setTimeout(() => elMult.classList.remove("flash"), 250);
      //  lastMult = newMult;
      //}

    }

    // === CONTRÃ”LES CLAVIER & SOURIS ===

    document.addEventListener('keydown',e=>{

      if ((e.key==="m" || e.key==="M") && cookies > 0 && !autopilot) {
          panic = 600; PanicButon=true
          --cookies; updateHUD();
          playSound("pi");
      }
      if ((e.key==="*" || e.key==="*") && !autopilot) {
//          ++vies; updateHUD();
          playSound("pi");
      }

      if ((e.key==="n" || e.key==="N") && !autopilot) {
//          niveau +=1 ; updateHUD();
      }

      // âœ… TOUCHE DEBUG : Z (simple et sans conflit)
      if(e.key==="z" || e.key==="Z") {
          e.preventDefault();
          if (Debug === true) {
              Debug = false;
            } else {
              Debug=true;
              showDebugPopup();
          return;
      }
    }

      // âœ… GESTION DES TOUCHES DE MOUVEMENT
      if(e.code==="ArrowLeft"||e.key==="q"||e.key==="Q") leftDown=true;
      if(e.code==="ArrowRight"||e.key==="d"||e.key==="D") rightDown=true;

      // âœ… GESTION DU SON ET DE LA PAUSE
      if(e.key==="s" || e.key==="S") {
        // Toggle du son (si tu as une fonction pour Ã§a)
      }

      if(e.key==="p" || e.key==="P") {
        pause = !pause; // Toggle de la pause
      }
    });


    canvas.addEventListener('mousemove', e => {
        // EmpÃªche la souris de prendre le contrÃ´le si l'autopilote est actif
        if (autopilot) return;

        // âœ… NOUVEAU : Calcul des coordonnÃ©es avec scale
        const scaledCoords = getScaledCoordinates(e.clientX, e.clientY);
        const limits = getEffectiveCanvasLimits();

        // âœ… NOUVEAU : SystÃ¨me de dÃ©multiplication du mouvement
        if (lastMouseX !== null) {
            // Calcul du dÃ©placement rÃ©el de la souris
            let deltaX = scaledCoords.x - lastMouseX;

            // âœ… APPLICATION DE LA DÃ‰MULTIPLICATION
            let amplifiedDelta = deltaX * mouseSensitivity;

            // Position cible avec dÃ©multiplication
            let targetX = paddleX + paddleW/2 + amplifiedDelta - paddleW/2;

            // âœ… CONTRAINTES : Rester dans les limites
            paddleX = Math.max(
                0,
                Math.min(limits.width - paddleW, targetX)
            );

        } else {
            // âœ… PREMIER MOUVEMENT : Position directe (sans dÃ©multiplication)
            paddleX = Math.max(
                0,
                Math.min(limits.width - paddleW, scaledCoords.x - paddleW / 2)
            );
        }

        // âœ… MÃ‰MORISATION de la position pour le prochain mouvement
        lastMouseX = scaledCoords.x;
    });
    //Fin de fonction mousemove_demultiplie


    // âœ… NOUVEAU : ContrÃ´le par molette de souris
    // === CONTRÃ”LE MOLETTE CORRIGÃ‰ POUR LE RESPONSIVE ===
    canvas.addEventListener('wheel', e => {
        e.preventDefault(); // EmpÃªche le scroll de la page

        // Ne pas contrÃ´ler si l'autopilote est actif
        if (autopilot) return;

        // âœ… NOUVEAU : SensibilitÃ© ajustÃ©e selon le scale
        const scaleFactor = getCurrentScaleFactor();
        const baseSensitivity = 20;
        const adjustedSensitivity = baseSensitivity * scaleFactor;

        // Calcul du dÃ©placement basÃ© sur la direction de la molette
        let deltaMove = 0;

        if (e.deltaY > 0) {
            // Molette vers le bas = mouvement vers la droite
            deltaMove = adjustedSensitivity;
        } else if (e.deltaY < 0) {
            // Molette vers le haut = mouvement vers la gauche
            deltaMove = -adjustedSensitivity;
        }

        // âœ… NOUVEAU : Limites ajustÃ©es selon le scale
        const limits = getEffectiveCanvasLimits();
        paddleX = Math.max(
            0,
            Math.min(limits.width - paddleW, paddleX + deltaMove)
        );
    });
    //Fin de fonction wheel_corrected


function autopilotMove(dt) {
    if (!ball) return;

    let finalTargetX = paddleX;
    let moveSpeed = 600; // âœ… VITESSE DE BASE AUGMENTÃ‰E
    let urgency = 1;

    // === VARIABLES DE PERFORMANCE ===
    const paddleCenter = paddleX + paddleW/2;
    const remainingBricks = bricks.filter(b => b.alive);
    const isEndGame = remainingBricks.length <= 8;

    // âœ… NOUVEAU : DÃ‰TECTION ULTRA-AGRESSIVE DES POWER-UPS
    let bestPowerup = null;
    let bestPowerupScore = -1;
    let powerupUrgency = 1;

    // === 1. PHASE COLLECTE POWER-UPS - PRIORITÃ‰ ABSOLUE ===
    powerups.forEach(p => {
        // âœ… ZONE DE DÃ‰TECTION MASSIMENT Ã‰LARGIE
        if (p.y > 50 && p.y < paddleY + 200 && !p.caught) { // Zone Ã©norme !

            // âœ… CALCUL PRÃ‰DICTIF DE LA TRAJECTOIRE
            let timeToIntercept = Math.max(0.1, (paddleY - p.y) / (p.speed || 6));
            let futureX = p.x + (p.dx || 0) * timeToIntercept;
            let currentDistance = Math.abs(futureX - paddleCenter);

            // âœ… NOUVEAU : Test si c'est atteignable
            let maxReachDistance = Math.min(CANVAS_W, paddleW * 4 + timeToIntercept * 1000);

            if (currentDistance <= maxReachDistance && timeToIntercept < 5) {
                let score = 5000; // Score de base Ã©norme !

                // âœ… PRIORISATION RÃ‰VOLUTIONNAIRE DES MULTIPLICATEURS
                if (p.type === "mult8") {
                    score = 50000;  // âœ… PRIORITÃ‰ MAXIMALE ABSOLUE
                    powerupUrgency = 5;
                } else if (p.type === "mult4") {
                    score = 40000;  // âœ… ULTRA PRIORITAIRE
                    powerupUrgency = 4.5;
                } else if (p.type === "mult2") {
                    score = 30000;  // âœ… TRÃˆS PRIORITAIRE
                    powerupUrgency = 4;
                } else if (p.type === "mult1") {
                    score = 25000;  // âœ… PRIORITAIRE
                    powerupUrgency = 3.5;
                } else if (p.type === "huge") {
                    score = 20000;  // âœ… Raquette gÃ©ante importante
                    powerupUrgency = 3;
                } else if (p.type === "long") {
                    score = 15000;  // âœ… Raquette longue importante
                    powerupUrgency = 2.5;
                } else if (p.type !== "skull") {
                    score = 10000;  // âœ… Autres power-ups importants
                    powerupUrgency = 2;
                }

                // âœ… BONUS TEMPOREL MASSIF
                let timeBonus = Math.max(0, 10000 - timeToIntercept * 2000);
                score += timeBonus;

                // âœ… BONUS PROXIMITÃ‰ Ã‰NORME
                let proximityBonus = Math.max(0, 8000 - currentDistance * 20);
                score += proximityBonus;

                // âœ… BONUS D'URGENCE selon la hauteur
                if (p.y > paddleY - 150) {
                    score += 15000; // Bonus Ã©norme si proche !
                    powerupUrgency += 2;
                }

                // âœ… SÃ‰LECTION DU MEILLEUR POWER-UP
                if (score > bestPowerupScore) {
                    bestPowerupScore = score;
                    bestPowerup = {
                        x: futureX,
                        originalX: p.x,
                        y: p.y,
                        timeToIntercept: timeToIntercept,
                        type: p.type,
                        urgency: powerupUrgency,
                        score: score
                    };
                }
            }
        }
    });

    // âœ… SI POWER-UP TROUVÃ‰ : MODE COLLECTE ULTRA-AGRESSIF
    if (bestPowerup) {
        console.log(`ğŸ¯ POWER-UP CIBLÃ‰ : ${bestPowerup.type} (Score: ${bestPowerup.score}) Ã  ${Math.floor(bestPowerup.x)}`);

        finalTargetX = bestPowerup.x - paddleW/2;
        moveSpeed = 1200 + bestPowerup.urgency * 200; // âœ… VITESSE Ã‰NORME !
        urgency = bestPowerup.urgency;

        // âœ… BOOST SUPPLÃ‰MENTAIRE SI TRÃˆS PROCHE
        if (bestPowerup.timeToIntercept < 1) {
            moveSpeed *= 2; // DOUBLE LA VITESSE !
            urgency *= 2;
        }

        // âœ… CORRECTION PRÃ‰DICTIVE AVANCÃ‰E
        let horizontalSpeed = Math.abs(finalTargetX - paddleCenter);
        let correctionFactor = Math.min(2, horizontalSpeed / 100);
        finalTargetX += (finalTargetX > paddleCenter ? 1 : -1) * correctionFactor * 20;

    // === 2. SI PAS DE POWER-UP : LOGIQUE DÃ‰FENSIVE/OFFENSIVE ===
    } else {
        // âœ… Ã‰VITEMENT SKULLS (inchangÃ© - fonctionne bien)
        let dangerousSkull = null;
        let minDanger = Infinity;

        skulls.forEach(skull => {
            if (skull.y < paddleY && skull.y > CANVAS_H * 0.4) {
                let timeToImpact = (paddleY - skull.y) / skull.speed;
                if (timeToImpact < minDanger && timeToImpact > 0.3) {
                    minDanger = timeToImpact;
                    dangerousSkull = skull;
                }
            }
        });

        if (dangerousSkull) {
            let skullCenter = dangerousSkull.x;
            let safeDistance = paddleW * 0.8;

            if (skullCenter - safeDistance > paddleW/2) {
                finalTargetX = skullCenter - safeDistance - paddleW/2;
            } else if (skullCenter + safeDistance < CANVAS_W - paddleW/2) {
                finalTargetX = skullCenter + safeDistance - paddleW/2;
            } else {
                finalTargetX = (paddleCenter < CANVAS_W/2) ? 0 : CANVAS_W - paddleW;
            }
            moveSpeed = 800;
            urgency = 3;

        // âœ… DÃ‰FENSE (si balle descend)
        } else if (ballDY > 0 && ball.y > CANVAS_H * 0.6) {
            let timeToImpact = (paddleY - ball.y) / ballDY;
            let impactX = ball.x + ballDX * timeToImpact;

            // Gestion des rebonds
            while (impactX < 0 || impactX > CANVAS_W) {
                if (impactX < 0) impactX = -impactX;
                if (impactX > CANVAS_W) impactX = CANVAS_W - (impactX - CANVAS_W);
            }

            finalTargetX = impactX - paddleW/2;
            moveSpeed = 700;
            urgency = 2;

        // âœ… COLLECTE BONUS SECONDAIRE
        } else {
            let bestBonus = null;
            let bestBonusScore = -1;

            bonuses.forEach(b => {
                if (b.y > CANVAS_H * 0.2 && b.y < paddleY - 10) {
                    let timeToIntercept = (paddleY - b.y) / (b.speed || 6);
                    let distance = Math.abs(b.x - paddleCenter);

                    if (timeToIntercept > 0.2 && timeToIntercept < 3 && distance < CANVAS_W * 0.7) {
                        let score = (b.points || 100) * 10 + Math.max(0, 500 - distance);

                        if (score > bestBonusScore) {
                            bestBonusScore = score;
                            bestBonus = {x: b.x, timeToIntercept: timeToIntercept};
                        }
                    }
                }
            });

            if (bestBonus) {
                finalTargetX = bestBonus.x - paddleW/2;
                moveSpeed = 600;
                urgency = 1.5;

            // âœ… PHASE OFFENSIVE (attaque des briques)
            } else if (ballDY < 0 && ball.y < CANVAS_H * 0.7) {
                // Logique de ciblage des briques simplifiÃ©e mais efficace
                let targetBrick = null;
                let bestBrickScore = -1;

                remainingBricks.forEach(brick => {
                    let distance = Math.abs(brick.x + brick.w/2 - ball.x) + Math.abs(brick.y - ball.y);
                    let score = 1000 - distance;

                    // Bonus pour briques accessibles
                    if (brick.y > wallOffset + brickH * 2) score += 300;

                    // Bonus pour briques spÃ©ciales
                    if (brick.special && brick.special.includes("ï¸âƒ£")) score += 500;

                    if (score > bestBrickScore) {
                        bestBrickScore = score;
                        targetBrick = brick;
                    }
                });

                if (targetBrick) {
                    let targetX = targetBrick.x + targetBrick.w/2;
                    let deltaX = targetX - ball.x;
                    let deltaY = targetBrick.y - ball.y;
                    let requiredAngle = Math.atan2(deltaX, -deltaY);
                    let paddleOffset = Math.sin(requiredAngle) * paddleW * 0.4;
                    finalTargetX = ball.x - paddleW/2 + paddleOffset;
                    moveSpeed = 650;
                    urgency = 1.8;
                } else {
                    finalTargetX = (CANVAS_W - paddleW) / 2;
                    moveSpeed = 400;
                }
            }
        }
    }

    // === 3. MOUVEMENT ULTRA-OPTIMISÃ‰ ET FLUIDE ===
    finalTargetX = Math.max(0, Math.min(CANVAS_W - paddleW, finalTargetX));

    let currentX = paddleX;
    let deltaX = finalTargetX - currentX;
    let distance = Math.abs(deltaX);

    if (distance > 1) { // Seuil ultra-fin
        let direction = deltaX > 0 ? 1 : -1;

        // âœ… VITESSE ADAPTATIVE RÃ‰VOLUTIONNAIRE
        let adaptiveSpeed = moveSpeed * urgency;

        // âœ… BOOST MASSIF pour les power-ups
        if (bestPowerup) {
            adaptiveSpeed *= 2.5; // Boost Ã©norme !
        }

        // Boost selon distance
        if (distance > paddleW * 2) adaptiveSpeed *= 1.8;
        else if (distance > paddleW) adaptiveSpeed *= 1.4;

        // âœ… MOUVEMENT FLUIDE AVEC INERTIE AMÃ‰LIORÃ‰E
        let maxMove = Math.min(distance, adaptiveSpeed * dt * megaspeed * 3);

        // Lissage prÃ¨s de la cible
        if (distance < 30) {
            maxMove *= (0.5 + (distance / 30) * 0.5);
        }

        // âœ… SYSTÃˆME D'INERTIE NATURELLE
        if (!paddleVelocity) paddleVelocity = 0;
        let targetVelocity = direction * maxMove;
        paddleVelocity += (targetVelocity - paddleVelocity) * 0.4; // Inertie plus rÃ©active

        paddleX += paddleVelocity;
    } else {
        // ArrÃªt en douceur
        if (paddleVelocity) paddleVelocity *= 0.9;
        paddleX += paddleVelocity;
    }

    // Contraintes finales
    //  paddleX = Math.max(0, Math.min(CANVAS_W - paddleW, paddleX));

    const limits = getEffectiveCanvasLimits();
    paddleX = Math.max(0, Math.min(limits.width - paddleW, paddleX));

    // âœ… CONTRÃ”LE VITESSE BALLE ENDGAME (inchangÃ©)
    if (isEndGame && Math.sqrt(ballDX * ballDX + ballDY * ballDY) < 16) {
        let currentSpeed = Math.sqrt(ballDX * ballDX + ballDY * ballDY);
        let targetSpeed = Math.min(18, 16 + (8 - remainingBricks.length));
        if (currentSpeed > 0) {
            let ratio = targetSpeed / currentSpeed;
            ballDX *= ratio;
            ballDY *= ratio;
        }
    }
}

    /**
     * Calcule le point d'impact prÃ©cis pour la dÃ©fense (fonction conservÃ©e car elle est parfaite).
     */
    function calculateDefensiveinterceptionPoint() {
      if (ballDY < 0) return ball.x;
      const timeToImpact = (paddleY - ball.y) / ballDY;
      let impactX = ball.x + ballDX * timeToImpact;
      while (impactX < 0 || impactX > CANVAS_W) {
        if (impactX < 0) impactX = -impactX;
        if (impactX > CANVAS_W) impactX = CANVAS_W - (impactX - CANVAS_W);
      }
      return impactX;
    }

    function calculateTrajectory(ball, dx, dy, brick, maxBounces) {
        let testX = ball.x;
        let testY = ball.y;
        let testDX = dx;
        let testDY = dy;
        let bounces = 0;
        let time = 0;

        // Simulation de trajectoire
        for (let i = 0; i < 200 && time < 300; i++) {
            let nextX = testX + testDX;
            let nextY = testY + testDY;
            time++;

            // VÃ©rification collision avec la brique cible
            if (nextY >= brick.y && nextY <= brick.y + brick.h &&
                nextX >= brick.x && nextX <= brick.x + brick.w) {

                // Calculer la position de raquette requise
                let ballReturnTime = (paddleY - nextY) / Math.abs(testDY);
                let ballReturnX = nextX + testDX * ballReturnTime;

                // GÃ©rer les rebonds sur le retour
                while (ballReturnX < 0 || ballReturnX > CANVAS_W) {
                    if (ballReturnX < 0) ballReturnX = -ballReturnX;
                    if (ballReturnX > CANVAS_W) ballReturnX = CANVAS_W - (ballReturnX - CANVAS_W);
                }

                return {
                    canHit: true,
                    impactX: nextX,
                    impactY: nextY,
                    requiredPaddleX: ballReturnX - paddleW/2,
                    timeToHit: time,
                    bounces: bounces
                };
            }

            // Gestion des rebonds sur les murs
            if (nextX <= 0 || nextX >= CANVAS_W) {
                testDX = -testDX;
                bounces++;
                if (bounces > maxBounces) break;
            }
            if (nextY <= 0) {
                testDY = -testDY;
                bounces++;
                if (bounces > maxBounces) break;
            }

            testX = nextX;
            testY = nextY;
        }

        return { canHit: false };
    }

    // âœ… FONCTION UTILITAIRE : Trouver la brique la plus accessible
    function findMostAccessibleBrick() {
        let closestBrick = null;
        let minDistance = Infinity;

        bricks.forEach(brick => {
            if (!brick.alive) return;

            let distance = Math.sqrt(
                Math.pow(brick.x + brick.w/2 - ball.x, 2) +
                Math.pow(brick.y + brick.h/2 - ball.y, 2)
            );

            // Bonus pour les briques du bas (plus faciles Ã  atteindre)
            if (brick.y > wallOffset + brickH * 2) {
                distance *= 0.8;
            }

            if (distance < minDistance) {
                minDistance = distance;
                closestBrick = brick;
            }
        });

        return closestBrick;
    }

    // âœ… FONCTION CENTRALE DE GESTION DE LA VITESSE
    function calculateGameSpeed() {
        // Vitesse de base + bonus niveau + bonus briques cassÃ©es
        let progressiveSpeed = baseGameSpeed +
                              (niveau - 1) * speedIncreasePerLevel +
                              bricksHit * speedIncreasePerBrick;

        // Application du multiplicateur autopilote si actif
        if (autopilot) {
            currentGameSpeed = progressiveSpeed * autopilotSpeedMultiplier;
        } else {
            currentGameSpeed = progressiveSpeed;
        }

        // âœ… LIMITATIONS PLUS STRICTES selon le mode
        if (autopilot) {
            currentGameSpeed = Math.min(currentGameSpeed, 13 + niveau * 0.05); // Limite autopilote
        } else {
            currentGameSpeed = Math.min(currentGameSpeed, 15 + niveau * 0.15); // Limite normale
        }

        return currentGameSpeed;
    }

    // âœ… FONCTION DE MISE Ã€ JOUR DE LA VITESSE DE LA BALLE
    function updateBallSpeed() {
        let newSpeed = calculateGameSpeed();

        // Conservation de la direction actuelle
        let currentSpeed = Math.sqrt(ballDX * ballDX + ballDY * ballDY);
        if (currentSpeed > 0) {
            let ratio = newSpeed / currentSpeed;
            ballDX *= ratio;
            ballDY *= ratio;
        }

        ballSpeed = newSpeed;

        // âœ… SÃ‰CURITÃ‰ ABSOLUE : Plafond de vitesse global RÃ‰DUIT
        let absoluteMaxSpeed = Math.min(18, 14 + niveau * 0.08); // Progression trÃ¨s lente + plafond Ã  18
        if (ballSpeed > absoluteMaxSpeed) {
            ballSpeed = absoluteMaxSpeed;
            console.log(`Vitesse limitÃ©e Ã  ${absoluteMaxSpeed.toFixed(1)} au niveau ${niveau}`);
        }

        // âœ… Application immÃ©diate de la limitation
        let currentBallSpeed = Math.sqrt(ballDX * ballDX + ballDY * ballDY);
        if (currentBallSpeed > ballSpeed) {
            let ratio = ballSpeed / currentBallSpeed;
            ballDX *= ratio;
            ballDY *= ratio;
        }



    }

    // === LOGIQUE DE MISE Ã€ JOUR DU JEU ===

    function update(dt, elapsed_ms) {

      // --- GESTION AUTOPILOTE & BANDEAU (VERSION CORRIGÃ‰E) ---
      let briquesRestantes = bricks.filter(b => b.alive).length;

      // 1. Logique du bandeau d'avertissement (SIMPLIFIÃ‰E)
      if (!autopilot && !isBossLevel &&
          briquesRestantes > 0 && briquesRestantes <= LancementAutoPilote + countdownRange &&
          briquesRestantes > LancementAutoPilote) {

          let bricksToActivation = briquesRestantes - LancementAutoPilote;
          elAutopilotBanner.textContent = `AUTOPILOT DANS ${bricksToActivation}`;

          if (elAutopilotBanner.style.display !== 'block') {
              playSound("AutopilotBanner");
              elAutopilotBanner.style.display = 'block';
          }

          elAutopilotBanner.classList.remove('flash');
          void elAutopilotBanner.offsetWidth;
          elAutopilotBanner.classList.add('flash');

      } else {
          if (elAutopilotBanner.style.display !== 'none') {
              elAutopilotBanner.style.display = 'none';
          }
      }

      // âœ… APPEL DIRECT ET SIMPLE
      if (document.getElementById('statsPanel')) {
        updateStatsPanel();
      }


      // 2. Activation de l'autopilote (LOGIQUE CORRIGÃ‰E)
      if (briquesRestantes <= LancementAutoPilote && !autopilot && !isBossLevel) {
          autopilot = true;
          leftDown = rightDown = false;

          // âœ… TRANSITION FLUIDE VERS LA VITESSE AUTOPILOTE
          updateBallSpeed(); // Applique immÃ©diatement le multiplicateur autopilote
          playSound("autopilot_on");
      }

      // 3. DÃ©sactivation pour les boss (SÃ‰CURISÃ‰E)
      if (isBossLevel && autopilot) {
          autopilot = false;
          updateBallSpeed(); // Retire le multiplicateur autopilote
          leftDown = rightDown = false;
          playSound("raquettenormale");

          // Affichage du message boss
          elAutopilotBanner.textContent = "âš ï¸ BOSS FIGHT - CONTRÃ”LE MANUEL âš ï¸";
          elAutopilotBanner.style.display = 'block';
          elAutopilotBanner.style.color = '#ff0000';

          setTimeout(() => {
              if (elAutopilotBanner.style.display !== 'none') {
                  elAutopilotBanner.style.display = 'none';
              }
          }, 3000);
      }

      // 4. Retour au manuel si trop de briques (NOUVEAU NIVEAU)
      if (briquesRestantes > LancementAutoPilote && autopilot && !isBossLevel) {
          autopilot = false;
          megaspeed = 1;
      }

      // GESTION DU MODE PANIC (CORRIGÃ‰E)
      if (panic > 0) {
          panic--;
          if (!autopilot) {
              autopilot = true;
              leftDown = rightDown = false;
          }
      } else if (PanicButon) {
          autopilot = false;
          PanicButon = false;
      }

      // AFFICHAGE DU STATUS AUTOPILOT (CORRIGÃ‰)
      if (autopilot) {
        elAutopilotStatus.style.display = 'inline-block';
        elAutopilotStatus.classList.add('blinking-effect');
       } else {
        elAutopilotStatus.style.display = 'none';
        elAutopilotStatus.classList.remove('blinking-effect');
      }

      // APPEL DE L'AUTOPILOTE (CONDITION CORRIGÃ‰E)
      if (autopilot && !isBossLevel) { // âœ… AJOUT : !isBossLevel
          autopilotMove(dt);
      } else {
          // ContrÃ´le manuel
          // CONTRÃ”LE MANUEL (VERSION CORRIGÃ‰E POUR LE RESPONSIVE)
          if (leftDown && !rightDown) {
              paddleAcceleration = Math.min(paddleAcceleration + paddleAccelerationStep, maxPaddleAcceleration);

              // âœ… NOUVEAU : Vitesse ajustÃ©e selon le scale
              const scaleFactor = getCurrentScaleFactor();
              const adjustedSpeed = (paddleSpeed + paddleAcceleration) * scaleFactor;

              paddleX = Math.max(0, paddleX - adjustedSpeed * dt);

          } else if (rightDown && !leftDown) {
              paddleAcceleration = Math.min(paddleAcceleration + paddleAccelerationStep, maxPaddleAcceleration);

              // âœ… NOUVEAU : Vitesse et limites ajustÃ©es selon le scale
              const scaleFactor = getCurrentScaleFactor();
              const adjustedSpeed = (paddleSpeed + paddleAcceleration) * scaleFactor;
              const limits = getEffectiveCanvasLimits();

              paddleX = Math.min(limits.width - paddleW, paddleX + adjustedSpeed * dt);

          } else {
              paddleAcceleration = 0;
          }
          //Fin de fonction controle_manuel_corrige

      }


      if (decrementActive) {
        // Temps Ã©coulÃ© en secondes rÃ©elles
        let elapsed = (performance.now() - decrementStartTime) / 1000;
        let timeLeft = Math.max(0, decrementTimer - elapsed);

        if (timeLeft <= 0) {
          decrementActive = false;
          decrementEffect = false;
          elDec.style.display = "none";
          playSound("raquettenormale");
        }
      }


      let prevX = ball.x, prevY = ball.y;
      let nextX = ball.x + ballDX * dt, nextY = ball.y + ballDY * dt;
      ball.x=nextX; ball.y=nextY;

      // Collisions murs
      if(ball.x-ball.r<0) {ball.x=ball.r; ballDX=Math.abs(ballDX); playSound("impact");}
      if(ball.x+ball.r>CANVAS_W) {ball.x=CANVAS_W-ball.r; ballDX=-Math.abs(ballDX); playSound("impact");}
      if(ball.y-ball.r<0) {ball.y=ball.r; ballDY=Math.abs(ballDY); playSound("impact");}
      if(Math.abs(ballDX)<2) ballDX=(Math.random()<0.5?-1:1)*2;

      // --- Collision raquette (VERSION HAUTE VITESSE SÃ‰CURISÃ‰E) ---
      if (ballDY > 0) { // La balle doit descendre
          // âœ… DÃ‰TECTION PRÃ‰DICTIVE pour Ã©viter les traversÃ©es
          let nextBallY = ball.y + ballDY * dt;
          let nextBallX = ball.x + ballDX * dt;

          // VÃ©rification collision avec la position prÃ©dite
          if (nextBallY + ball.r >= paddleY &&
              ball.y + ball.r <= paddleY + paddleH &&
              nextBallX + ball.r >= paddleX &&
              nextBallX - ball.r <= paddleX + paddleW) {

              // âœ… REPOSITIONNEMENT SÃ‰CURISÃ‰ avant le rebond
              ball.y = paddleY - ball.r - 1; // Marge de sÃ©curitÃ©
              ball.x = nextBallX; // Conserve le mouvement horizontal

              // âœ… CALCUL DE L'ANGLE DE REBOND (inchangÃ© - fonctionne bien)
              let impactPoint = (ball.x - (paddleX + paddleW / 2)) / (paddleW / 2);
              impactPoint = Math.max(-1, Math.min(1, impactPoint));
              const maxBounceAngle = 5 * Math.PI / 12;
              const newAngle = impactPoint * maxBounceAngle;

              // âœ… VITESSE LIMITÃ‰E pour Ã©viter les bugs
              let speed = Math.sqrt(ballDX * ballDX + ballDY * ballDY);
              let maxSpeed = autopilot ? (baseGameSpeed * 2) : (baseGameSpeed * 2.5);
              speed = Math.min(speed, maxSpeed);

              ballDX = speed * Math.sin(newAngle);
              ballDY = -speed * Math.cos(newAngle);

              playSound("paddle");
          }
      }


      // === MISE Ã€ JOUR DU BOSS (VERSION STABILISÃ‰E) ===
      if (isBossLevel && boss && boss.alive) {
          // âœ… GESTION DE L'ENTRÃ‰E SÃ‰CURISÃ‰E
          if (boss.entrancePhase) {
              boss.y += 1; // Vitesse d'entrÃ©e rÃ©duite
              if (boss.y >= 140) {
                  boss.entrancePhase = false;
                  boss.y = 140;
              }
          } else {
              // âœ… MOUVEMENT HORIZONTAL STABLE
              let moveSpeed = (5 + niveau * 0.2) * dt; // Vitesse trÃ¨s rÃ©duite
              boss.x += boss.direction * moveSpeed;

              // âœ… REBONDS SÃ‰CURISÃ‰S
              if (boss.x <= 0) {
                  boss.x = 0;
                  boss.direction = 1;
              } else if (boss.x + boss.w >= CANVAS_W) {
                  boss.x = CANVAS_W - boss.w;
                  boss.direction = -1;
              }

              // âœ… ATTAQUES CONTRÃ”LÃ‰ES
              bossAttackTimer += elapsed_ms;
              if (bossAttackTimer > boss.attackCooldown) {
                  bossAttack();
                  bossAttackTimer = 0;
              }
          }
      }

      updateGalaxy(dt);


      // === COLLISION AVEC LE BOSS (VERSION SÃ‰CURISÃ‰E) ===
      if (isBossLevel && boss && boss.alive && !bossInvulnerable) {
          // âœ… COLLISION DETECTION AMÃ‰LIORÃ‰E
          let ballRight = ball.x + ball.r;
          let ballLeft = ball.x - ball.r;
          let ballBottom = ball.y + ball.r;
          let ballTop = ball.y - ball.r;

          let bossRight = boss.x + boss.w;
          let bossBottom = boss.y + boss.h;

          if (ballRight > boss.x && ballLeft < bossRight &&
              ballBottom > boss.y && ballTop < bossBottom) {

              // âœ… CALCUL SÃ‰CURISÃ‰ DU REBOND
              let overlapX = Math.min(ballRight - boss.x, bossRight - ballLeft);
              let overlapY = Math.min(ballBottom - boss.y, bossBottom - ballTop);

              if (overlapX < overlapY) {
                  // Collision horizontale
                  ballDX = ball.x < boss.x + boss.w/2 ? -Math.abs(ballDX) : Math.abs(ballDX);
                  ball.x = ball.x < boss.x + boss.w/2 ? boss.x - ball.r : boss.x + boss.w + ball.r;
              } else {
                  // Collision verticale
                  ballDY = ball.y < boss.y + boss.h/2 ? -Math.abs(ballDY) : Math.abs(ballDY);
                  ball.y = ball.y < boss.y + boss.h/2 ? boss.y - ball.r : boss.y + boss.h + ball.r;
              }

              // âœ… DÃ‰GÃ‚TS ET EFFETS (SÃ‰CURISÃ‰S)
              bossHP = Math.max(0, bossHP - 10);
              boss.hitFlash = 10;
              playSound("boss_hit");

              // âœ… INVULNÃ‰RABILITÃ‰ TEMPORAIRE SÃ‰CURISÃ‰E
              bossInvulnerable = true;
              timeoutManager.set('bossInvulnerable', () => {
                  bossInvulnerable = false;
              }, 500);

              // âœ… PARTICULES D'IMPACT
              for (let j = 0; j < 15; j++) {
                  let angle = Math.random() * 2 * Math.PI;
                  let velocity = 3 + Math.random() * 4;
                  particles.push({
                      x: ball.x, y: ball.y,
                      dx: Math.cos(angle) * velocity,
                      dy: Math.sin(angle) * velocity,
                      life: 20, color: "#ff0"
                  });
              }

              // âœ… VÃ‰RIFICATION DE DÃ‰FAITE DU BOSS
              if (bossHP <= 0) {
                  boss.alive = false;
                  bossDefeated = true;
                  playSound("boss_death");

                  // RÃ©compenses

                  score += 20000 * niveau;
                  cookies += 3;
                  vies += 1;

                  // âœ… NOUVEAU : Animation du gain qui monte vers le score
                  showScoreBonusAnim(boss.x + boss.w/2, boss.y + boss.h/2, 20000 * niveau);

                  updateHUD();

                  // Animation de victoire
                  for (let i = 0; i < 30; i++) {
                      timeoutManager.set(`bossVictory${i}`, () => {
                          particles.push({
                              x: boss.x + Math.random() * boss.w,
                              y: boss.y + Math.random() * boss.h,
                              dx: (Math.random() - 0.5) * 8,
                              dy: (Math.random() - 0.5) * 8,
                              life: 40,
                              color: COLORS[Math.floor(Math.random() * COLORS.length)]
                          });
                      }, i * 30);
                  }
              }
          }
      }


      // Collision briques
      for(let i=0;i<bricks.length;i++) {
        let b=bricks[i];
        if(!b.alive) continue;
        if(ball.x+ball.r>b.x && ball.x-ball.r<b.x+b.w && ball.y+ball.r>b.y && ball.y-ball.r<b.y+b.h) {
          b.alive=false;

          if (autopilot && lastTargetBrick === b) {
              // SuccÃ¨s ! On mÃ©morise cette stratÃ©gie
              shotHistory.push({
                  targetBrick: b,
                  paddlePosition: paddleX,
                  ballPosition: {x: ball.x, y: ball.y},
                  hit: true,
                  timestamp: performance.now()
              });

              // Nettoyer l'historique (garder seulement les 10 derniers)
              if (shotHistory.length > 10) {
                  shotHistory.shift();
              }
          } else if (autopilot && lastTargetBrick && lastTargetBrick.alive) {
              // RatÃ© ! On mÃ©morise l'Ã©chec pour ajuster
              shotHistory.push({
                  targetBrick: lastTargetBrick,
                  paddlePosition: paddleX,
                  ballPosition: {x: ball.x, y: ball.y},
                  hit: false,
                  timestamp: performance.now()
              });
          }

          // Reset des variables de ciblage
          lastTargetBrick = null;
          lastPaddleTarget = 0;


          bricksHit++; // IncrÃ©mentation ici
          playSound("impact");
          // --- Collision briques (vÃ©rification de l'appel) ---
          // Collision briques (vers ligne 1000)

        if (decrementEffect) {
          // Si le malus est actif, on applique la pÃ©nalitÃ©.
          let penalty = 100 * mult;
          score -= penalty;
          showScoreDecrementAnim(b.x + b.w / 2, b.y + b.h / 2, penalty);
        } else {
          // Le gain de points normal...
          let brickPoints = 100 * mult;
          score += brickPoints;
          updateStatsPanel();

          // âœ… NOUVEAU : Son de piÃ¨ces pour les hauts scores
          if (brickPoints >= 200) {  // 200+ points (multiplicateur x2 minimum)
            playSound("coins");
          } else {
            playSound("impact");  // Son normal pour les briques de base
          }

          showScoreBonusAnim(b.x + b.w / 2, b.y + b.h / 2, brickPoints);
        }

          for(let j=0;j<16;j++) {
            let a=Math.random()*2*Math.PI, v=2+Math.random()*3;
            particles.push({x:ball.x,y:ball.y,dx:Math.cos(a)*v,dy:Math.sin(a)*v,life:16,color:COLORS[b.colorIdx%COLORS.length]});
          }
          if(b.special) {
            if(b.special === "â˜ ï¸") {
              spawnSkull(b);
            } else {
              spawnPowerup(b);
            }
          }

          bricksHit++; // IncrÃ©ment pour calcul de vitesse
          updateBallSpeed(); // Mise Ã  jour progressive de la vitesse

          // Conservation de la direction pour le rebond
          let dir = Math.atan2(ballDY, ballDX);
          ballDX = Math.cos(dir) * currentGameSpeed;
          ballDY = Math.sin(dir) * currentGameSpeed;

          if(Math.abs(ball.x-(b.x+b.w/2))>Math.abs(ball.y-(b.y+b.h/2))) ballDX*=-1;
          else ballDY*=-1;
          break;
        }
      }

      // --- Boucle de collecte des power-ups (CORRIGÃ‰E DÃ‰FINITIVEMENT) ---
      powerups.forEach(p => {
          // âœ… NOUVEAU : Validation de sÃ©curitÃ© pour Ã©viter les crashes
          if (!p || typeof p.y === 'undefined') {
              p.caught = true; // Marquer pour suppression
              return;
          }

          // âœ… MOUVEMENT SÃ‰CURISÃ‰ POUR TOUS LES PROJECTILES
          if (p.type === "boss_projectile") {
              // Mouvement vertical standard
              p.y += p.speed * dt;

              // Mouvement horizontal pour les projectiles en Ã©ventail
              if (p.dx && typeof p.dx === 'number') {
                  p.x += p.dx * dt * 0.5; // Vitesse rÃ©duite pour l'horizontal
              }

              // âœ… HOMING SÃ‰CURISÃ‰ ET PRÃ‰VISIBLE
              if (p.homing && p.y < paddleY + 100 && p.y > 50) {
                  let targetX = paddleX + paddleW / 2;
                  let deltaX = targetX - p.x;

                  // Vitesse de correction trÃ¨s rÃ©duite pour Ã©viter les oscillations
                  let correctionSpeed = Math.min(Math.abs(deltaX) * 0.02, 30 * dt);
                  let direction = deltaX > 0 ? 1 : -1;

                  p.x += direction * correctionSpeed;
              }
          } else {
              // Mouvement normal pour les autres powerups
              p.y += p.speed * dt;
          }

          // âœ… DISPARITION AVEC MARGE Ã‰TENDUE
          if (p.y > CANVAS_H + 100 || p.x < -100 || p.x > CANVAS_W + 100) {
              p.caught = true;
              return;
          }

          // âœ… COLLISION AMÃ‰LIORÃ‰E ET SÃ‰CURISÃ‰E
          if (p.y + 10 >= paddleY && p.y - 10 <= paddleY + paddleH &&
              p.x + 10 >= paddleX && p.x - 10 <= paddleX + paddleW) {

              p.caught = true;

              // âœ… GESTION DES PROJECTILES DE BOSS (CORRIGÃ‰E)
              if (p.type === "boss_projectile") {
                  // DÃ©gÃ¢ts au joueur
                  vies = Math.max(0, vies - 1);
                  playSound("mort");

                  // Effet visuel de dÃ©gÃ¢ts
                  for (let j = 0; j < 15; j++) {
                      let a = Math.random() * 2 * Math.PI, v = 4 + Math.random() * 6;
                      particles.push({
                          x: p.x, y: p.y,
                          dx: Math.cos(a) * v, dy: Math.sin(a) * v,
                          life: 20, color: "#f00"
                      });
                  }

                  // âœ… NOUVEAU : Effet de flash rouge sur la raquette
                  timeoutManager.set('paddleDamageFlash', () => {
                    // Rien Ã  faire, juste pour crÃ©er un dÃ©lai visuel
                  }, 200);

                  updateHUD();

                  // VÃ©rifier game over
                  if (vies <= 0) {
                      gameOver = true;
                      setTimeout(() => showEndPanel(), 400);
                  }

                  return; // âœ… IMPORTANT : sortir immÃ©diatement
              }

              // âœ… GESTION DES POWERUPS NORMAUX (inchangÃ©e)
              if (decrementEffect) {
                  playSound("mort");
                  let penalty = 1000;
                  score -= penalty;
                  showScoreDecrementAnim(p.x, p.y, penalty);
              } else {
                  playSound("powerup");
                  handleIconImpact({
                      icon: p.icon,
                      x: p.x,
                      y: p.y,
                      size: 20,
                      color: p.color || "#fff",
                      type: p.type
                  });
              }
          }
      });

      // âœ… FILTRAGE SÃ‰CURISÃ‰
      powerups = powerups.filter(p => p && !p.caught);



      // --- Boucle de collecte des bonus (CORRIGÃ‰E DÃ‰FINITIVEMENT) ---
      bonuses.forEach(b => {
        b.y += b.speed * dt;

        if (b.y > CANVAS_H) b.caught = true;

        if (b.y > paddleY && b.x > paddleX && b.x < paddleX + paddleW && b.y < paddleY + paddleH) {

          if (b.type === "cookie") {
                cookies++; // On ajoute un cookie
                playSound("life2");
          }
          if (b.type === "vie") {
                vies++; // On ajoute une vie
                playSound("life2");
          }
          if (b.type === "niveau") {
              if (isBossLevel && boss) {
                  boss.alive = false;
                  bossDefeated = true;
                  bossHP = 0;
                }
                bricks.forEach(b => b.alive = false);
                vies++; // On ajoute une vie
                //levelComplete = true
//              playSound("life2");
                playSound("boss_death");
          }


          // âœ… AJOUT : Comptage des bonus collectÃ©s
          if (bonusesCaptured[b.emoji] !== undefined) {
            bonusesCaptured[b.emoji]++;
          }

          b.caught = true;
          updateHUD();

          bonuses = bonuses.filter(b => !b.caught);

          if (decrementEffect) {
            // Si le malus est actif, on applique la pÃ©nalitÃ©.
            playSound("mort");
            let penalty = b.points;

            // ** LA CORRECTION EST ICI : "sscore" a Ã©tÃ© remplacÃ© par "score" **
            score -= penalty;

            showScoreDecrementAnim(b.x, b.y, penalty);

          } else {
              // Sinon, on gagne les points normalement (multiplicateur inclus).
              playSound("bonus");
              let finalPoints = b.points * mult;

              // âœ… CORRECTION : Ajouter les points immÃ©diatement
              score += finalPoints;

              // Animation visuelle (sans dÃ©lai pour les points)
              showScoreBonusAnim(b.x, b.y, finalPoints);

          }
        }
      });
      bonuses = bonuses.filter(b => !b.caught);



      // Skulls (â˜ ï¸)
      skulls.forEach(s=>{
        s.y+=s.speed*dt;
        if(s.y>CANVAS_H) s.caught=true;
        if(s.y>paddleY && s.x>paddleX && s.x<paddleX+paddleW && s.y<paddleY+paddleH) {
          s.caught=true;
          playSound("mort");
          handleIconImpact({
            icon: s.icon,
            x: s.x,
            y: s.y,
            size: 20,
            color: "#fff",
            type: "skull"
          });
          startDecrement();
        }
      });
      skulls = skulls.filter(s=>!s.caught);

      animations.forEach(a => {
        let t = 1 - a.frames/36;
//        let cx = a.x + (CANVAS_W-600 - a.x)*t + Math.sin(t*3)*22;
//        let cy = a.y + (60 - a.y)*t - Math.sin(t*Math.PI)*18;

        let cx = a.x + (a.targetX - a.x) * t;
        let cy = a.y + (a.targetY - a.y) * t;

        ctx.save();
        ctx.translate(cx, cy);
        ctx.rotate(Math.sin(t*5)*0.4);
        ctx.font = a.size + "px "+EMOJI_FONT;
        ctx.globalAlpha = 0.9 - t*0.5;
        ctx.shadowColor = a.color;
        ctx.shadowBlur = 10 + 10*Math.abs(Math.sin(t*6));
        ctx.fillStyle = a.color;
        ctx.fillText(a.icon, 0, 0);
        ctx.shadowBlur=0;
        if (a.frames < 10) {
          for(let k=0;k<8;k++) {
            ctx.save();
            ctx.globalAlpha = 0.18 + 0.12*Math.sin(performance.now()/80 + k);
            ctx.beginPath();
            ctx.arc(a.targetX + Math.cos(k*Math.PI/4)*18, a.targetY + Math.sin(k*Math.PI/4)*18, 3, 0, 2*Math.PI);
            ctx.fillStyle = COLORS[k%COLORS.length];
            ctx.shadowColor = COLORS[k%COLORS.length];
            ctx.shadowBlur = 8;
            ctx.fill();
            ctx.restore();
          }
        }
        if (a.frames < 10) {
          for(let k=0;k<2;k++) {
            ctx.save();
            ctx.globalAlpha = 0.22 + 0.12*Math.sin(performance.now()/80 + k);
            ctx.beginPath();
            ctx.arc(a.targetX, a.targetY, 22+6*k+a.frames*1.2, 0, 2*Math.PI);
            ctx.strokeStyle = k%2===0 ? "#ff0" : "#fff";
            ctx.lineWidth = 1.5+k;
            ctx.shadowColor = k%2===0 ? "#ff0" : "#fff";
            ctx.shadowBlur = 8;
            ctx.stroke();
            ctx.restore();
          }
        }
        ctx.restore();
        a.frames--;
      });
      animations = animations.filter(a => a.frames > 0);

      if (mult > 1) {
        // On dÃ©crÃ©mente le minuteur en utilisant les secondes rÃ©elles.
        multTimer -= elapsed_ms / 1000;

        if (multTimer <= 0) {
          mult = 1;
          multTimer = 0;
        }
      }
      updateMultDisplay(mult);

      particles.forEach(p=>{
        p.x+=p.dx; p.y+=p.dy; p.life--;
      });
      particles = particles.filter(p=>p.life>0);

      // NOUVEAU MOTEUR D'ANIMATION DU SCORE (GÃ¨re correctement les nombres nÃ©gatifs)
      const scoreDifference = score - displayScore;

      // On anime le score s'il y a un Ã©cart significatif (l'animation fluide est conservÃ©e)
      if (Math.abs(scoreDifference) > 0.5) {
        displayScore += scoreDifference * 0.08; // Vitesse de l'animation
        elScore.classList.add("flash");
      } else {
        // Si l'animation est terminÃ©e, on s'assure que la valeur est exacte et on arrÃªte le flash.
        displayScore = score;
        elScore.classList.remove("flash");
      }

      // --- NOUVELLE LOGIQUE D'AFFICHAGE ROBUSTE (LA CORRECTION FINALE) ---
      let scoreToDisplay = Math.round(displayScore);

      if (scoreToDisplay >= 0) {
        // Si le score est POSITIF ou nul, on utilise la mÃ©thode classique.
        elScore.textContent = scoreToDisplay.toString().padStart(9, "0");
      } else {
        // Si le score est NÃ‰GATIF :
        // 1. On prend la valeur absolue du score (ex: -5000 -> 5000).
        let positiveValue = Math.abs(scoreToDisplay);

        // 2. On la formate sur 8 caractÃ¨res pour laisser de la place au signe "-".
        let paddedScore = positiveValue.toString().padStart(8, "0");

        // 3. On ajoute manuellement le signe "-" au dÃ©but.
        elScore.textContent = "-" + paddedScore;
      }


      if(ball.y-ball.r>CANVAS_H) {
        vies--; mult = 1; multTimer = 0;

        playSound("life");

        ballSpeed = ballSpeed0;

        if(vies<=0) {
          gameOver=true;
          elapsedTime = Math.floor((Date.now() - startTime) / 1000);
          setTimeout(()=>showEndPanel(),400);
        }
        else resetBall();
        updateHUD();
      }

      // === CONDITION DE VICTOIRE Ã‰QUILIBRÃ‰E ===
      // === CONDITION DE VICTOIRE Ã‰QUILIBRÃ‰E AVEC DÃ‰LAI ===
      levelComplete = false;

      if (isBossLevel) {
          // BOSS : VÃ©rifications complÃ¨tes et sÃ©curisÃ©es
          levelComplete = boss &&
                         !boss.alive &&
                         bossDefeated &&
                         bricks.every(b => !b.alive) &&
                         bossHP <= 0;
      } else {
          // NIVEAU NORMAL : Juste les briques
          levelComplete = bricks.every(b => !b.alive);
      }

      // âœ… NOUVEAU : Gestion de la transition avec dÃ©lai
      if (levelComplete && !levelTransition) {
          // âœ… 1. DÃ‰MARRER LA TRANSITION
          levelTransition = true;
          levelTransitionTimer = performance.now();

          // âœ… 2. MESSAGE DE TRANSITION SELON LE TYPE DE NIVEAU
          if (isBossLevel) {
              levelTransitionMessage = `ğŸ† BOSS VAINCU ! ğŸ†\n\nNiveau ${niveau + 1} dans 3...`;
              playSound("boss_death");
          } else {
              levelTransitionMessage = `âœ… NIVEAU ${niveau} TERMINÃ‰ !\n\nProchain niveau dans 3...`;
              playSound("coins");
          }

          // âœ… 3. ARRÃŠTER LA BALLE TEMPORAIREMENT
          ballDX = 0;
          ballDY = 0;

          console.log(`ğŸ¯ Transition dÃ©marrÃ©e : ${levelTransitionMessage}`);
      }

      // âœ… 4. GESTION DU DÃ‰LAI DE TRANSITION
      // âœ… 4. GESTION DU DÃ‰LAI DE TRANSITION
      if (levelTransition) {
          let elapsed = performance.now() - levelTransitionTimer;
          let secondsLeft = Math.ceil((levelTransitionDelay - elapsed) / 1000);

          // âœ… Mise Ã  jour du message avec compte Ã  rebours
          if (isBossLevel) {
              levelTransitionMessage = `ğŸ† BOSS VAINCU ! ğŸ†\n\nNiveau ${niveau + 1} dans ${secondsLeft}...`;
              // âœ… CORRECTION : Vies supprimÃ©es d'ici - elles sont dÃ©jÃ  ajoutÃ©es ailleurs
          } else {
              levelTransitionMessage = `âœ… NIVEAU ${niveau} TERMINÃ‰ !\n\nProchain niveau dans ${secondsLeft}...`;
          }

          // âœ… 5. FIN DE LA TRANSITION - PASSAGE AU NIVEAU SUIVANT
          if (elapsed >= levelTransitionDelay) {
              levelTransition = false;
              levelTransitionMessage = "";

              // âœ… 6. SAUVEGARDE DE L'Ã‰TAT ACTUEL
              let wasIsBossLevel = isBossLevel;

              // âœ… 7. PROGRESSION DU NIVEAU (CODE EXISTANT)
              niveau++;
              clearAllTimersEndLevel();
              changeGalaxyConfiguration();
              levelsPassed++;
              vies += 1;

              // âœ… 8. GESTION DES OFFSETS (ORDRE CORRIGÃ‰)
              wallOffset += 3;
              wallOffsetPlus += 3;

              if (wallOffsetPlus >= 10) {
                  brickRows = Math.min(12, brickRows + 1);
                  wallOffsetPlus = 0;
              }

              // âœ… 9. NETTOYAGE COMPLET (AVANT LA CRÃ‰ATION)
              if (wasIsBossLevel) {
                  // Nettoyage spÃ©cifique boss
                  timeoutManager.clear('bossInvulnerable');
                  for (let i = 0; i < 50; i++) {
                      timeoutManager.clear(`bossVictory${i}`);
                  }

                  // Reset des variables boss
                  isBossLevel = false;
                  boss = null;
                  bossDefeated = false;
                  bossHP = 0;
                  bossInvulnerable = false;
                  bossAttackTimer = 0;
                  bossMovementTimer = 0;
              }

              // Nettoyage gÃ©nÃ©ral
              clearAllTimersEndLevel();

              // âœ… 10. CRÃ‰ATION DU PROCHAIN NIVEAU
              if (niveau % 5 === 0) {
                  createBoss();
              } else {
                  createBricks();
              }

              // âœ… 11. FINALISATION
              resetBall();
              updateHUD();

              // âœ… 12. BONUS (PROBABILITÃ‰ Ã‰QUILIBRÃ‰E)
              if (Math.random() < 0.60) {
                  spawnBonus();
              }

              console.log(`ğŸš€ Niveau ${niveau} dÃ©marrÃ© !`);
          }
      }

      // âœ… 8. BONUS CONTINU (FRÃ‰QUENCE RÃ‰DUITE POUR Ã‰VITER LE SPAM)
      if (Math.random() < 0.002 && bonuses.length < 2) { // 0.003 -> 0.002
          spawnBonus();
      }
    }


    // âœ… SYSTÃˆME D'INTERPOLATION POUR UNE FLUIDITÃ‰ PARFAITE
    function smoothMovement(object, targetX, targetY, smoothingFactor = 0.15) {
        if (!object.smooth) {
            object.smooth = { lastX: object.x, lastY: object.y };
        }

        // Interpolation linÃ©aire vers la cible
        object.x = object.smooth.lastX + (targetX - object.smooth.lastX) * smoothingFactor;
        object.y = object.smooth.lastY + (targetY - object.smooth.lastY) * smoothingFactor;

        // Mise Ã  jour des positions prÃ©cÃ©dentes
        object.smooth.lastX = object.x;
        object.smooth.lastY = object.y;
    }



    // --- Fonctions utilitaires pour powerups, bonus, effets, etc. ---

    function spawnPowerup(b) {
      let x=b.x+b.w/2, y=b.y+b.h/2;
      let icon=b.special, type=null;
      let color="#fff";
      if(icon==="ğŸ³ï¸") type="long";  // âœ… CORRIGÃ‰
      if(icon==="ğŸ´â€â˜ ï¸") type="short";
      if(icon==="1ï¸âƒ£") type="mult1";  // âœ… CORRIGÃ‰
      if(icon==="2ï¸âƒ£") type="mult2";
      if(icon==="4ï¸âƒ£") type="mult4";
      if(icon==="8ï¸âƒ£") type="mult8";
      if(icon==="ğŸ”Ÿ") type="mult10";
      if(icon==="â¤ï¸â€ğŸ”¥") type="huge";
      powerups.push({
        x, y, icon, type, color, speed:6+Math.random()*2, caught:false, drop:true
      });
    }

    function spawnSkull(b) {
      let x=b.x+b.w/2, y=b.y+b.h/2;
      skulls.push({
        x, y, icon:"â˜ ï¸", speed:7+Math.random()*2, caught:false
      });
    }


    function startDecrement() {
      decrementTimer = 30; // durÃ©e en secondes
      decrementActive = true;
      decrementEffect = true;
      decrementStartTime = performance.now(); // horodatage prÃ©cis
//      elDec.textContent = "â˜ ï¸ SCORE - (30s)";
//      elDec.style.display = "block";
    }


    /**
     * Affiche une animation de perte de score Ã  l'Ã©cran.
     * VERSION CORRIGÃ‰E : Ne contient plus d'erreurs de syntaxe et vise le compteur de score.
     */
    function showScoreDecrementAnim(x, y, points) {
      // --- Cible de l'animation de perte de points ---
      // On rÃ©cupÃ¨re la position du compteur de score pour que l'animation s'y dirige.
      const scoreEl = document.getElementById('score');
      const rect = scoreEl.getBoundingClientRect();
      const canvasRect = canvas.getBoundingClientRect();
      const targetX = rect.left + rect.width / 2 - canvasRect.left;
      const targetY = rect.top + rect.height / 2 - canvasRect.top;

      animations.push({
        icon: "-" + points, // Affiche le montant correct de la pÃ©nalitÃ©
        x: x,
        y: y,
        size: 24,         // Un peu plus grand pour Ãªtre bien visible
        targetX: targetX, // Cible le compteur de score (corrigÃ©)
        targetY: targetY, // Cible le compteur de score (corrigÃ©)
        frames: 30,       // Une animation lÃ©gÃ¨rement plus longue
        color: "#ff4444"  // Couleur rouge distinctive pour les malus
      });
    }




    function showScoreBonusAnim(x, y, pts) {
      const scoreEl = document.getElementById('score');
      const rect = scoreEl.getBoundingClientRect();
      const canvasRect = canvas.getBoundingClientRect();
      const targetX = rect.left + rect.width / 2 - canvasRect.left;
      const targetY = rect.top + rect.height / 2 - canvasRect.top;
      animations.push({
        icon: "+" + pts,
        x: x,
        y: y,
        size: 20,
        targetX: targetX,
        targetY: targetY,
        frames: 26,
        color: "#ff0"
      });
    }


    function applyPowerup(p) {


      if (p.type === "long") {
          // âœ… ANNULATION de l'effet prÃ©cÃ©dent
          if (paddleSizeEffect !== null) {
              timeoutManager.clear('paddleSize');
          }

          paddleSizeEffect = "long";
          paddleOriginalSize = paddleBaseW; // âœ… Toujours partir de la base
          paddleW = Math.min(320, paddleOriginalSize + 70);

          timeoutManager.set('paddleSize', () => {
              paddleW = paddleOriginalSize; // âœ… Retour Ã  la taille de base
              paddleSizeEffect = null;
              playSound("raquettenormale");
          }, 30000);
      }


      if (p.type === "short") {
          // âœ… ANNULATION de l'effet prÃ©cÃ©dent
          if (paddleSizeEffect !== null) {
              timeoutManager.clear('paddleSize');
          }

          playSound("mort");
          paddleSizeEffect = "short";
          paddleOriginalSize = paddleBaseW; // âœ… Toujours partir de la base
          paddleW = Math.max(50, paddleOriginalSize - 60);

          timeoutManager.set('paddleSize', () => {
              paddleW = paddleOriginalSize; // âœ… Retour Ã  la taille de base
              paddleSizeEffect = null;
              playSound("raquettenormale");
          }, 30000);
      }



      if (p.type && p.type.startsWith("mult")) {
        let val = parseInt(p.type.replace("mult", ""));
        mult = Math.min(mult + val, multMax);
        multTimer += 30; // Si gÃ©rÃ© par un interval ailleurs, assurez-vous de le clearer si needed
      }

      if (p.type === "cookie") { // Correction : b.type -> p.type (assuming typo)
        cookies++;
        updateHUD();
        playSound("life2");
      }

      if (p.type === "huge") {
          // âœ… ANNULATION de l'effet prÃ©cÃ©dent
          if (paddleSizeEffect !== null) {
              timeoutManager.clear('paddleSize');
          }
          if (paddleHugeTimeout) {
              clearTimeout(paddleHugeTimeout);
              paddleHugeTimeout = null;
          }

          paddleSizeEffect = "huge";
          paddleOriginalSize = paddleBaseW; // âœ… Toujours partir de la base
          paddleTimer = 10;
          paddleTimerActive = true;

          // âœ… CALCUL BASÃ‰ SUR LA TAILLE DE BASE, pas la taille actuelle
          paddleW = Math.min(CANVAS_W - 40, paddleOriginalSize * 2.5);

          paddleHugeTimeout = setTimeout(() => {
              paddleW = paddleOriginalSize; // âœ… Retour Ã  la taille de base
              paddleSizeEffect = null;
              paddleTimerActive = false;
              paddleHugeTimeout = null;
              playSound("raquettenormale");
          }, 15000);

        // GÃ©nÃ©ration de particules (inchangÃ©)
        for (let j = 0; j < 36; j++) {
          let a = Math.random() * 2 * Math.PI, v = 5 + Math.random() * 8;
          particles.push({x: paddleX + paddleW / 2, y: paddleY, dx: Math.cos(a) * v, dy: Math.sin(a) * v, life: 30, color: "#f55"});
        }
      }

    }


    function spawnBonus() {
      let b = BONUS_ICONS[Math.floor(Math.random()*BONUS_ICONS.length)];
      bonuses.push({
        x: Math.random()*(CANVAS_W-120)+60,
        y: wallOffset+30,
        emoji: b.emoji,
        points: b.points,
        color: b.color,
        type: b.type, // <-- LA LIGNE MANQUANTE EST ICI
        speed: 7+Math.random()*2,
        caught: false
      });
    }


    function handleIconImpact(obj) {
      try {
        // RÃ©cupÃ©rer l'Ã©lÃ©ment score avec check d'existence
        const scoreEl = document.getElementById('score');
        if (!scoreEl) {
          console.warn("Ã‰lÃ©ment 'score' non trouvÃ© â€“ animation ignorÃ©e");
          return; // Sortir tÃ´t pour Ã©viter erreurs
        }

        const rect = scoreEl.getBoundingClientRect();
        const canvasRect = canvas.getBoundingClientRect();

        // Calculer la position cible relative au canvas
        const targetX = rect.left + rect.width / 2 - canvasRect.left;
        const targetY = rect.top + rect.height / 2 - canvasRect.top;

        // IncrÃ©menter le compteur avec check
        if (!powerupsCaptured[obj.type]) powerupsCaptured[obj.type] = 0;
        powerupsCaptured[obj.type]++;

        // CrÃ©er l'animation
        let anim = {
          icon: obj.icon,
          x: obj.x,
          y: obj.y,
          size: obj.size,
          targetX: targetX,
          targetY: targetY,
          frames: 36,
          color: obj.color || "#fff"
        };
        animations.push(anim);

        // GÃ©rer le dÃ©lai avec un timeout annulable si needed (stockÃ© globalement si plusieurs impacts)
        if (impactTimeout) clearTimeout(impactTimeout);
        // âœ… CORRECTION : Timeout sÃ©parÃ© pour chaque impact
        let timeoutKey = `impact_${Date.now()}_${Math.random()}`;
        timeoutManager.set(timeoutKey, () => {
          if (obj.points && obj.points > 0) {
            score += obj.points;
          }
          if (obj.type && obj.type !== "skull") {
            applyPowerup(obj);
          }
        }, 400);

      } catch (error) {
        console.error("Erreur dans handleIconImpact :", error);
        // Continuer sans crash pour ne pas bloquer le jeu
      }
    }


    // === SCORE FINAL, TEMPS, STATS, MEILLEUR SCORE ===

    function getBestScore() {
      return parseInt(localStorage.getItem("akranoid_best_score") || "0");
    }
    function setBestScore(val) {
      localStorage.setItem("akranoid_best_score", val);
    }

    function startPsychedelicBg() {
      const canvas = document.getElementById('psyCanvas');
      if (!canvas) return;
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      const ctx = canvas.getContext('2d');
      let t = 0;

      function draw() {
        ctx.clearRect(0,0,canvas.width,canvas.height);
        let w = canvas.width, h = canvas.height;
        let cx = w/2, cy = h/2;
        for (let i=0; i<18; i++) {
          let angle = (t*0.03) + i*Math.PI/9;
          let r = 180 + 80*Math.sin(t*0.02+i);
          let x = cx + Math.cos(angle)*r;
          let y = cy + Math.sin(angle)*r;
          let size = 110 + 10*Math.sin(t*0.07+i*1.3);
          let color = `hsl(${(t*4+i*20)%360},95%,60%)`;
          ctx.save();
          ctx.globalAlpha = 0.21 + 0.18*Math.sin(t*0.09+i);
          ctx.translate(x, y);
          ctx.rotate(angle + Math.sin(t*0.04+i)*1.2);
          ctx.beginPath();
          ctx.arc(0, 0, size, 0, 2*Math.PI);
          ctx.fillStyle = color;
          ctx.shadowColor = color;
          ctx.shadowBlur = 40;
          ctx.fill();
          ctx.restore();
        }
        t++;
        psyAnimId = requestAnimationFrame(draw);
      }
      draw();
    }


    function stopPsychedelicBg() {
        if (typeof psyAnimId !== 'undefined' && psyAnimId) {
            cancelAnimationFrame(psyAnimId);
            psyAnimId = null;
        }
        const canvas = document.getElementById('psyCanvas');
        if (canvas) {
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }
    }

    function bossAttack() {
        if (!boss || !boss.alive || bossInvulnerable) return;

        let attackType = Math.random();

        if (bossPhase === 1) {
            // Phase 1 : Attaques simples
            if (attackType < 0.7) {
                bossFireProjectile();
            } else {
                bossSpawnEnemyBricks();
            }
        } else if (bossPhase === 2) {
            // Phase 2 : Attaques plus variÃ©es
            if (attackType < 0.4) {
                bossFireProjectile();
            } else if (attackType < 0.7) {
                bossSpawnEnemyBricks();
            } else {
                bossFireSpread();
            }
        } else {
            // Phase 3 : Attaques dÃ©vastatrices
            if (attackType < 0.3) {
                bossFireProjectile();
            } else if (attackType < 0.5) {
                bossFireSpread();
            } else if (attackType < 0.8) {
                bossRainAttack();
            } else {
                bossSpawnSkulls();
            }
        }
    }

    function bossFireProjectile() {
        // âœ… VALIDATION STRICTE
        if (!boss || !boss.alive || bossInvulnerable) return;

        // âœ… PROJECTILE AVEC MOUVEMENT ALÃ‰ATOIRE
        let randomAngle = (Math.random() - 0.5) * 0.4; // Variation d'angle Â±0.2 radians
        let speedVariation = 8 + Math.random() * 12; // âœ… VITESSE RÃ‰DUITE : entre 8 et 20

        powerups.push({
            x: boss.x + boss.w/2,
            y: boss.y + boss.h + 10,
            icon: "ğŸ’¥",
            type: "boss_projectile",
            color: "#f00",
            speed: speedVariation,
            caught: false,
            drop: true,
            homing: false,
            dx: Math.sin(randomAngle) * speedVariation * 0.3,  // âœ… NOUVEAU : DÃ©rive horizontale alÃ©atoire
            dy: Math.cos(randomAngle) * speedVariation,        // âœ… NOUVEAU : Vitesse verticale variable
            wobble: Math.random() * 2,                         // âœ… NOUVEAU : Facteur d'oscillation
            wobbleSpeed: 0.1 + Math.random() * 0.1,            // âœ… NOUVEAU : Vitesse d'oscillation
            age: 0                                             // âœ… NOUVEAU : Ã‚ge du projectile pour animations
        });
        playSound("impact");
    }



    function bossFireSpread() {
        // âœ… VALIDATION STRICTE
        if (!boss || !boss.alive || bossInvulnerable) return;

        // âœ… TIR EN Ã‰VENTAIL SIMPLIFIÃ‰
        for (let i = -1; i <= 1; i++) {
            powerups.push({
                x: boss.x + boss.w/2 + i * 25,
                y: boss.y + boss.h + 10,
                icon: "â­",
                type: "boss_projectile",
                color: "#fa0",
                speed: 35,
                caught: false,
                drop: true,
                homing: false,
                dx: i * 25, // Direction horizontale simple
                dy: 35     // Direction verticale simple
            });
        }
        playSound("powerup");
    }

    function bossRainAttack() {
        // Pluie de projectiles
        for (let i = 0; i < 8; i++) {
            setTimeout(() => {
                powerups.push({
                    x: Math.random() * (CANVAS_W - 40) + 20,
                    y: -20,
                    icon: "ğŸ’€",
                    type: "boss_projectile",
                    color: "#f0f",
                    speed: 10 + niveau * 0.8,
                    caught: false,
                    drop: true
                });
            }, i * 100);
        }
        playSound("mort");
    }

    function bossSpawnEnemyBricks() {
        // CrÃ©e des briques ennemies qui bougent
        let newBrickX = boss.x + (Math.random() - 0.5) * 200;
        newBrickX = Math.max(0, Math.min(CANVAS_W - brickW, newBrickX));

        bricks.push({
            x: newBrickX,
            y: boss.y + boss.h + 20,
            w: brickW,
            h: brickH,
            finalX: newBrickX,
            finalY: boss.y + boss.h + 20,
            colorIdx: 0,
            special: Math.random() < 0.4 ? "â˜ ï¸" : null,
            alive: true,
            animFrame: 36,
            animAngle: 0,
            animating: false,
            isBossMinion: true,
            moveSpeed: 30,
            moveDirection: Math.random() < 0.5 ? -1 : 1
        });
    }

    function bossSpawnSkulls() {
        // Phase 3 : Spawn direct de skulls
        for (let i = 0; i < 3; i++) {
            skulls.push({
                x: Math.random() * (CANVAS_W - 40) + 20,
                y: boss.y + boss.h,
                icon: "â˜ ï¸",
                speed: 100 + Math.random() * 50,
                caught: false
            });
        }
        playSound("mort");
    }


    function showEndPanel() {
        // Animation psychÃ©dÃ©lique
        // âœ… NOUVEAU : Application du scale avant affichage
        applyEndPanelScale();
        document.getElementById('TITRE').innerHTML = "--- GAME OVER ---<br><br>";
        const finalScoreEl = document.getElementById('finalScore');
        finalScoreEl.textContent = "SCORE : " + score.toLocaleString();
        finalScoreEl.classList.add('flashy-score');

        // Statistiques du jeu
        document.getElementById('bricksHit').textContent = "Briques touchÃ©es : " + bricksHit;
        document.getElementById('levelsPassed').textContent = "Tableaux passÃ©s : " + levelsPassed;
        let min = Math.floor(elapsedTime/60), sec = elapsedTime%60;
        document.getElementById('timePlayed').textContent = "Temps de jeu : " + min + "m " + sec + "s";

        let details = Object.entries(powerupsCaptured)
            .map(([k, v]) => v > 0 ? k + " : " + v : null)
            .filter(Boolean)
            .join("<br>");
        document.getElementById('powerupDetails').innerHTML = "Power-ups capturÃ©s :<br><br>" + (details || "Aucun");

        // âœ… NOUVEAU : Gestion des records
        let playerNameSection = document.getElementById('playerNameSection');
        let leaderboardSection = document.getElementById('leaderboardSection');
        let saveScoreBtn = document.getElementById('saveScoreBtn');
        let skipSaveBtn = document.getElementById('skipSaveBtn');
        let playerNameInput = document.getElementById('playerNameInput');

        // VÃ©rifier si c'est un nouveau record
        if (isNewRecord(score)) {
            // âœ… NOUVEAU RECORD : Demander le nom
            playerNameSection.style.display = 'block';
            leaderboardSection.style.display = 'none';

            // Focus sur l'input
            setTimeout(() => {
                playerNameInput.focus();
                playerNameInput.select();
            }, 500);

            // âœ… GESTION DE LA SAISIE
            let scoreSaved = false;

            // Fonction de sauvegarde
            function saveScore() {
                if (scoreSaved) return;
                scoreSaved = true;

                let playerName = playerNameInput.value.trim() || "JOUEUR";
                addScoreToLeaderboard(playerName, score);

                // Masquer la saisie et afficher le classement
                playerNameSection.style.display = 'none';
                leaderboardSection.style.display = 'block';
                displayLeaderboard();

                playSound("bonus"); // Son de confirmation
            }

            // âœ… Ã‰VÃ‰NEMENTS
            saveScoreBtn.onclick = saveScore;
            skipSaveBtn.onclick = () => {
                if (scoreSaved) return;
                scoreSaved = true;
                playerNameSection.style.display = 'none';
                leaderboardSection.style.display = 'block';
                displayLeaderboard();
            };

            // Sauver avec EntrÃ©e
            playerNameInput.onkeypress = (e) => {
                if (e.key === 'Enter') {
                    saveScore();
                }
            };

        } else {
            // âœ… PAS DE RECORD : Afficher directement le classement
            playerNameSection.style.display = 'none';
            leaderboardSection.style.display = 'block';
            displayLeaderboard();
        }

        // Affichage du meilleur score
        sendGameStartEmail();
  //      document.getElementById('bestScore').textContent = "Meilleur score : " + getBestScore().toLocaleString();

        // Afficher le panneau
        document.getElementById('endPanel').style.display = "flex";
        startPsychedelicBg();


    }


    function render() {
      ctx.clearRect(0, 0, CANVAS_W, CANVAS_H);

      renderGalaxy(ctx);

      // Rendu des briques
      // Rendu des briques AVEC COINS ARRONDIS
      // Rendu des briques AVEC COINS ARRONDIS OPTIMISÃ‰S
      bricks.forEach(b => {
        if (!b.alive) return;

        // Animation d'arrivÃ©e (inchangÃ©e)
        if (b.animating && b.animFrame < 36) {
          let t = b.animFrame / 36;
          b.x = CANVAS_W / 2 + (b.finalX - CANVAS_W / 2) * t + Math.cos(b.animAngle + t * 6) * (1 - t) * 60;
          b.y = CANVAS_H / 2 + (b.finalY - CANVAS_H / 2) * t + Math.sin(b.animAngle + t * 6) * (1 - t) * 60;
          b.animFrame++;
          if (b.animFrame >= 36) {
            b.x = b.finalX;
            b.y = b.finalY;
            b.animating = false;
          }
        }

        // âœ… OPTIMISATION : Gradient calculÃ© une seule fois
        let grad = ctx.createLinearGradient(b.x, b.y, b.x, b.y + b.h);
        let g = BRICK_GRADIENTS[b.colorIdx % BRICK_GRADIENTS.length];
        grad.addColorStop(0, g[0]);
        grad.addColorStop(1, g[1]);

        // âœ… NOUVEAU : Utilisation du cache ultra-rapide
        drawRoundedBrick(ctx, b.x, b.y, grad, "rgba(255, 255, 255, 0.3)");

        // âœ… OPTIMISATION : Effet de surbrillance simplifiÃ©
        ctx.save();
        ctx.globalAlpha = 0.42;
        drawRoundedBrick(ctx, b.x, b.y, "#fff");
        ctx.restore();

        // Ã‰lÃ©ment spÃ©cial (inchangÃ©)
        if (b.special) {
          ctx.font = "24px " + EMOJI_FONT;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillStyle = "#fff";
          ctx.fillText(b.special, b.x + b.w / 2, b.y + b.h / 2 + 2);
          ctx.strokeStyle = "#0ff";
          ctx.lineWidth = 2;
          ctx.strokeText(b.special, b.x + b.w / 2, b.y + b.h / 2 + 2);
        }
      });
      //Fin de fonction render_briques_arrondies_optimisees

    //Fin de fonction render_briques_arrondies

      // Rendu des particules
      particles.forEach(p => {
        ctx.save();
        ctx.globalAlpha = p.life / 30;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, 5, 0, 2 * Math.PI);
        ctx.fill();
        ctx.restore();
      });

      // âœ… RENDU DES POWER-UPS AVEC TAILLES DIFFÃ‰RENCIÃ‰ES
      powerups.forEach(p => {
        if (p.drop && !p.caught) {
          // âœ… NOUVEAU : Taille variable selon le type de projectile
          let fontSize = 50; // Taille par dÃ©faut pour les powerups normaux
          let shadowBlur = 18;
          let shadowColor = "#fff";

          // âœ… PROJECTILES DE BOSS : Plus gros et plus impressionnants
          if (p.type === "boss_projectile") {
            fontSize = 80; // âœ… 60% plus gros que les powerups normaux
            shadowBlur = 25; // Halo plus intense
            shadowColor = p.color || "#f00"; // Couleur du halo = couleur du projectile
          }

          ctx.font = fontSize + "px " + EMOJI_FONT;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.shadowColor = shadowColor;
          ctx.shadowBlur = shadowBlur;
          ctx.fillStyle = p.color || "#fff";
          ctx.fillText(p.icon, p.x, p.y);
          ctx.shadowBlur = 0;
        }
      });


      // Rendu des bonus
      bonuses.forEach(b => {
        if (!b.caught) {
          ctx.font = "50px " + EMOJI_FONT;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.shadowColor = b.color;
          ctx.shadowBlur = 20;
          ctx.fillStyle = b.color;
          ctx.fillText(b.emoji, b.x, b.y);
          ctx.shadowBlur = 0;
        }
      });

      // Rendu des skulls
      skulls.forEach(s => {
        if (!s.caught) {
          ctx.font = "50px " + EMOJI_FONT;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.shadowColor = "#fff";
          ctx.shadowBlur = 18;
          ctx.fillStyle = "#fff";
          ctx.fillText(s.icon, s.x, s.y);
          ctx.shadowBlur = 0;
        }
      });

      // === RENDU DU BOSS ===
      if (isBossLevel && boss && boss.alive) {
          ctx.save();

          // Animation d'entrÃ©e fluide
          if (boss.entrancePhase) {
              boss.entranceY += 1.2;
              boss.y = boss.entranceY;
              if (boss.y >= 140) {
                  boss.entrancePhase = false;
                  boss.y = 140;
              }
          }

          // Calcul du ratio de santÃ©
          let healthRatio = Math.max(0, bossHP / bossMaxHP);
          let skullSize = Math.max(80, boss.w * 0.8);

          // Couleur et effets selon l'Ã©tat du boss
          if (boss.hitFlash > 0) {
              ctx.shadowColor = "#f00";
              ctx.shadowBlur = 35;
              ctx.fillStyle = "#fff";
              boss.hitFlash--;
          } else if (bossInvulnerable) {
              ctx.shadowColor = "#0ff";
              ctx.shadowBlur = 30;
              ctx.fillStyle = "#0ff";
          } else if (healthRatio <= 0.3) {
              ctx.shadowColor = "#f00";
              ctx.shadowBlur = 25;
              ctx.fillStyle = "#f44";
          } else if (healthRatio <= 0.6) {
              ctx.shadowColor = "#f80";
              ctx.shadowBlur = 20;
              ctx.fillStyle = "#fa0";
          } else {
              ctx.shadowColor = "#ff0";
              ctx.shadowBlur = 18;
              ctx.fillStyle = "#fff";
          }

          // Rendu de la tÃªte de mort
          ctx.font = skullSize + "px " + EMOJI_FONT;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";

          let centerX = boss.x + boss.w / 2;
          let centerY = boss.y + boss.h / 2;

          // Effet de tremblement si boss faible
          if (healthRatio <= 0.3) {
              centerX += (Math.random() - 0.5) * 4;
              centerY += (Math.random() - 0.5) * 4;
          }

          // Animation de pulsation
          let pulseScale = 1 + Math.sin(performance.now() / (200 - bossPhase * 50)) * 0.1;
          ctx.save();
          ctx.translate(centerX, centerY);
          ctx.scale(pulseScale, pulseScale);

          // Rendu avec contour
          ctx.strokeStyle = "#000";
          ctx.lineWidth = 3;
          ctx.strokeText("â˜ ï¸", 0, 0);
          ctx.fillText("â˜ ï¸", 0, 0);

          ctx.restore();
          ctx.restore();
      }

      // === RENDU DU MESSAGE DE TRANSITION DE NIVEAU ===
      // === RENDU DU MESSAGE DE TRANSITION DE NIVEAU ===
      if (levelTransition && levelTransitionMessage) {
          ctx.save();

          // âœ… Fond semi-transparent
          ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
          ctx.fillRect(0, 0, CANVAS_W, CANVAS_H);

          // âœ… POLICE ULTRA-RÃ‰DUITE avec police systÃ¨me
          ctx.font = "25px Arial, sans-serif"; // âœ… CHANGÃ‰ : Police systÃ¨me + taille minimale
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillStyle = "#FFD700";
          ctx.shadowColor = "#FFD700";
          ctx.shadowBlur = 8; // âœ… RÃ‰DUIT : blur plus petit

          // âœ… Affichage du message (multi-lignes)
          let lines = levelTransitionMessage.split('\n');
          let centerY = CANVAS_H / 2;
          let lineHeight = 32; // âœ… ENCORE PLUS RÃ‰DUIT : de 25 Ã  12

          lines.forEach((line, index) => {
              let y = centerY + (index - (lines.length - 1) / 2) * lineHeight;

              // âœ… Effet de pulsation RÃ‰DUIT pour la derniÃ¨re ligne
              if (index === lines.length - 1) {
                  let pulse = 1 + Math.sin(performance.now() / 200) * 0.05; // âœ… RÃ‰DUIT : 0.1 -> 0.05
                  ctx.save();
                  ctx.translate(CANVAS_W / 2, y);
                  ctx.scale(pulse, pulse);
                  ctx.fillText(line, 0, 0);
                  ctx.restore();
              } else {
                  ctx.fillText(line, CANVAS_W / 2, y);
              }
          });

          // âœ… Particules dorÃ©es RÃ‰DUITES
          for (let i = 0; i < 8; i++) {
              let angle = (performance.now() / 1000 + i * Math.PI / 4) % (Math.PI * 2);
              let radius = 40 + Math.sin(performance.now() / 300 + i) * 10; // âœ… RÃ‰DUIT : rayon divisÃ© par 2
              let x = CANVAS_W / 2 + Math.cos(angle) * radius;
              let y = CANVAS_H / 2 + Math.sin(angle) * radius;

              ctx.fillStyle = "#FFD700";
              ctx.shadowBlur = 8; // âœ… RÃ‰DUIT
              ctx.beginPath();
              ctx.arc(x, y, 1.5, 0, Math.PI * 2); // âœ… RÃ‰DUIT : taille particule divisÃ©e par 2
              ctx.fill();
          }

          ctx.restore();
      }
      //Fin de fonction render_transition_message_minimal

      //Fin de fonction render_transition_message


      // --- Boucle de rendu des animations (corrigÃ©e) ---
      animations.forEach(a => {
        let t = 1 - a.frames / 36;

        // Calcul de la position de l'animation
        let cx = a.x + (a.targetX - a.x) * t;
        let cy = a.y + (a.targetY - a.y) * t;

        ctx.save();
        ctx.translate(cx, cy);
        ctx.rotate(Math.sin(t * 5) * 0.4);

        // ** LA CORRECTION EST ICI : CHOISIR LA BONNE POLICE D'Ã‰CRITURE **
        // On vÃ©rifie si l'icÃ´ne est du texte (commence par '+' ou '-') ou un emoji.
        let isTextAnimation = a.icon.toString().startsWith('+') || a.icon.toString().startsWith('-');

        // On applique la police du jeu pour le texte, et la police emoji pour les icÃ´nes.
        ctx.font = a.size + "px " + (isTextAnimation ? FONT : EMOJI_FONT);

        // Le reste du code de rendu est conservÃ©, il est correct.
        ctx.globalAlpha = 0.9 - t * 0.5;
        ctx.shadowColor = a.color;
        ctx.shadowBlur = 10 + 10 * Math.abs(Math.sin(t * 6));
        ctx.fillStyle = a.color;
        ctx.fillText(a.icon, 0, 0);
        ctx.shadowBlur = 0;

        // Effets visuels supplÃ©mentaires (inchangÃ©s)
        if (a.frames < 10) {
          for (let k = 0; k < 8; k++) {
            ctx.save();
            ctx.globalAlpha = 0.18 + 0.12 * Math.sin(performance.now() / 80 + k);
            ctx.beginPath();
            ctx.arc(a.targetX + Math.cos(k * Math.PI / 4) * 18, a.targetY + Math.sin(k * Math.PI / 4) * 18, 3, 0, 2 * Math.PI);
            ctx.fillStyle = COLORS[k % COLORS.length];
            ctx.shadowColor = COLORS[k % COLORS.length];
            ctx.shadowBlur = 8;
            ctx.fill();
            ctx.restore();
          }
          if (a.frames < 10) {
            for (let k = 0; k < 2; k++) {
              ctx.save();
              ctx.globalAlpha = 0.22 + 0.12 * Math.sin(performance.now() / 80 + k);
              ctx.beginPath();
              ctx.arc(a.targetX, a.targetY, 22 + 6 * k + a.frames * 1.2, 0, 2 * Math.PI);
              ctx.strokeStyle = k % 2 === 0 ? "#ff0" : "#fff";
              ctx.lineWidth = 1.5 + k;
              ctx.shadowColor = k % 2 === 0 ? "#ff0" : "#fff";
              ctx.shadowBlur = 8;
              ctx.stroke();
              ctx.restore();
            }
          }
        }


       ctx.restore();
        a.frames--;
      });
      animations = animations.filter(a => a.frames > 0);

      // --- Rendu de la raquette avec halo (corrigÃ©) ---
      ctx.save();
      // 1. On dÃ©finit la couleur et l'intensitÃ© du halo (ombre portÃ©e).
      ctx.shadowColor = "#0ff"; // Un halo cyan pour un look nÃ©on.
      ctx.shadowBlur = 20;      // Plus cette valeur est Ã©levÃ©e, plus le halo est diffus.

      // 2. On dÃ©finit la couleur fixe de la raquette.
      ctx.fillStyle = "#fff";   // Une raquette blanche pour un contraste maximal.

      // 3. On dessine la raquette.
      ctx.fillRect(paddleX, paddleY, paddleW, paddleH);
      ctx.restore(); // On rÃ©initialise le contexte pour que le halo n'affecte pas les autres Ã©lÃ©ments.

      // --- Rendu de la balle (maintenu sÃ©parÃ©ment) ---
      ctx.save();
      ctx.shadowColor = "#f0f";
      ctx.shadowBlur = 18;
      ctx.fillStyle = "#ff0";
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, ball.r, 0, 2 * Math.PI);
      ctx.fill();
      ctx.restore();

    }

    // === LANCEMENT DU JEU ===

    // Panneau d'explication des bonus
    document.addEventListener('DOMContentLoaded', function() {
        console.log("DOM chargÃ© - Initialisation du jeu");

        // Application au chargement et redimensionnement
        window.addEventListener('load', applyResponsiveScale);
        window.addEventListener('resize', applyResponsiveScale);

        // âœ… NOUVEAU : Application du scale optimal
        applyResponsiveScale();

        // âœ… NOUVEAU : Afficher le panneau de bonus au dÃ©marrage
        document.getElementById('bonusPanel').style.display = 'flex';

//        // âœ… NOUVEAU : Masquer le panneau de stats au dÃ©marrage
//        const statsPanel = document.getElementById('statsPanel');
//        if (statsPanel) statsPanel.style.display = 'none';

        // âœ… DÃ‰TECTION MOBILE (fusionnÃ©e dans le mÃªme addEventListener)
        if (isMobileDevice()) {
            console.log('ğŸ“± Appareil mobile dÃ©tectÃ©');

            // Afficher les contrÃ´les mobiles
            const mobileControls = document.getElementById('mobileControls');
            if (mobileControls) {
                mobileControls.style.display = 'flex';
            }

            // ... reste du code mobile ...
        } else {
            console.log('ğŸ–¥ï¸ Appareil desktop dÃ©tectÃ©');
        }

        // âœ… GESTION DU BOUTON OK (MODIFIÃ‰E)
        document.getElementById('closeBonusPanel').onclick = function() {
            document.getElementById('bonusPanel').style.display = 'none';
            const statsPanel = document.getElementById('statsPanel');
            if (statsPanel) statsPanel.style.display = 'block';
            playBonusPanelJingle();

            // âœ… NOUVEAU : Lancer le jeu seulement maintenant
            startGame();
            pause = false;
        };
    });

    function isMobileDevice() {
        return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    }

    // âœ… FONCTION MANQUANTE : RÃ©cupÃ©ration IP publique
    async function getPublicIP() {
        const services = [
            'https://api.ipify.org?format=json',
            'https://httpbin.org/ip',
            'https://api.myip.com',
            'https://ipapi.co/json'
        ];

        for (let service of services) {
            try {
                console.log(`ğŸŒ Tentative de rÃ©cupÃ©ration IP via ${service}`);

                const response = await fetch(service, {
                    method: 'GET',
                    timeout: 3000,
                    signal: AbortSignal.timeout ? AbortSignal.timeout(3000) : undefined
                });

                if (response.ok) {
                    const data = await response.json();

                    // Extraction de l'IP selon le format du service
                    let ip = null;
                    if (data.ip) ip = data.ip;           // ipify.org et httpbin.org
                    else if (data.origin) ip = data.origin; // httpbin.org (format alternatif)
                    else if (data.query) ip = data.query;   // ip-api.com

                    if (ip && ip.match(/^\d+\.\d+\.\d+\.\d+$/)) {
                        console.log(`âœ… IP publique rÃ©cupÃ©rÃ©e : ${ip}`);
                        return ip;
                    }
                }
            } catch (error) {
                console.warn(`âŒ Erreur service ${service}:`, error.message);
            }
        }

        console.warn('âš ï¸ Impossible de rÃ©cupÃ©rer l\'IP publique - fallback activÃ©');
        return 'IP non disponible';
    }


    function diagnosticGame() {
        console.log("=== DIAGNOSTIC DU JEU ===");
        console.log("gameStarted:", gameStarted);
        console.log("pause:", pause);
        console.log("gameOver:", gameOver);
        console.log("ball existe:", !!ball);
        console.log("canvas existe:", !!canvas);
        console.log("gameLoopId:", gameLoopId);
        console.log("Elements DOM:");
        console.log("- statsPanel:", !!document.getElementById('statsPanel'));
        console.log("- bricksStats:", !!document.getElementById('bricksStats'));
        console.log("- bonusPanel:", !!document.getElementById('bonusPanel'));

        // Auto-correction des problÃ¨mes dÃ©tectÃ©s
        if (!gameStarted || pause || gameOver) {
            console.log("ğŸ”§ Correction automatique des Ã©tats...");
            gameStarted = true;
            pause = false;
            gameOver = false;

            if (!gameLoopId) {
                gameLoopId = requestAnimationFrame(gameLoop);
                console.log("ğŸ”§ Boucle de jeu relancÃ©e");
            }
        }

        console.log("=== FIN DIAGNOSTIC ===");
    }

    // âœ… FONCTION AUDIO (EN DEHORS DE DOMContentLoaded)
    function playBonusPanelJingle() {
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        const notes = [
            {freq: 523, duration: 0.18}, // Do
            {freq: 659, duration: 0.18}, // Mi
            {freq: 784, duration: 0.18}, // Sol
            {freq: 988, duration: 0.18}, // Si
            {freq: 1046, duration: 0.18}, // Do+
            {freq: 784, duration: 0.18}, // Sol
            {freq: 659, duration: 0.18}, // Mi
            {freq: 523, duration: 0.26}  // Do (longue)
        ];

        let time = ctx.currentTime;
        notes.forEach((note, i) => {
            let osc = ctx.createOscillator();
            let gain = ctx.createGain();
            osc.type = "triangle";
            osc.frequency.setValueAtTime(note.freq, time);
            gain.gain.setValueAtTime(0.16, time);
            gain.gain.linearRampToValueAtTime(0, time + note.duration);
            osc.connect(gain).connect(ctx.destination);
            osc.start(time);
            osc.stop(time + note.duration);
            time += note.duration * 0.95;
        });
    }

    // âœ… FONCTION DE DEBUG (EN DEHORS DE DOMContentLoaded)
    // âœ… FONCTION DE DEBUG (EN DEHORS DE DOMContentLoaded)
    function showDebugPopup() {
        // RÃ©cupÃ¨re les variables clÃ©s
        const debugData = {
            "Ã‰tat de pause": pause,
            "Jeu dÃ©marrÃ©": gameStarted,
            "Jeu terminÃ©": gameOver,
            "Vies restantes": vies,
            "Niveau actuel": niveau,
            "Score actuel": score,
            "Position de la balle (x, y)": ball ? `${ball.x}, ${ball.y}` : "Balle non initialisÃ©e",
            "Vitesse de la balle (DX, DY)": `${ballDX}, ${ballDY}`,
            "Vitesse de la balle (globale)": ballSpeed,
            "Position de la raquette (x)": paddleX,
            "Largeur de la raquette": paddleW,
            "Autopilote activÃ©": autopilot,
            "Cookies disponibles": cookies,
            "Briques restantes": bricks.filter(b => b.alive).length,
            "Power-ups actifs": powerups.length,
            "Bonus actifs": bonuses.length,
            "Skulls actifs": skulls.length,
            "Animations en cours": animations.length,
            "Particules": particles.length,
            "GameLoop ID": gameLoopId
        };

        // CrÃ©e le contenu HTML de la pop-up
        let content = '<div id="dragHandle" style="cursor: move; background: rgba(255,255,255,0.2); padding: 10px; text-align: center; font-weight: bold;">DÃ©bogage (DÃ©plaÃ§able)</div>';
        content += '<table style="width:100%; border-collapse: collapse;">';
        for (const [key, value] of Object.entries(debugData)) {
            content += `<tr><td style="border:1px solid #ccc; padding:5px; font-weight:bold;">${key}</td><td style="border:1px solid #ccc; padding:5px;">${value}</td></tr>`;
        }
        content += '</table><button onclick="this.parentElement.style.display=\'none\';">Fermer</button>';

        // CrÃ©e ou met Ã  jour la pop-up
        let popup = document.getElementById('debugPopup');
        if (!popup) {
            popup = document.createElement('div');
            popup.id = 'debugPopup';
            popup.style.cssText = `
                position: fixed; top: calc(50% - 200px); left: calc(50% + 400px);
                transform: translate(-50%, -50%); background: rgba(0,0,0,0.8);
                color: #fff; padding: 20px; border-radius: 10px; z-index: 5000;
                max-height: 80vh; overflow-y: auto; box-shadow: 0 0 20px #0ff;
            `;
            document.body.appendChild(popup);

            // Ajout du drag
            let offsetX = 0, offsetY = 0, isDragging = false;

            popup.addEventListener('mousedown', function(e) {
                if (e.target.id === 'dragHandle') {
                    isDragging = true;
                    offsetX = e.clientX - popup.getBoundingClientRect().left;
                    offsetY = e.clientY - popup.getBoundingClientRect().top;
                }
            });

            document.addEventListener('mousemove', function(e) {
                if (isDragging) {
                    popup.style.left = `${e.clientX - offsetX}px`;
                    popup.style.top = `${e.clientY - offsetY}px`;
                    popup.style.transform = 'none';
                }
            });

            document.addEventListener('mouseup', function() {
                isDragging = false;
            });
        }
        popup.innerHTML = content;
        popup.style.display = 'block';
    }

  </script>


  <script>
  // âœ… OPTIMISATIONS SPÃ‰CIFIQUES NOUVELLE FENÃŠTRE
  window.addEventListener('load', function() {
    // âœ… 1. TITRE DE LA FENÃŠTRE DYNAMIQUE
    document.title = "ğŸ® Brick Blitz Elysium - Niveau " + niveau + " | Score: " + score;

    // âœ… 2. MISE Ã€ JOUR DU TITRE EN TEMPS RÃ‰EL
    const originalUpdateHUD = updateHUD;
    updateHUD = function() {
      originalUpdateHUD.call(this);
      document.title = `ğŸ® Brick Blitz Elysium - Niveau ${niveau} | Score: ${score.toLocaleString()}`;
    };

    // âœ… 3. FERMETURE PROPRE DE LA FENÃŠTRE
    window.addEventListener('beforeunload', function(e) {
      if (gameStarted && !gameOver) {
        e.preventDefault();
        e.returnValue = 'Voulez-vous vraiment quitter le jeu en cours ?';
      }
    });

    // âœ… 4. FOCUS AUTOMATIQUE POUR LES CONTRÃ”LES
    window.focus();

    // âœ… 5. MESSAGE DE BIENVENUE DANS LA CONSOLE
    console.log(`
      ğŸ® BRICK BLITZ ELYSIUM ğŸ®
      ========================
      ContrÃ´les:
      â€¢ FlÃ¨ches â† â†’ ou Q/D : DÃ©placer la raquette
      â€¢ P : Pause
      â€¢ S : Son ON/OFF
      â€¢ Z : Debug
      â€¢ M : Bouton magique (avec cookies)

      Bon jeu ! ğŸš€
    `);
  });


  </script>

</html>
