<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>p ELYSIUM</title>
  <link href="https://fonts.googleapis.com/css?family=Press+Start+2P" rel="stylesheet">
  <style>



  /* ✅ OPTIMISATION POUR NOUVELLE FENÊTRE */


  {
      margin: 0 !important;
      padding: 0 !important;
      box-sizing: border-box;
  }

  html, body {
    margin: 5;
    padding: 5;
    background: #000;
    overflow: hidden; /* ✅ DÉSACTIVE COMPLÈTEMENT L'ASCENSEUR */
    height: 100vh; /* ✅ HAUTEUR FIXE au lieu de min-height */
  }


  /* ✅ CONTENEUR PRINCIPAL CENTRÉ */
  body {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      height: 100vh; /* ✅ CHANGÉ : hauteur exacte sans dépassement */
      padding: 5; /* ✅ SUPPRIMÉ : plus de padding qui crée des marges */
      margin: 5; /* ✅ AJOUT : supprime les marges par défaut */
      max-width: 100vw;
      overflow: hidden; /* ✅ COHÉRENT : pas de scroll */
  }


  /* === AJUSTEMENT DU TITRE === */
  #title {
      font-family: 'Press Start 2P', monospace;
      font-size: 2.5em;
      letter-spacing: 0.2em;
      text-shadow: 0 0 15px #0ff, 0 0 40px #ff0, 0 0 150px #f0f;
      margin-top: 0; /* ✅ CHANGÉ : de -10px à 0 */
      padding: 0 0 10px 0; /* ✅ CHANGÉ : supprime le padding du haut, garde un peu en bas */
      font-weight: bold;
      filter: brightness(1.4);
      text-align: center;
      width: 100%;
      position: relative;
      left: 0;
      top: 0;
      transform: none;
      pointer-events: none;
      user-select: none;
      z-index: 20;
      white-space: nowrap;
      overflow: hidden;
  }



  /* === AJUSTEMENT DU HUD === */
  #hud {
      position: relative;
      left: 50%; /* ✅ NOUVEAU : Position au centre */
      top: 0;
      transform: translateX(-50%); /* ✅ NOUVEAU : Correction du centrage exact */
      width: 100%;
      max-width: 1140px;
      margin: 10px 0; /* ✅ CHANGÉ : margin vertical seulement, pas de centrage auto */
      text-align: center;
      font-family: 'Press Start 2P', monospace;
      color: #fff;
      pointer-events: none;
      z-index: 10;
      user-select: none;
      background: linear-gradient(260deg, #0ff 0%, #f0f 50%, #ff0 100%);
      box-shadow: 0 0 20px #0ff, 0 0 40px #f0f;
      border-radius: 12px;
      padding: 8px 0 6px 0;
  }



  /* ✅ CORRECTION : Ajouter #cookies au sélecteur */
  #score, #vies, #niveau, #mult, #cookies {
    font-family: 'Press Start 2P', monospace;
    font-size:1.1em;
    margin:0 30px;
    display:inline-block;
    text-shadow:0 0 9px #0ff, 0 0 9px #f0f;
    text-align: right;
    vertical-align:top;
    color: #fff;
    letter-spacing: 2px;
    transition: filter 0.2s, font-size 0.15s, color 0.15s;
  }

    #score.flash, #mult.flash {
      font-family: 'Press Start 2P', monospace;
      filter: brightness(1) drop-shadow(0 0 15px #ff0);
      /* ✅ SUPPRIMÉ : font-size:1.3em; pour éviter le redimensionnement */
      color: #ff0;
      /* ✅ NOUVEAU : Effet visuel alternatif sans changement de taille */
      text-shadow:
//        0 0 12px #ff0,
        0 0 24px #ff0,
        0 0 36px #fef,
        0 0 48px #fff;
      transform: scale(1.2); /* ✅ Légère mise à l'échelle qui n'affecte pas le layout */
      transform-origin: center center;
    }


    #bonus-anim {
      font-family: 'Press Start 2P', monospace;
      position:absolute; left:50%; top:50%; font-size:20px;
      pointer-events:none; opacity:0; transform:translate(-50%,-50%) scale(1.2);
      text-shadow:0 0 32px #fff, 0 0 64px #f0f, 0 0 128px #0ff;
      transition:opacity 0.4s, transform 0.4s;
      z-index:100;
    }
    #decrement-timer {

      position: absolute;
      left: 0; right: 0;
      font-family: 'Press Start 2P', monospace;
      font-size: 1em;
      color: #ff4444;
      text-shadow: 0 0 12px #fff, 0 0 24px #f00;
      z-index: 50;
      pointer-events: none;
      user-select: none;
      display: none;
      background: rgba(0,0,0,0.7);
      padding: 4px 10px;
      border-radius: 8px;
      text-align: center;
      top: 0;
    }

    /* === CONTAINER DE COUPLAGE GAMECANVAS + STATSPANEL === */
    .game-canvas-container {
      display: flex;
      align-items: flex-start; /* Alignement parfait en hauteur */
      gap: 15px; /* ✅ EXACTEMENT 15px entre canvas et panel */
      justify-content: center;
      position: relative;
      margin: 20px auto 0; /* Centrage et marge supérieure */
      width: fit-content; /* S'adapte au contenu */
    }

    /* === GAMECANVAS DANS LE CONTAINER === */
    #gameCanvas {
      display: block;
      margin: 0; /* ✅ SUPPRIMÉ : tous les margins/positions manuels */
      background: #111;
      box-shadow: 0 0 40px #0ff, 0 0 80px #f0f;
      border-radius: 12px;
      /* ✅ SUPPRIMÉ : position, left, top - maintenant géré par flex */
      flex-shrink: 0; /* Empêche la compression */
      cursor: none !important;
    }

    /* === STATSPANEL COUPLÉ AU CANVAS === */
    #statsPanel {
      /* ✅ NOUVEAU : Plus de position fixed - maintenant dans le flux */
      position: static !important;

      /* ✅ DIMENSIONS IDENTIQUES AU CANVAS */
      width: 250px !important;
      height: 900px !important; /* ✅ EXACTEMENT comme le canvas */
      max-height: 900px !important;
      min-height: 900px !important;

      /* ✅ STYLES VISUELS CONSERVÉS */
      background: #111;
      box-shadow: 0 0 40px #0ff, 0 0 80px #f0f;
      border-radius: 12px;
      z-index: 5;
      overflow-y: auto;
      overflow-x: hidden;
      box-sizing: border-box !important;

      /* ✅ FLEX : Pas de compression ni d'expansion */
      flex-shrink: 0;
      flex-grow: 0;

      /* ✅ SUPPRIMÉ : left, top, transform - maintenant géré par flex */
    }

    #bonusPanel {
      font-family: 'Press Start 2P', monospace;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      /* ✅ DIMENSIONS FIXES DE RÉFÉRENCE (comme le game-main-container) */
      width: 600px;
      height: 800px;

      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 2000;

      font-size: 0.8rem;
      box-sizing: border-box;
      overflow: hidden;

      /* ✅ STYLES VISUELS CONSERVÉS */
      border-radius: 18px;
      box-shadow:
        0 0 40px rgba(0, 255, 255, 0.8),
        0 0 80px rgba(255, 0, 255, 0.6),
        0 0 120px rgba(255, 255, 0, 0.4),
        inset 0 0 30px rgba(0, 255, 255, 0.2);
    }


  /* ✅ ARRIÈRE-PLAN AVEC PULSATION VISIBLE */
  #bonusPanel::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    z-index: -1;

    //background: rgba(0, 0, 0, 0.85);
    Background: rgba(0, 0, 0, 0.40);
    border-radius: 18px;

    box-shadow:
      0 0 60px rgba(0, 255, 255, 1),
      0 0 120px rgba(255, 0, 255, 0.8),
      0 0 180px rgba(255, 255, 0, 0.6);

    animation: haloStaticPulse 2s ease-in-out infinite alternate;
  }

  /* ✅ HALO EXTERNE ROTATIF ULTRA-VISIBLE */
  #bonusPanel::after {
    content: '';
    position: absolute;
    top: -20px;
    left: -20px;
    right: -20px;
    bottom: -20px;
    z-index: -2;

    /* ✅ NOUVEAU : Gradient en forme de rayons pour rotation visible */
    background: conic-gradient(
      from 0deg,
      rgba(0, 255, 255, 1) 0%,     /* Cyan intense - rayon 1 */
      transparent 5%,
      rgba(255, 0, 255, 1) 15%,    /* Magenta intense - rayon 2 */
      transparent 20%,
      rgba(255, 255, 0, 1) 30%,    /* Jaune intense - rayon 3 */
      transparent 35%,
      rgba(0, 255, 0, 1) 45%,      /* Vert intense - rayon 4 */
      transparent 50%,
      rgba(255, 165, 0, 1) 60%,    /* Orange intense - rayon 5 */
      transparent 65%,
      rgba(138, 43, 226, 1) 75%,   /* Violet intense - rayon 6 */
      transparent 80%,
      rgba(0, 255, 255, 1) 90%,    /* Retour cyan - rayon 7 */
      transparent 95%,
      rgba(255, 0, 255, 1) 100%    /* Magenta final - rayon 8 */
    );

    border-radius: 35px;

    /* ✅ ANIMATION PLUS RAPIDE ET VISIBLE */
    animation: haloRotate 3s linear infinite;

    /* ✅ BLUR RÉDUIT pour voir la rotation */
    filter: blur(6px);
  }

  /* ✅ ANIMATIONS OPTIMISÉES POUR LA VISIBILITÉ */
  @keyframes haloRotate {
    0% {
      transform: rotate(0deg) scale(1);
      filter: blur(6px);
    }
    25% {
      transform: rotate(90deg) scale(1.03);
      filter: blur(4px);
    }
    50% {
      transform: rotate(180deg) scale(1);
      filter: blur(6px);
    }
    75% {
      transform: rotate(270deg) scale(1.03);
      filter: blur(4px);
    }
    100% {
      transform: rotate(360deg) scale(1);
      filter: blur(6px);
    }
  }

  @keyframes haloStaticPulse {
    0% {
      opacity: 0.8;
      transform: scale(0.98);
      box-shadow:
        0 0 60px rgba(0, 255, 255, 1),
        0 0 120px rgba(255, 0, 255, 0.8),
        0 0 180px rgba(255, 255, 0, 0.6);
    }
    50% {
      opacity: 1;
      transform: scale(1.02);
      box-shadow:
        0 0 80px rgba(0, 255, 255, 1),
        0 0 160px rgba(255, 0, 255, 1),
        0 0 240px rgba(255, 255, 0, 0.8);
    }
    100% {
      opacity: 0.9;
      transform: scale(1);
      box-shadow:
        0 0 70px rgba(0, 255, 255, 1),
        0 0 140px rgba(255, 0, 255, 0.9),
        0 0 210px rgba(255, 255, 0, 0.7);
    }
  }

  /* ✅ EFFET HOVER RENFORCÉ */
  #bonusPanel:hover::before {
    animation-duration: 1s; /* Pulsation plus rapide au survol */
    background: rgba(0, 0, 0, 0.9);
  }

  #bonusPanel:hover::after {
    animation-duration: 1.5s; /* Rotation plus rapide au survol */
    filter: blur(3px); /* Halo plus net */
    transform: scale(0.70); /* Légèrement plus grand */
  }

  #bonusPanel:hover {
    box-shadow:
      0 0 80px rgba(0, 255, 255, 1),
      0 0 160px rgba(255, 0, 255, 0.9),
      0 0 240px rgba(255, 255, 0, 0.8),
      inset 0 0 50px rgba(0, 255, 255, 0.4);
  }



/* === CONTAINER PRINCIPAL RESPONSIVE === */
.game-main-container {
  position: relative;
  width: 1200px;
  height: 1000px;
  margin: 0 auto;
  transform-origin: center top;
  transition: transform 0.3s ease;
  /* ✅ Le scale sera calculé dynamiquement par JavaScript */
}


    .bonus-panel-content {
//      background: rgba(30, 40, 60, 0.99);
      background: rgba(30, 40, 60, 0.75);
      color: #fff;
      border-radius: clamp(12px, 2vw, 18px);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.45);

      /* ✅ NOUVEAU : Padding responsive mais sans créer de débordement */
      padding: clamp(20px, 5vw, 40px) clamp(25px, 6vw, 45px) clamp(15px, 4vw, 35px) clamp(25px, 6vw, 45px);

      font-family: 'Press Start 2P', monospace;
      text-align: left;

      /* ✅ SUPPRIMÉ : overflow-y: auto pour éliminer l'ascenseur interne */
      /* ✅ SUPPRIMÉ : height: 100% qui forçait le scroll */
      width: 100%;
      max-width: 100%;

      /* ✅ NOUVEAU : Taille de police légèrement plus grande */
      font-size: clamp(0.6em, 1.8vw, 0.85em); /* ✅ AUGMENTÉ pour meilleure lisibilité */

      /* ✅ NOUVEAU : Espacement des lignes optimisé */
      line-height: clamp(1.4, 2vw, 1.8);
      box-sizing: border-box;

      /* ✅ NOUVEAU : Disposition naturelle sans contrainte de hauteur */
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
    }

    /* Animation de clignotement générique et réutilisable */
    .blinking-effect {
      animation: blink-animation 1s step-end infinite;
    }
    @keyframes blink-animation {
      50% {
        opacity: 0;
      }
    }


    /* ✅ NOUVEAU : Éléments internes responsive */
    /* ✅ NOUVEAU : Éléments internes optimisés pour la nouvelle taille */
  .bonus-panel-content h2 {
    text-align: center;
    color: #FFD700;
    margin-top: 0;
    margin-bottom: clamp(12px, 4vw, 25px); /* ✅ AUGMENTÉ proportionnellement */

    font-size: clamp(0.9em, 2.4vw, 1.3em); /* ✅ AUGMENTÉ : de 2vw à 2.4vw */
    letter-spacing: clamp(1px, 0.4vw, 3px); /* ✅ AUGMENTÉ */
    text-shadow: 1px 2px 0 #222;
  }

  .bonus-panel-content h3 {
    text-align: center;
    color: #FFE000;
    margin-top: 0;
    margin-bottom: clamp(10px, 2.5vw, 20px); /* ✅ AUGMENTÉ */

    font-size: clamp(0.4em, 1.2vw, 0.6em); /* ✅ AUGMENTÉ : de 1vw à 1.2vw */
    letter-spacing: clamp(1px, 0.25vw, 2.5px);
    text-shadow: 1px 5px 0 #122;
  }

  .bonus-panel-content ul {
    list-style: none;
    padding: 0;
    margin-bottom: clamp(15px, 4vw, 30px); /* ✅ AUGMENTÉ */
  }

  .bonus-panel-content li {
    margin-bottom: clamp(8px, 2vw, 16px); /* ✅ AUGMENTÉ : de 1.5vw à 2vw */
    display: flex;
    align-items: center;
    font-size: clamp(0.55em, 1.6vw, 0.95em); /* ✅ AUGMENTÉ : de 1.3vw à 1.6vw */
  }

  .bonus-emoji {
    font-size: clamp(1em, 2.4vw, 1.5em); /* ✅ AUGMENTÉ : de 2vw à 2.4vw */
    margin-right: clamp(10px, 2.5vw, 18px); /* ✅ AUGMENTÉ */
    filter: drop-shadow(0 0 6px #0ff);

    /* ✅ NOUVELLE TAILLE minimale */
    min-width: clamp(20px, 3.5vw, 30px); /* ✅ AUGMENTÉ */
    display: inline-block;
    text-align: center;
  }

  #closeBonusPanel {
    display: block;
    margin: clamp(8px, 2.5vw, 15px) auto 0; /* ✅ AUGMENTÉ */
    padding: clamp(10px, 2.5vw, 16px) clamp(25px, 6vw, 45px); /* ✅ AUGMENTÉ */

    background: linear-gradient(90deg, #FFD700 45%, #FF6F00 100%);
    color: #222;
    border: none;
    border-radius: clamp(8px, 2vw, 12px); /* ✅ AUGMENTÉ */

    font-family: 'Press Start 2P', monospace;
    font-size: clamp(0.7em, 1.8vw, 1.2em); /* ✅ AUGMENTÉ : de 1.5vw à 1.8vw */
    letter-spacing: clamp(1px, 0.4vw, 2.5px);
    cursor: pointer;

    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
    transition: background 0.2s, transform 0.1s;
  }

  #closeBonusPanel:hover {
    background: linear-gradient(90deg, #FFEC80 45%, #FF9F00 100%);
    transform: scale(clamp(1.03, 1.08, 1.12)); /* ✅ AUGMENTÉ : hover plus marqué */
  }

    /* Panneau de fin */
    #endPanel {
      font-family: 'Press Start 2P', monospace;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);

      /* ✅ DIMENSIONS FIXES DE RÉFÉRENCE (comme les autres panneaux) */
      width: 900px;
      height: 700px;

      display: none; /* Caché par défaut */
      align-items: center;
      justify-content: center;
      flex-direction: column;
      z-index: 3000;

      /* ✅ STYLES VISUELS CONSERVÉS */
      background: rgba(0,0,0,0.94);
      border-radius: 15px;
      box-shadow: 0 0 50px rgba(0, 255, 255, 0.3);
      border: 2px solid rgba(255, 255, 255, 0.1);
      overflow: hidden;
      box-sizing: border-box;
    }

    /* ✅ SUPPRIME TOUS LES @media DU END PANEL ! */

    #endPanel .score-final {
      color:#FFD700;
      font-size: clamp(1.8em, 3vw, 2.2em); /* ✅ RÉDUIT ET RESPONSIVE */
      text-shadow:0 0 25px #ff0,0 0 50px #f0f; /* ✅ RÉDUIT */
      margin-bottom: clamp(14px, 2.5vw, 18px); /* ✅ RESPONSIVE */
      text-align:center;
    }

    #endPanel .stat {
      color:#fff;
      font-size: clamp(0.9em, 1.5vw, 1em); /* ✅ RÉDUIT ET RESPONSIVE */
      margin-bottom: clamp(12px, 2vw, 14px); /* ✅ RESPONSIVE */
      text-align:center;
      line-height: 1.4; /* ✅ NOUVEAU : Meilleur espacement */
    }

    #endPanel .best-score {
      color:#FFD700;
      font-size: clamp(0.9em, 1.5vw, 1em); /* ✅ RÉDUIT ET RESPONSIVE */
      margin-bottom: clamp(14px, 2.5vw, 16px); /* ✅ RESPONSIVE */
      text-align:center;
    }

    #endPanel button {
      padding: clamp(10px, 2vw, 12px) clamp(30px, 5vw, 35px); /* ✅ RESPONSIVE */
      font-size: clamp(0.9em, 1.4vw, 1em); /* ✅ RÉDUIT ET RESPONSIVE */
      border-radius: clamp(7px, 1.5vw, 9px); /* ✅ RESPONSIVE */
      background:linear-gradient(90deg,#FFD700 45%,#FF6F00 100%);
      border:none;
      color:#222;
      font-family:'Press Start 2P',monospace;
      margin-top: clamp(12px, 2.5vw, 16px); /* ✅ RESPONSIVE */
      cursor:pointer;
      transition: transform 0.1s ease; /* ✅ NOUVEAU : Animation hover */
    }

    #endPanel button:hover {
      background: linear-gradient(90deg, #FFEC80 45%, #FF9F00 100%);
      transform: scale(1.05); /* ✅ EFFET HOVER AJUSTÉ */
    }

    /* ✅ NOUVEAU : Ajustements pour le leaderboard dans endPanel */
    #leaderboardSection {
      max-height: clamp(350px, 60vh, 450px) !important; /* ✅ HAUTEUR RESPONSIVE */
      overflow: hidden !important; /* ✅ COHÉRENT avec les autres panneaux */
      margin-top: clamp(15px, 3vw, 20px); /* ✅ MARGE RESPONSIVE */
    }

    #leaderboardList table {
      font-size: clamp(0.6em, 1.2vw, 0.8em) !important; /* ✅ TAILLE AJUSTÉE */
      line-height: 1.3 !important; /* ✅ ESPACEMENT OPTIMISÉ */
    }

    #leaderboardList td {
      padding: clamp(6px, 1.5vw, 8px) clamp(3px, 1vw, 4px) !important; /* ✅ PADDING RESPONSIVE */
    }

    /* ✅ NOUVEAU : Ajustements pour la saisie du nom */
    #playerNameSection input {
      font-size: clamp(0.9em, 1.4vw, 1em) !important; /* ✅ TAILLE AJUSTÉE */
      padding: clamp(8px, 1.5vw, 10px) !important; /* ✅ PADDING RESPONSIVE */
      width: clamp(160px, 25vw, 200px) !important; /* ✅ LARGEUR RESPONSIVE */
    }

    #playerNameSection button {
      font-size: clamp(0.8em, 1.2vw, 0.9em) !important; /* ✅ BOUTONS PLUS PETITS */
      padding: clamp(8px, 1.5vw, 10px) clamp(15px, 3vw, 20px) !important; /* ✅ PADDING AJUSTÉ */
    }

    #psyCanvas {
      position: absolute;
      top: 0; left: 0; width: 100%; height: 100%;
      z-index: 1;
      pointer-events: none;
    }

    #autopilot-status {
      display: none; /* Caché par défaut */
      font-family: 'Press Start 2P', monospace;
      font-size: 1.1em; /* Même taille que le score */
      margin-left: 25px; /* Espace par rapport au score */

      color: #0ff; /* Couleur cyan, pour un look "high-tech" */
      text-shadow: 0 0 8px #0ff, 0 0 16px #0ff, 0 0 24px #fff;

      /* Animation de clignotement */
      animation: blink-effect 1s step-end infinite;
    }

    /* Définition de l'animation de clignotement */
    @keyframes blink-effect {
      50% {
        opacity: 0;
      }
    }

    #psyOverlay {
      position: relative;
      z-index: 2;
      width: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
    }


    .stats-panel-content {
      padding: 20px 15px;
      font-family: 'Press Start 2P', monospace;
      color: #fff;
      font-size: 0.7em;
    }

    .stats-panel-content h3 {
      text-align: center;
      color: #FFD700;
      margin: 0 0 20px 0;
      font-size: 1.1em;
      letter-spacing: 2px;
      text-shadow: 0 0 10px #FFD700;
    }

    .stats-section {
      margin-bottom: 20px;
      border-bottom: 1px solid rgba(0, 255, 255, 0.3);
      padding-bottom: 15px;
    }

    .stats-section:last-child {
      border-bottom: none;
    }

    .stats-section h4 {
      color: #0ff;
      margin: 0 0 10px 0;
      font-size: 0.8em;
      text-shadow: 0 0 8px #0ff;
      letter-spacing: 1px;
    }

    .stats-item {
      display: flex;
      justify-content: space-between;
      margin-bottom: 5px;
      font-size: 0.75em;
    }

    .stats-item-label {
      color: #fff;
      flex: 1;
    }

    .stats-item-value {
      color: #ff0;
      font-weight: bold;
      text-shadow: 0 0 6px #ff0;
    }

    .stats-emoji {
      font-family: 'Apple Color Emoji', 'Segoe UI Emoji', 'Noto Color Emoji', monospace;
      margin-right: 8px;
      filter: drop-shadow(0 0 4px #0ff);
    }

    /* Indicateur de danger pour les skulls */
    .danger-indicator {
      color: #f44 !important;
      animation: dangerBlink 1s infinite;
    }

    @keyframes dangerBlink {
      0%, 50% { opacity: 1; }
      51%, 100% { opacity: 0.3; }
    }

    /* Indicateur positif pour les multiplicateurs */
    .positive-indicator {
      color: #0f0 !important;
      text-shadow: 0 0 8px #0f0 !important;
    }

    .flashy-score {
      color: #ff0; /* Jaune vif par défaut */
      color: #FFD700;
      text-shadow: 0 0 10px #0ff, 0 0 20px #f0f, 0 0 40px #ff0, 0 0 80px #f0f;
      font-weight: bold;
      animation: flashyColor 0.5s infinite alternate;
    }

    @keyframes flashyColor {
      0%   { color: #ff0; text-shadow: 0 0 10px #0ff, 0 0 40px #f0f; }
      25%  { color: #0ff; text-shadow: 0 0 10px #ff0, 0 0 40px #f0f; }
      50%  { color: #f0f; text-shadow: 0 0 10px #ff0, 0 0 40px #0ff; }
      75%  { color: #ff00cc; text-shadow: 0 0 10px #ff0, 0 0 40px #0ff; }
      100% { color: #ff0; text-shadow: 0 0 10px #0ff, 0 0 40px #f0f; }
    }
    /* Style du bandeau d'alerte pour l'autopilote */
    #autopilot-banner {
      display: none; /* Caché par défaut */
      position: absolute;
      left: 45%;
      top: 35%;
      transform: translate(-50%, -50%);
      padding: 12px 30px;

      font-family: 'Press Start 2P', monospace;
      font-size: 1em; /* Grande taille pour être bien visible */
      color: #FFD700; /* Couleur or, classique */

      background: rgba(20, 10, 40, 0.65); /* Fond plus transparent (0.85 -> 0.65) */
        border: 4px solid rgba(255, 0, 255, 0.5); /* Bordure plus transparente */
        border-radius: 12px;
        box-shadow: 0 0 20px rgba(255, 0, 255, 0.5), /* Ombres externes plus douces */

      text-align: center;
      text-shadow: 0 0 10px #ff0, 0 0 20px #f0f;
      white-space: nowrap; /* Empêche le texte de passer à la ligne */
      z-index: 0; /* S'assure qu'il est au-dessus du jeu */

      user-select: none; /* Empêche la sélection du texte */
      pointer-events: none; /* Permet aux clics de passer à travers */
    }

    /* Animation de "flash" pour attirer l'attention */
    #autopilot-banner.flash {
      animation: banner-flash 0.3s ease-in-out;
    }

    @keyframes banner-flash {
      0%   { transform: translate(-50%, -50%) scale(1.05); filter: brightness(1.5); }
      100% { transform: translate(-50%, -50%) scale(1); filter: brightness(1); }
    }

  </style>
</head>

<body>
  <!-- ✅ NOUVEAU : Container principal scalable -->
  <div class="game-main-container">
    <div id="title">BRICK BLITZ ELYSIUM</div>

    <div id="hud">
      <span id="vies">VIE(S):3</span>
      <span id="cookies">COOKIE(S):0</span>
      <span id="niveau">NIVEAU(X):1</span>
      <span id="mult">x1</span>
      <span id="score">000000000</span>
      <span id="autopilot-status">AUTOPILOT</span>
    </div>

    <div id="bonus-anim"></div>
    <div id="decrement-timer"></div>

    <!-- ✅ NOUVEAU : Container de couplage Canvas + StatsPanel -->
    <div class="game-canvas-container">
      <canvas id="gameCanvas" width="875" height="900"></canvas>

      <div id="statsPanel">
        <div class="stats-panel-content">
          <h3>STATISTIQUES</h3>

          <div class="stats-section">
            <h4>BRIQUES</h4>
            <div id="bricksStats"></div>
          </div>

          <div class="stats-section">
            <h4>BONUS</h4>
            <div id="bonusesStats"></div>
          </div>

          <div class="stats-section">
            <h4>POWER-UPS</h4>
            <div id="powerupsStats"></div>
          </div>

          <div class="stats-section">
            <h4>ÉTAT DU JEU</h4>
            <div id="gameStateStats"></div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- ✅ FIN du container principal scalable -->

  <!-- ✅ Éléments qui restent HORS du scaling -->
  <div id="autopilot-banner"></div>

  <!-- Panneau d'explication des bonus -->
  <div id="bonusPanel">
    <div class="bonus-panel-content">
      <h2>BONUS</h2>
      <ul>
        <li><span class="bonus-emoji">🍒 🍌 🍇 🌸</span> <b>500 pts Petit bonus de score</li>
        <li><span class="bonus-emoji">🍓</span> <b>1000 pts Bonus de score</li>
        <li><span class="bonus-emoji">🐲</span> <b>1500 pts Bonus fleuri</li>
        <li><span class="bonus-emoji">🛸 🍉</span> <b>2000 pts Super bonus</li>
        <li><span class="bonus-emoji">🍑</span> <b>5000 pts Méga bonus</li>
        <li><span class="bonus-emoji">💝</span> <b>8000 pts Bonus de score</li>
        <li><span class="bonus-emoji">💊</span> <b>15000 pts Méga bonus</li>
        <h2>POWER-UPS</h2>
        <li><span class="bonus-emoji">🏳️</span> <b>Raquette longue</b> <span class="bonus-emoji">🏴‍☠️</span> <b>Raquette courte</b> <span class="bonus-emoji">❤️‍🔥</span> <b>Raquette géante</b></li>
        <li><span class="bonus-emoji">1️⃣ 2️⃣ 4️⃣ 8️⃣ </span> <b>Multiplicateurs de score pendant 30s</li>
        <li><span class="bonus-emoji">🍪</span> <b>Cookies  Bouton panique (M)</li>
        <li><span class="bonus-emoji">🌈</span> <b>Vie      Une vie</li>
        <li><span class="bonus-emoji">🏖️</span> <b>Niveau   Niveau suivant</li>
        <li><span class="bonus-emoji">☠️</span>  <b>Malus    Score en décrémentation pendant 30s</li>
      </ul>
      <h2>ACTIONS</h2>
      <li><span class="bonus-emoji">M</span>Bouton panique  <span class="bonus-emoji">P</span>Pause <span class="bonus-emoji">S</span>Son Marche/Arrêt <span class="bonus-emoji">z</span>Variables</li>
      <ul>
      <button id="closeBonusPanel">OK</button>
      <li><span></span></li>
      <h3>(c) jean-luc faisans 2025     v1.01</h3>
    </div>
  </div>

  <!-- Panneau de fin de partie -->
  <div id="endPanel">
    <canvas id="psyCanvas"></canvas>
    <div id="psyOverlay">
      <div class="score-final" id="TITRE"></div>
      <div class="score-final" id="finalScore"></div>

      <!-- ✅ NOUVEAU : Formulaire de saisie du nom -->
      <div id="playerNameSection" style="display: none;">
        <div style="color: #fff; font-size: 1.2em; margin: 20px 0; text-align: center;">
          🏆 NOUVEAU RECORD ! 🏆
        </div>
        <div style="color: #FFD700; font-size: 1em; margin-bottom: 15px; text-align: center;">
          Entrez votre nom :
        </div>
        <input type="text" id="playerNameInput" maxlength="12"
               style="padding: 10px; font-size: 1.1em; font-family: 'Press Start 2P', monospace;
                      text-align: center; background: #222; color: #fff; border: 2px solid #0ff;
                      border-radius: 5px; margin-bottom: 15px; width: 200px;"
               placeholder="JOUEUR">
        <br>
        <button id="saveScoreBtn" style="padding: 10px 20px; font-size: 1em;
                font-family: 'Press Start 2P', monospace; background: linear-gradient(90deg, #FFD700 45%, #FF6F00 100%);
                color: #222; border: none; border-radius: 5px; cursor: pointer; margin-right: 10px;">
          SAUVER
        </button>
        <button id="skipSaveBtn" style="padding: 10px 20px; font-size: 1em;
                font-family: 'Press Start 2P', monospace; background: #666;
                color: #fff; border: none; border-radius: 5px; cursor: pointer;">
          PASSER
        </button>
      </div>

      <!-- ✅ NOUVEAU : Tableau des meilleurs scores -->
      <div id="leaderboardSection" style="display: none; margin-top: 20px; max-height: 500px; overflow-y: auto;">
        <div style="color: #FFD700; font-size: 1.2em; margin-bottom: 15px; text-align: center;">
          🥇 TOP 10 🥇
        </div>
          <br>
        <div id="leaderboardList"></div>
        <br>  <br>
      </div>

      <div class="stat" id="levelsPassed"></div>
      <div class="stat" id="bricksHit"></div>
      <div class="stat" id="timePlayed"></div>
      <div class="stat" id="powerupDetails"></div>
      <div class="best-score" id="bestScore"></div>
      <button onclick="closeEndPanel()">OK</button>
    </div>
  </div>

</body>


  <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/@emailjs/browser@4/dist/email.min.js"></script>


  <script>

    // === CONSTANTES GLOBALES ===

    const COLORS = ["#0ff", "#f0f", "#ff0", "#0f0", "#fff"];
    const BRICK_GRADIENTS = [
      ["#0ff", "#0cf"],
      ["#f0f", "#c0f"],
      ["#ff0", "#fc0"],
      ["#0f0", "#0c8"],
      ["#fff", "#aaa"]
    ];
    const SPECIAL_ICONS = ["🏳️‍⚧️","🏴‍☠️","1️⃣","2️⃣","4️⃣","8️⃣","❤️‍🔥"];
    const BONUS_ICONS = [
      {emoji:"🍒", points:500, color:"#f06"},
      {emoji:"🍓", points:1000, color:"#f44"},
      {emoji:"🛸", points:2000, color:"#0ff"},
      {emoji:"🍑", points:5000, color:"#fa8"},
      {emoji:"🌸", points:500, color:"#f9f"},
      {emoji:"💝", points:8000, color:"#f44"},
      {emoji:"🍉", points:2000, color:"#0ff"},
      {emoji:"💊", points:15000, color:"#fa8"},
      {emoji:"🐲", points:15000, color:"#f9f"},
      {emoji:"🍇", points:2000, color:"#94f"},
      {emoji:"🍪", points:0, color:"#A67B5B", type:"cookie"},
      {emoji:"🌈", points:0, color:"#A67B5B", type:"vie"},
      {emoji:"🏖", points:0, color:"#A67B5B", type:"niveau"},
      {emoji:"🍌", points:500, color:"#ff4"},
    ];



    const PERF_CONFIG = {
      enabled: true,               // Activer/désactiver l’adaptation
      measureIntervalFrames: 300,  // Nombre de frames entre deux mesures
      fpsThresholdDisable: 30,     // Seuil pour désactiver la galaxie
      fpsThresholdLow: 35,         // Basculer en qualité “low” sous ce FPS
    };



    const FONT = "Press Start 2P, monospace";
    const EMOJI_FONT = "'Apple Color Emoji', 'Segoe UI Emoji', 'Noto Color Emoji', 'Press Start 2P', monospace";
    const CANVAS_W = 875, CANVAS_H = 900;

    // === VARIABLES D'ÉTAT DU JEU ===

    // Ligne corrigée
    let vies = 4, niveau = 1, score = 0, displayScore = 0;
    let mult = 1, multTimer = 0, multMax = 40, lastMult = 1;
    let bricks = [], particles = [], powerups = [], bonuses = [], animations = [];
    brickCols = 14;
    let wallOffset = 50;
    let brickW = 61, brickH = 28; brickGap = 2;
    let paddleW = 150, paddleH = 18, paddleY = CANVAS_H-60;
    let paddleX = (CANVAS_W-paddleW)/2, paddleSpeed = 13;
    let isMouseCaptured = false;
    let perfFrameCount = 0;
    let perfLastTime = performance.now();

    let ballSpeed0 = 12; // IMPORTANT : avant son utilisation
    let LancementAutoPilote = 5;
    let brickRows = 8; //et autour de la ligne 700
    let isEndGame = false;
    let ball = null, ballSpeed = ballSpeed0, ballR = 13;
    let ballDX = 0, ballDY = 0;
    let leftDown = false, rightDown = false;
    let lastFrame = 0, gameOver = false, pause = false;
    let bonusAnimTimeout = null;
    let paddleHugeTimeout = null;
    let decrementTimer = 0;
    let decrementActive = false;
    let decrementEffect = false;
    let levelsPassed = 0;
    let paddleAcceleration = 0;
    const maxPaddleAcceleration = 15;   // Accélération maximale (ajuste selon le feeling)
    const paddleAccelerationStep = 1.02; // Vitesse d'accélération (ajuste selon le feeling)
    let paddleBaseW = 150; // Taille de base de la raquette
    let decrementStartTime = 0;
    let gameStarted = false;
    let autopilot = false;
    let aimingError = 0;      // AJOUT : Mémorise l'erreur de placement du coup précédent.
    let desiredPaddleX = 0;   // AJOUT : Stocke la position cible calculée par l'IA.
    let AutopilotBanner = false
    let panic = false
    let PanicButon = false
    let cookies = 0;
    let wallOffsetPlus =0;
    let megaspeed=1
    let gameLoopId = null; // Ajouter en haut du fichier
    let longTimeout = null;
    let shortTimeout = null;
    let impactTimeout = null;
    let paddleVelocity = 0;
    let Debug = false;
    let wheelVelocity = 0;
    let skulls = [];
    let shotHistory = [];
    let lastTargetBrick = null;
    let lastPaddleTarget = 0;
    let paddleSizeEffect = null;
    let paddleOriginalSize = paddleBaseW;
    let dernierUtilisateur = null;

    // === VARIABLE DE SENSIBILITÉ SOURIS ===
    let mouseSensitivity = 1.1; // ✅ NOUVEAU : Facteur de démultiplication (1.8x plus sensible)
    let lastMouseX = null; // ✅ NOUVEAU : Position précédente de la souris pour calcul du delta
    //Fin de variables sensibilité souris

// === VARIABLES GALAXIE ÉVOLUTIVES ===
let galaxyParticles = [];
let galaxyTime = 0;
let galaxyCenter = { x: CANVAS_W/2, y: CANVAS_H/2 };
let galaxyRadius = 300;
let galaxyParticleCount = 150; // Nombre de pixels lumineux
let galaxyColorScheme = 0; // Schéma de couleur actuel (0-4)
let galaxySpacing = 1.0; // Multiplicateur d'espacement (0.7-1.5)
let galaxyRotationMode = 0; // Mode de rotation (0-2)

// ✅ OPTIMISATION : Cache trigonométrique
let trigCache = {
    sin: new Array(360),
    cos: new Array(360),
    init() {
        for (let i = 0; i < 360; i++) {
            let rad = (i * Math.PI) / 180;
            this.sin[i] = Math.sin(rad);
            this.cos[i] = Math.cos(rad);
        }
    },
    getSin(angle) {
        return this.sin[Math.floor(angle * 180 / Math.PI) % 360];
    },
    getCos(angle) {
        return this.cos[Math.floor(angle * 180 / Math.PI) % 360];
    }
};
trigCache.init();



let targetVelocity = 0;
let adaptiveCompensation = 0;
let compensationStep = 5;

let isBossLevel = false;
let boss = null;
let bossPhase = 1;
let bossMaxHP = 100;
let bossHP = 100;
let bossInvulnerable = false;
let bossAttackTimer = 0;
let bossMovementTimer = 0;
let bossDefeated = false;
let psyAnimId = null;
let emailSent = false; // Pour éviter les envois multiples
let gameSessionId = null; // ID unique de la session de jeu
let levelComplete = false;

let gyroControls = {
    active: false,
    supported: false,
    permission: false,
    sensitivity: 1.5,
    deadZone: 3
};

let frameCount = 0;
let lastPerformanceCheck = 0;

const EMAILJS_CONFIG = {
    publicKey: "S4SodZJrD9Ftqor5s",
    serviceId: "service_z3kyzle",
    templateId: "template_7x60gk8",
    toEmail: "jlmaybe1024@gmail.com", // ✅ AJOUT : Email de destination
    enabled: true // ✅ AJOUT : Possibilité de désactiver facilement
};

let gyroActive = false;
let gyroSupported = false;
let gyroPermission = false;
let touchStartX = 0;
let touchStartY = 0;
let isTouching = false;
let touchControlZone = null; // 'left', 'right', ou null

// === SYSTÈME DE QUALITÉ DYNAMIQUE ===
let renderQuality = "low"; // "high", "medium", "low"
//let performanceFrames = 0;
//let performanceStart = 0;

let baseGameSpeed = 12;
let currentGameSpeed = 12;
let levelSpeedBonus = 0;
let brickSpeedBonus = 0;
let speedIncreasePerBrick = 0.001; // ✅ RÉDUIT de 0.02 à 0.008 (60% plus lent)
let speedIncreasePerLevel = 0.05;   // ✅ RÉDUIT de 1.2 à 0.6 (50% plus lent)
let autopilotSpeedMultiplier = 1.04; // ✅ RÉDUIT de 1.15 à 1.08 (seulement 8% plus rapide)

// === VARIABLES DE TRANSITION DE NIVEAU ===
let levelTransition = false;
let levelTransitionTimer = 0;
let levelTransitionMessage = "";
let levelTransitionDelay = 5000; // 4 secondes en millisecondes


let bricksHit = 0;
let powerupsCaptured = {
  "long": 0,
  "short": 0,
  "mult1": 0,
  "mult2": 0,
  "mult4": 0,
  "mult8": 0,
  "huge": 0,
  "skull": 0
};

let bonusesCaptured = {
  "🍒": 0,   // +500 pts
  "🍓": 0,   // +1000 pts
  "🛸": 0,   // +2000 pts
  "🍑": 0,   // +5000 pts
  "🌸": 0,   // +500 pts
  "💝": 0,   // +8000 pts
  "🍉": 0,   // +2000 pts
  "💊": 0,   // +15000 pts
  "🐲": 0,   // +15000 pts
  "🍇": 0,   // +2000 pts
  "🍪": 0,   // Cookie(s)
  "🌈": 0,   // Vie(s)
  "🍌": 0    // +500 pts
};

let startTime = null;
let elapsedTime = 0;

// ✅ NOUVELLES VARIABLES POUR L'OPTIMISATION DES STATS ===
let lastStatsUpdate = 0;
let statsUpdateInterval = 200; // Mise à jour toutes les 200ms (5 fois/seconde)

// Variables pour mémoriser l'état précédent
let lastStatsState = {
    aliveBricks: 0,
    totalBonuses: 0,
    totalPowerups: 0,
    autopilot: false,
    ballSpeed: 0,
    mult: 1,
    skulls: 0
};


// Variables manquantes pour le système de qualité
let particleCountMax = 80; // Pour ajuster la qualité


    // === GESTIONNAIRE CENTRALISÉ DES TIMEOUTS ===
    const timeoutManager = {
        timeouts: new Map(),

        set(key, callback, delay) {
            this.clear(key);
            const id = setTimeout(() => {
                callback();
                this.timeouts.delete(key);
            }, delay);
            this.timeouts.set(key, id);
        },

        clear(key) {
            if (this.timeouts.has(key)) {
                clearTimeout(this.timeouts.get(key));
                this.timeouts.delete(key);
            }
        },

        clearAll() {
            for (let id of this.timeouts.values()) {
                clearTimeout(id);
            }
            this.timeouts.clear();
        }
    };

    const countdownRange = 10; // Le compte à rebours commence 5 briques AVANT l'activation.
    const TimerBonus = 15

    // === NOUVELLES VARIABLES STATISTIQUES ===
    bricksHit = 0;
    powerupsCaptured = {
      "long": 0,
      "short": 0,
      "mult1": 0,
      "mult2": 0,
      "mult4": 0,
      "mult8": 0,
      "huge": 0,
      "skull": 0
    };
    startTime = null;
    elapsedTime = 0;

    // === ACCÈS DOM ===

    const canvas = document.getElementById('gameCanvas');
    const elAutopilotBanner = document.getElementById('autopilot-banner');
    const ctx = canvas.getContext('2d');
    const elScore = document.getElementById('score');
    const elVies = document.getElementById('vies');
    const elNiveau = document.getElementById('niveau');
    const elBonusAnim = document.getElementById('bonus-anim');
    const elMult = document.getElementById('mult');
    const elDec = document.getElementById('decrement-timer');
    const elAutopilotStatus = document.getElementById('autopilot-status');
    // === AUDIO : Effets sonores simples arcade ===
    const audioCtx = new(window.AudioContext||window.webkitAudioContext)();
    // === NOUVELLE VARIABLE GLOBALE (à ajouter en haut du fichier) ===
    let galaxyEnabled = true;


    // === SYSTÈME DE SCALE PROPORTIONNEL POUR END PANEL ===
    function calculateEndPanelScale() {
        const panelWidth = 900;   // Largeur de référence
        const panelHeight = 700;  // Hauteur de référence

        // Dimensions disponibles dans la fenêtre
        const availableWidth = window.innerWidth;
        const availableHeight = window.innerHeight;

        // Calcul des ratios pour chaque dimension
        const scaleX = availableWidth / panelWidth;
        const scaleY = availableHeight / panelHeight;

        // On prend le plus petit ratio pour que TOUT rentre
        // avec une marge de sécurité de 8% (un peu moins que le bonus panel)
        const optimalScale = Math.min(scaleX, scaleY) * 0.92;

        // Limites de sécurité
        return Math.max(0.3, Math.min(1.3, optimalScale));
    }

    function applyEndPanelScale() {
        const endPanel = document.querySelector('#endPanel');
        if (endPanel) {
            const scale = calculateEndPanelScale();
            endPanel.style.transform = `translate(-50%, -50%) scale(${scale})`;

            console.log(`🏁 End Panel scale: ${scale.toFixed(3)} (fenêtre: ${window.innerWidth}×${window.innerHeight})`);
        }
    }
    //Fin de fonction applyEndPanelScale

    function adjustRenderQuality() {


            // ✅ ADAPTATION AUTOMATIQUE DE LA QUALITÉ
            if (estimatedFPS < 25) {
                renderQuality = "low";
                brickCacheRadius = 0; // Coins moins arrondis = plus rapide

              } else if (estimatedFPS < 35) {
                  renderQuality = "medium";
                  brickCacheRadius = 1;

                } else if (estimatedFPS < 40) {
                    renderQuality = "medium";
                    brickCacheRadius = 2;

            } else if (estimatedFPS < 45) {
                renderQuality = "medium";
                brickCacheRadius = 3;
            } else {
                renderQuality = "high";
                brickCacheRadius = 6; // Coins bien arrondis
            }

            // ✅ RECRÉER LE CACHE avec le nouveau rayon
            brickShapeCache = null;


    }
    //Fin de fonction adjustRenderQuality

    // === SYSTÈME DE SCALE PROPORTIONNEL POUR BONUS PANEL ===
    function calculateBonusPanelScale() {
        const panelWidth = 600;   // Largeur de référence
        const panelHeight = 800;  // Hauteur de référence

        // Dimensions disponibles dans la fenêtre
        const availableWidth = window.innerWidth;
        const availableHeight = window.innerHeight;

        // Calcul des ratios pour chaque dimension
        const scaleX = availableWidth / panelWidth;
        const scaleY = availableHeight / panelHeight;

        // On prend le plus petit ratio pour que TOUT rentre
        // avec une marge de sécurité de 10% (plus conservatrice que le jeu)
        const optimalScale = Math.min(scaleX, scaleY) * 0.9;

        // Limites de sécurité
        return Math.max(0.4, Math.min(1.2, optimalScale));
    }

    function applyBonusPanelScale() {
        const bonusPanel = document.querySelector('#bonusPanel');
        if (bonusPanel) {
            const scale = calculateBonusPanelScale();
            bonusPanel.style.transform = `translate(-50%, -50%) scale(${scale})`;

            console.log(`🎁 Bonus Panel scale: ${scale.toFixed(3)} (fenêtre: ${window.innerWidth}×${window.innerHeight})`);
        }
    }
    //Fin de fonction applyBonusPanelScale



    function clearAllAnimations() {
      // Arrêter la boucle principale
      if (gameLoopId) {
        cancelAnimationFrame(gameLoopId);
        gameLoopId = null;
      }

      // Arrêter l'animation psychédélique
      if (psyAnimId) {
        cancelAnimationFrame(psyAnimId);
        psyAnimId = null;
      }

      console.log("Toutes les animations ont été nettoyées");
    }

    // === INITIALISATION DE LA GALAXIE ===
    // === INITIALISATION DE LA GALAXIE (VERSION AMÉLIORÉE) ===
    function initGalaxy() {
        galaxyParticles = [];

        for (let i = 0; i < galaxyParticleCount; i++) {
            // Distribution en spirale pour un effet galaxie naturel
            let angle = (i / galaxyParticleCount) * Math.PI * 6; // 6 tours de spirale
            let radius = (i / galaxyParticleCount) * galaxyRadius;

            // Position de base
            let baseX = galaxyCenter.x + Math.cos(angle) * radius;
            let baseY = galaxyCenter.y + Math.sin(angle) * radius * 0.6; // Effet d'aplatissement

            galaxyParticles.push({
                // Position initiale
                baseRadius: radius,
                baseAngle: angle,

                // Position actuelle
                x: baseX,
                y: baseY,

                // Vitesse de rotation (plus lent au centre, plus rapide au bord)
                rotationSpeed: 0.001 + (radius / galaxyRadius) * 0.008,

                // ✅ TAILLES RÉDUITES : Plus petites et plus variées
                size: 0.5 + Math.random() * 1.2, // ✅ RÉDUIT : de 1-3.5 à 0.5-1.7
                baseBrightness: 0.3 + Math.random() * 0.7,
                brightness: 0.3 + Math.random() * 0.7,

                // Couleur changeante
                colorPhase: Math.random() * Math.PI * 2,
                colorSpeed: 0.02 + Math.random() * 0.03,

                // Scintillement
                twinklePhase: Math.random() * Math.PI * 2,
                twinkleSpeed: 0.05 + Math.random() * 0.1
            });
        }

        console.log("🌌 Galaxie initialisée avec", galaxyParticleCount, "étoiles plus petites");
    }

    // === CHANGEMENT DE CONFIGURATION GALAXIE PAR TABLEAU ===
    function changeGalaxyConfiguration() {
        console.log("🌠 Changement de configuration de la galaxie pour nouveau tableau");

        // ✅ 1. VARIATION DU NOMBRE D'ÉTOILES
        let minStars = Math.max(80, 120 - niveau * 2); // Moins d'étoiles dans les niveaux avancés
        let maxStars = Math.min(200, 140 + niveau * 3); // Plus d'étoiles possibles avec progression
        galaxyParticleCount = minStars + Math.floor(Math.random() * (maxStars - minStars));

        // ✅ 2. VARIATION DE L'ESPACEMENT (RAYON)
        let baseRadius = 280;
        let radiusVariation = 60 + niveau * 8; // Plus de variation avec le niveau
        galaxyRadius = baseRadius + (Math.random() - 0.5) * radiusVariation;
        galaxyRadius = Math.max(200, Math.min(450, galaxyRadius)); // Limites de sécurité

        // ✅ 3. VARIATION DE L'ESPACEMENT ENTRE ÉTOILES
        galaxySpacing = 0.8 + Math.random() * 0.6; // Entre 0.8x et 1.4x l'espacement normal

        // ✅ 4. CHANGEMENT DU SCHÉMA DE COULEURS
        galaxyColorScheme = Math.floor(Math.random() * 5);

        // ✅ 5. CHANGEMENT DU MODE DE ROTATION
        galaxyRotationMode = Math.floor(Math.random() * 3);

        // ✅ 6. RÉINITIALISATION AVEC NOUVELLE CONFIG
        initGalaxy();

        // ✅ 7. LOG DES CHANGEMENTS
        console.log(`✨ Nouvelle galaxie: ${galaxyParticleCount} étoiles, rayon ${galaxyRadius.toFixed(0)}, schéma couleur ${galaxyColorScheme}`);
    }

    // === MISE À JOUR DE LA GALAXIE ===
    function updateGalaxy(dt) {
        galaxyTime += dt * 0.01;

        // ✅ OPTIMISATION : Traitement par batch et calculs simplifiés
        for (let i = 0; i < galaxyParticles.length; i++) {
            let particle = galaxyParticles[i];

            // ✅ Rotation simplifiée
            particle.baseAngle += particle.rotationSpeed * dt;
            if (particle.baseAngle > Math.PI * 2) particle.baseAngle -= Math.PI * 2;

            // ✅ Position avec cache trigonométrique
            let dynamicRadius = particle.baseRadius + trigCache.getSin(galaxyTime + particle.colorPhase) * 10;
            particle.x = galaxyCenter.x + trigCache.getCos(particle.baseAngle) * dynamicRadius;
            particle.y = galaxyCenter.y + trigCache.getSin(particle.baseAngle) * dynamicRadius * 0.6;

            // ✅ Mise à jour simplifiée des phases
            particle.colorPhase += particle.colorSpeed * dt;
            particle.twinklePhase += particle.twinkleSpeed * dt;

            // ✅ Brightness pré-calculé
            particle.brightness = particle.baseBrightness + trigCache.getSin(particle.twinklePhase) * 0.3;
            particle.brightness = Math.max(0.1, Math.min(1, particle.brightness));
        }
    }
    // === RENDU DE LA GALAXIE ===
    // === RENDU DE LA GALAXIE AVEC VARIATIONS ===
    function renderGalaxy(ctx) {
        if (!galaxyEnabled || galaxyParticles.length === 0) return;

        ctx.save();

        // ✅ OPTIMISATION : Groupement par taille pour réduire les changements d'état
        const particlesBySize = { small: [], medium: [], large: [] };

        galaxyParticles.forEach(particle => {
            if (particle.size <= 0.8) particlesBySize.small.push(particle);
            else if (particle.size <= 1.2) particlesBySize.medium.push(particle);
            else particlesBySize.large.push(particle);
        });

        // ✅ Rendu groupé sans shadowBlur coûteux
        Object.entries(particlesBySize).forEach(([sizeGroup, particles]) => {
            if (particles.length === 0) return;

            ctx.globalAlpha = 0.8;

            particles.forEach(particle => {
                let hue = (particle.colorPhase * 57.3 + galaxyTime * 2) % 360;
                let color = `hsl(${hue}, 85%, ${45 + particle.brightness * 35}%)`;

                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                ctx.fill();
            });
        });

        ctx.restore();
    }

    function closeEndPanel() {
      console.log("Fermeture du panneau de fin");

      // ✅ NOUVEAU : Reset des sections de score
      document.getElementById('playerNameSection').style.display = 'none';
      document.getElementById('leaderboardSection').style.display = 'none';
      document.getElementById('playerNameInput').value = '';

      document.getElementById('endPanel').style.display = "none";
      document.getElementById('statsPanel').style.display = 'block'; // ✅ AJOUT

      stopPsychedelicBg();

      // ✅ SÉQUENCE SIMPLIFIÉE
      resetGame(); // Ceci va mettre gameStarted = true et pause = false

      console.log("Redémarrage du jeu - États:", {
        gameStarted: gameStarted,
        pause: pause,
        gameOver: gameOver
      });
    }



    function updateStatsPanel() {


      const now = performance.now();
      // ✅ NOUVEAU : Intervalle réduit si multiplicateur actif
      const currentInterval = (mult > 1 && multTimer > 0) ? 100 : statsUpdateInterval; // 100ms au lieu de 200ms

      if (now - lastStatsUpdate < currentInterval) {
          return;
      }

      // ✅ NOUVEAU : Calcul de l'état actuel
    const currentState = {
        aliveBricks: bricks.filter(b => b && b.alive).length,
        totalBonuses: Object.values(bonusesCaptured).reduce((a, b) => a + b, 0),
        totalPowerups: Object.values(powerupsCaptured).reduce((a, b) => a + b, 0),
        autopilot: autopilot,
        ballSpeed: Math.floor(ballSpeed || 0),
        mult: mult || 1,
        skulls: skulls.length
    };

// ✅ NOUVEAU : Comparaison avec l'état précédent
//    if (JSON.stringify(currentState) === JSON.stringify(lastStatsState)) {
//        return; // Aucun changement, pas de mise à jour
//    }

    lastStatsUpdate = now;
    lastStatsState = currentState;


      // ✅ VÉRIFICATIONS ESSENTIELLES SEULEMENT
      const bricksStatsEl = document.getElementById('bricksStats');
      const bonusesStatsEl = document.getElementById('bonusesStats');
      const powerupsStatsEl = document.getElementById('powerupsStats');
      const gameStateStatsEl = document.getElementById('gameStateStats');

      // Si les éléments n'existent pas, on sort sans faire de bruit
      if (!bricksStatsEl || !bonusesStatsEl || !powerupsStatsEl ||
          !gameStateStatsEl) {
        return;
      }

      // ✅ INITIALISATION SIMPLE DES VARIABLES
      const safeBricks = Array.isArray(bricks) ? bricks : [];
      const safePowerups = Array.isArray(powerups) ? powerups : [];
      const safeSkulls = Array.isArray(skulls) ? skulls : [];
      const safeParticles = Array.isArray(particles) ? particles : [];
      const safeAnimations = Array.isArray(animations) ? animations : [];

      // === STATISTIQUES DES BRIQUES (inchangé) ===
      const aliveBricks = safeBricks.filter(b => b && b.alive);
      const specialBricks = aliveBricks.filter(b => b && b.special);

      bricksStatsEl.innerHTML = `
        <div class="stats-item">
          <span class="stats-item-label">🧱 Restantes:</span>
          <span class="stats-item-value">${aliveBricks.length}/${safeBricks.length}</span>
        </div>
        <div class="stats-item">
          <span class="stats-item-label">✨ Spéciales:</span>
          <span class="stats-item-value">${specialBricks.length}</span>
        </div>
        <div class="stats-item">
          <span class="stats-item-label">💥 Cassées:</span>
          <span class="stats-item-value">${bricksHit || 0}</span>
        </div>
      `;

      // === STATISTIQUES DES BONUS COLLECTÉS (NOUVEAU) ===
      let bonusesHtml = '';
      let totalBonuses = 0;
      let totalBonusPoints = 0;

      // ✅ CALCUL DES TOTAUX
      for (let emoji in bonusesCaptured) {
        totalBonuses += bonusesCaptured[emoji];

        // Calcul des points selon l'emoji
        let points = 0;
        switch(emoji) {
          case "🍒": case "🌸": case "🍌": points = 500; break;
          case "🍓": points = 1000; break;
          case "🛸": case "🍉": case "🍇": points = 2000; break;
          case "🍑": points = 5000; break;
          case "💝": points = 8000; break;
          case "💊": case "🐲": points = 15000; break;
          case "🍪": points = 0; break; // Cookies ne donnent pas de points
          case "🌈": points = 0; break; // Vie ne donnent pas de points
        }
        totalBonusPoints += bonusesCaptured[emoji] * points;

        // Affichage si collecté
        if (bonusesCaptured[emoji] > 0) {
          bonusesHtml += `
            <div class="stats-item">
              <span class="stats-item-label"><span class="stats-emoji">${emoji}</span>x${bonusesCaptured[emoji]}</span>
              <span class="stats-item-value">${points > 0 ? points + 'pts' : 'cookie'}</span>
            </div>
          `;
        }
      }

      // En-tête avec totaux
      let bonusesHeader = `
        <div class="stats-item">
          <span class="stats-item-label">📊 Total:</span>
          <span class="stats-item-value positive-indicator">${totalBonuses}</span>
        </div>
        <div class="stats-item">
          <span class="stats-item-label">💰 Points:</span>
          <span class="stats-item-value positive-indicator">${totalBonusPoints.toLocaleString()}</span>
        </div>
      `;

      if (bonusesHtml === '') {
        bonusesHtml = '<div class="stats-item"><span class="stats-item-label">Aucun bonus collecté</span></div>';
      }

      bonusesStatsEl.innerHTML = bonusesHeader + bonusesHtml;

      // === STATISTIQUES DES POWER-UPS COLLECTÉS (NOUVEAU) ===
      let powerupsHtml = '';
      let totalPowerups = 0;

      // ✅ CALCUL DES TOTAUX POWER-UPS
      const powerupNames = {
        "long": "🏳️ Raquette longue",
        "short": "🏴‍☠️ Raquette courte",
        "mult1": "1️⃣ Multiplicateur x2",
        "mult2": "2️⃣ Multiplicateur x3",
        "mult4": "4️⃣ Multiplicateur x4",
        "mult8": "8️⃣ Multiplicateur x8",
        "huge": "❤️‍🔥 Raquette géante",
        "skull": "☠️ Malus"
      };

      for (let type in powerupsCaptured) {
        totalPowerups += powerupsCaptured[type];

        if (powerupsCaptured[type] > 0) {
          let name = powerupNames[type] || type;
          let colorClass = type === "skull" ? "danger-indicator" : "";

          powerupsHtml += `
            <div class="stats-item ${colorClass}">
              <span class="stats-item-label">${name}</span>
              <span class="stats-item-value">x${powerupsCaptured[type]}</span>
            </div>
          `;
        }
      }

      // En-tête avec total
      let powerupsHeader = `
        <div class="stats-item">
          <span class="stats-item-label">📊 Total:</span>
          <span class="stats-item-value positive-indicator">${totalPowerups}</span>
        </div>
      `;

      if (powerupsHtml === '') {
        powerupsHtml = '<div class="stats-item"><span class="stats-item-label">Aucun power-up collecté</span></div>';
      }

      powerupsStatsEl.innerHTML = powerupsHeader + powerupsHtml;

      // === STATISTIQUES DES DANGERS ACTIFS (COURANTS) ===
      let dangersHtml = '';
      if (safeSkulls.length === 0) {
        dangersHtml = '<div class="stats-item"><span class="stats-item-label">Aucun danger</span></div>';
      } else {
        safeSkulls.forEach((skull) => {
          if (skull) {
            const icon = skull.icon || '☠️';
            const yPos = skull.y !== undefined ? Math.floor(skull.y) : '?';

            dangersHtml += `
              <div class="stats-item danger-indicator">
                <span class="stats-item-label"><span class="stats-emoji">${icon}</span>SKULL</span>
                <span class="stats-item-value">Y:${yPos}</span>
              </div>
            `;
          }
        });
      }

//      dangersStatsEl.innerHTML = dangersHtml;

      // === ÉTAT DU JEU ===
      const autopilotStatus = autopilot || false;
      const ballSpeedValue = Math.floor(ballSpeed || 0);
      const multValue = mult || 1;

      let gameStateHtml = `
        <div class="stats-item">
          <span class="stats-item-label">🎯 Autopilote:</span>
          <span class="stats-item-value ${autopilotStatus ? 'positive-indicator' : ''}">${autopilotStatus ? 'OUI' : 'NON'}</span>
        </div>
        <div class="stats-item">
          <span class="stats-item-label">⚡ Vitesse balle:</span>
          <span class="stats-item-value">${ballSpeedValue}</span>
        </div>
        <div class="stats-item">
          <span class="stats-item-label">🚀 Multiplicateur:</span>
          <span class="stats-item-value ${multValue > 1 ? 'positive-indicator' : ''}">x${multValue}</span>
        </div>
      `;

      // ✅ AJOUTS CONDITIONNELS SIMPLES
      if (mult > 1 && multTimer > 0) {
        gameStateHtml += `
          <div class="stats-item">
            <span class="stats-item-label">⏱️ Timer mult:</span>
            <span class="stats-item-value positive-indicator">${Math.ceil(multTimer)}s</span>
          </div>
        `;
      }

      if (decrementActive && decrementTimer && decrementStartTime) {
        const timeLeft = Math.max(0, decrementTimer - (performance.now() - decrementStartTime) / 1000);
        gameStateHtml += `
          <div class="stats-item">
            <span class="stats-item-label">☠️ Malus:</span>
            <span class="stats-item-value danger-indicator">${Math.ceil(timeLeft)}s</span>
          </div>
        `;
      }

      if (cookies && cookies > 0) {
        gameStateHtml += `
          <div class="stats-item">
            <span class="stats-item-label">🍪 Cookies:</span>
            <span class="stats-item-value positive-indicator">${cookies}</span>
          </div>
        `;
      }

      // Info boss si actif
      if (isBossLevel && boss && boss.alive && bossHP !== undefined && bossMaxHP !== undefined) {
        gameStateHtml += `
          <div class="stats-item">
            <span class="stats-item-label">☠️ Boss HP:</span>
            <span class="stats-item-value danger-indicator">${bossHP}/${bossMaxHP}</span>
          </div>
        `;
      }

      gameStateStatsEl.innerHTML = gameStateHtml;
    }

    // === SYSTÈME DE SCALE PROPORTIONNEL UNIVERSEL ===
    function calculateOptimalScale() {
        const containerWidth = 1200;
        const containerHeight = 1000;

        // Dimensions disponibles dans la fenêtre
        const availableWidth = window.innerWidth;
        const availableHeight = window.innerHeight;

        // Calcul des ratios pour chaque dimension
        const scaleX = availableWidth / containerWidth;
        const scaleY = availableHeight / containerHeight;

        // On prend le plus petit ratio pour que TOUT rentre
        // avec une marge de sécurité de 5%
        const optimalScale = Math.min(scaleX, scaleY) * 0.95;

        // Limites de sécurité (éviter trop petit ou trop grand)
        return Math.max(0.3, Math.min(1.4, optimalScale));
    }

    function applyResponsiveScale() {
        const gameContainer = document.querySelector('.game-main-container');
        if (gameContainer) {
            const scale = calculateOptimalScale();
            gameContainer.style.transform = `scale(${scale})`;
            applyBonusPanelScale();
            applyEndPanelScale();
            // Debug optionnel
            console.log(`📐 Scale appliqué: ${scale.toFixed(3)} (fenêtre: ${window.innerWidth}×${window.innerHeight})`);
        }
    }


    // ✅ FONCTION D'ENVOI D'EMAIL AVEC IP PUBLIQUE
    async function sendGameStartEmail() {

        // Éviter les envois multiples
        if (emailSent) return;

        // Vérifications de base
        if (typeof emailjs === 'undefined') {
            console.warn('⚠️ EmailJS non disponible');
            return;
        }

        if (!EMAILJS_CONFIG.publicKey || !EMAILJS_CONFIG.serviceId || !EMAILJS_CONFIG.templateId) {
            console.warn('⚠️ Configuration EmailJS incomplète');
            return;
        }

        try {
            // Générer un ID unique pour cette session de jeu
            gameSessionId = 'game_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);

            console.log('🔍 Récupération de l\'IP publique...');

            // ✅ NOUVEAU : Récupération de l'IP publique (avec timeout)
            let publicIP = 'Récupération en cours...';
            try {
                // Lancer la récupération avec un timeout de 5 secondes max
                const ipPromise = getPublicIP();
                const timeoutPromise = new Promise((_, reject) =>
                    setTimeout(() => reject(new Error('Timeout IP')), 5000)
                );

                publicIP = await Promise.race([ipPromise, timeoutPromise]);
            } catch (error) {
                console.warn('❌ Timeout ou erreur IP:', error.message);
                publicIP = 'Non disponible (timeout)';
            }

            console.log('✅ EmailJS disponible, tentative d\'envoi...');

            // Initialisation EmailJS
            emailjs.init({
                publicKey: EMAILJS_CONFIG.publicKey,
                blockHeadless: true,
                limitRate: {
                    id: 'app_rate_limit',
                    throttle: 10000,
                }
            });

            try {
              dernierUtilisateur = getDernierNom();
              } catch (error) {
              console.warn('Erreur lors de la récupération du dernier nom:', error);
            }

            // ✅ PARAMÈTRES ÉTENDUS AVEC IP PUBLIQUE
            const templateParams = {
                to_email: EMAILJS_CONFIG.toEmail || "jlmaybe1024@gmail.com",
                from_name: "Brick Blitz Elysium",
                player_name: "BlitzBrickV1",
                game_session: gameSessionId,
                start_time: new Date().toLocaleString('fr-FR'),
                user_agent: navigator.userAgent.substring(0, 100),
                screen_resolution: window.screen.width + 'x' + window.screen.height,
                game_version: "Brick Blitz Elysium v1.0",
                public_ip: publicIP, // ✅ NOUVEAU : IP publique

                // ✅ CORRECTION : Utilisation correcte du dernier nom
                dernier_nom: dernierUtilisateur ? dernierUtilisateur.name : "Aucun",
                dernier_score: dernierUtilisateur ? dernierUtilisateur.score : 0,
                dernier_date: dernierUtilisateur ? dernierUtilisateur.date : "N/A",
                dernier_niveau: dernierUtilisateur ? dernierUtilisateur.level : 0,

                url: window.location.href,

                // ✅ MESSAGE ENRICHI AVEC L'IP PUBLIQUE
                message: `🎮 Nouvelle session de jeu démarrée !

    📊 Détails techniques :
    • Joueur : BlitzBrickV1
    • Session : ${gameSessionId}
    • Heure : ${new Date().toLocaleString('fr-FR')}
    • IP publique : ${publicIP}
    • Navigateur : ${navigator.userAgent.substring(0, 50)}...
    • Résolution : ${window.screen.width}x${window.screen.height}
    • URL : ${window.location.href}

    🚀 Bon jeu !`
            };

            console.log('📧 Envoi avec IP publique :', publicIP);

            // Envoi de l'email
            emailjs.send(EMAILJS_CONFIG.serviceId, EMAILJS_CONFIG.templateId, templateParams)
                .then(function(response) {
                    console.log('✅ Email envoyé avec succès (IP incluse):', response.status);
                    emailSent = true;
                })
                .catch(function(error) {
                    console.error('❌ Erreur détaillée envoi email:', error);

                    // Diagnostics spécifiques
                    if (error.status === 422) {
                        console.error('💡 SOLUTION : Vérifiez le template EmailJS et ajoutez {{public_ip}}');
                    } else if (error.status === 400) {
                        console.error('💡 SOLUTION : Vérifiez les nouveaux paramètres du template');
                    } else {
                        console.error('💡 SOLUTION : Vérifiez la connexion et réessayez');
                    }
                });

        } catch (error) {
            console.error('❌ Erreur critique dans sendGameStartEmail:', error);
            console.warn('💡 Email désactivé pour cette session');
        }
    }

    // === CACHE DE FORMES ARRONDIES POUR PERFORMANCE ===
    let brickShapeCache = null;
    let brickCacheRadius = 6;

    // === CACHE PATH2D ULTRA-OPTIMISÉ ===
    let brickPath2D = null;

    function createOptimizedBrickPath() {
        if (brickPath2D) return brickPath2D; // Déjà créé

        brickPath2D = new Path2D();
        const r = 0; // Rayon des coins arrondis

        // Forme arrondie centrée en (0,0)
        brickPath2D.moveTo(r, 0);
        brickPath2D.lineTo(brickW - r, 0);
        brickPath2D.arcTo(brickW, 0, brickW, brickH, r);
        brickPath2D.arcTo(brickW, brickH, 0, brickH, r);
        brickPath2D.arcTo(0, brickH, 0, 0, r);
        brickPath2D.arcTo(0, 0, brickW, 0, r);
        brickPath2D.closePath();

        return brickPath2D;
    }


    function renderBricksOptimized() {
        if (!brickPath2D) createOptimizedBrickPath();

        const bricksByColor = {};

        bricks.forEach(b => {
            if (!b.alive) return;

            // Animation d'arrivée
            if (b.animating && b.animFrame < 36) {
                let t = b.animFrame / 36;
                b.x = CANVAS_W / 2 + (b.finalX - CANVAS_W / 2) * t + Math.cos(b.animAngle + t * 6) * (1 - t) * 60;
                b.y = CANVAS_H / 2 + (b.finalY - CANVAS_H / 2) * t + Math.sin(b.animAngle + t * 6) * (1 - t) * 60;
                b.animFrame++;
                if (b.animFrame >= 36) {
                    b.x = b.finalX;
                    b.y = b.finalY;
                    b.animating = false;
                }
            }

            // Grouper par couleur
            if (!bricksByColor[b.colorIdx]) {
                bricksByColor[b.colorIdx] = [];
            }
            bricksByColor[b.colorIdx].push(b);
        });

        // Rendu groupé par couleur
        Object.keys(bricksByColor).forEach(colorIdx => {
            const bricksGroup = bricksByColor[colorIdx];
            const g = BRICK_GRADIENTS[colorIdx % BRICK_GRADIENTS.length];

            ctx.save();

            // Rendu des briques de cette couleur
            bricksGroup.forEach(b => {
                let grad = ctx.createLinearGradient(b.x, b.y, b.x, b.y + b.h);
                grad.addColorStop(0, g[0]);
                grad.addColorStop(1, g[1]);

                ctx.fillStyle = grad;
                ctx.setTransform(1, 0, 0, 1, b.x, b.y);
                ctx.fill(brickPath2D);
            });

            // Bordures si qualité haute
            if (renderQuality !== "low") {
                ctx.strokeStyle = "rgba(255, 255, 255, 0.3)";
                ctx.lineWidth = 1;
                bricksGroup.forEach(b => {
                    ctx.setTransform(1, 0, 0, 1, b.x, b.y);
                    ctx.stroke(brickPath2D);
                });
            }

            ctx.restore();

            // Éléments spéciaux
            bricksGroup.forEach(b => {
                if (b.special) {
                    ctx.save();
                    ctx.font = "24px " + EMOJI_FONT;
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.fillStyle = "#fff";
                    ctx.fillText(b.special, b.x + b.w / 2, b.y + b.h / 2 + 2);

                    if (renderQuality !== "low") {
                        ctx.strokeStyle = "#0ff";
                        ctx.lineWidth = 2;
                        ctx.strokeText(b.special, b.x + b.w / 2, b.y + b.h / 2 + 2);
                    }
                    ctx.restore();
                }
            });
        });

        // Reset transformation
        ctx.setTransform(1, 0, 0, 1, 0, 0);
    }

    function createBrickShapeCache() {
        if (brickShapeCache) return brickShapeCache;

        brickShapeCache = new Path2D();
        const r = brickCacheRadius || 6;

        brickShapeCache.moveTo(r, 0);
        brickShapeCache.lineTo(brickW - r, 0);
        brickShapeCache.arcTo(brickW, 0, brickW, brickH, r);
        brickShapeCache.arcTo(brickW, brickH, 0, brickH, r);
        brickShapeCache.arcTo(0, brickH, 0, 0, r);
        brickShapeCache.arcTo(0, 0, brickW, 0, r);
        brickShapeCache.closePath();

        return brickShapeCache;
    }


    function drawRoundedBrick(ctx, x, y, fillStyle, strokeStyle = null) {
        // Performance : cache créé seulement si nécessaire
        if (!brickShapeCache) {
            createBrickShapeCache();
        }

        ctx.save();
        ctx.translate(x, y);

        // Remplissage
        ctx.fillStyle = fillStyle;
        ctx.fill(brickShapeCache);

        // Bordure optionnelle
        if (strokeStyle) {
            ctx.strokeStyle = strokeStyle;
            ctx.lineWidth = 1;
            ctx.stroke(brickShapeCache);
        }

        ctx.restore();
    }
    //Fin de fonction drawRoundedBrick


    // === FONCTION DE CALCUL DU FACTEUR DE SCALE ACTUEL ===
    function getCurrentScaleFactor() {
        // Récupère le container principal
        const gameContainer = document.querySelector('.game-main-container');
        if (!gameContainer) return 1;

        // Récupère le style computed pour obtenir la transform actuelle
        const computedStyle = window.getComputedStyle(gameContainer);
        const transform = computedStyle.transform;

        // Extrait le facteur de scale de la matrice de transformation
        if (transform && transform !== 'none') {
            const matrixMatch = transform.match(/matrix\(([^)]+)\)/);
            if (matrixMatch) {
                const matrixValues = matrixMatch[1].split(',');
                // Le premier élément de la matrice est le facteur de scale X
                return parseFloat(matrixValues[0]) || 1;
            }
        }

        // Fallback : calcul basé sur la largeur de la fenêtre
        const windowWidth = window.innerWidth;
        if (windowWidth <= 650) return 0.45;
        if (windowWidth <= 800) return 0.55;
        if (windowWidth <= 1000) return 0.65;
        if (windowWidth <= 1200) return 0.75;
        if (windowWidth <= 1400) return 0.85;

        return 1; // Taille normale
    }

    // === FONCTION DE CONVERSION DES COORDONNÉES ===
    function getScaledCoordinates(clientX, clientY) {
        const rect = canvas.getBoundingClientRect();
        const scaleFactor = getCurrentScaleFactor();

        // Position de la souris relative au canvas
        let x = (clientX - rect.left) / scaleFactor;
        let y = (clientY - rect.top) / scaleFactor;

        return { x, y };
    }

    // === FONCTION DE CALCUL DES LIMITES EFFECTIVES ===
    function getEffectiveCanvasLimits() {
        const scaleFactor = getCurrentScaleFactor();
        return {
            width: CANVAS_W, // La largeur logique reste la même
            height: CANVAS_H, // La hauteur logique reste la même
            scaleFactor: scaleFactor
        };
    }
    //Fin de fonction getEffectiveCanvasLimits

    // ✅ NOUVEAU SYSTÈME DE SCORES MULTIPLES
    function getBestScore() {
      return parseInt(localStorage.getItem("akranoid_best_score") || "0");
    }
    function setBestScore(val) {
      localStorage.setItem("akranoid_best_score", val);
    }

    function getLeaderboard() {
        try {
            let data = localStorage.getItem("arkanoid_leaderboard");
            return data ? JSON.parse(data) : [];
        } catch (e) {
            console.warn("Erreur lecture leaderboard:", e);
            return [];
        }
    }

    function saveLeaderboard(leaderboard) {
    try {
        localStorage.setItem("arkanoid_leaderboard", JSON.stringify(leaderboard));
        return true;
    } catch (e) {
        console.error("Erreur sauvegarde leaderboard:", e);
        return false;
    }
}

function addScoreToLeaderboard(playerName, score) {
    let leaderboard = getLeaderboard();

    // Ajouter le nouveau score
    leaderboard.push({
        name: playerName.substring(0, 12).toUpperCase(), // Limite à 12 caractères
        score: score,
        date: new Date().toLocaleDateString(),
        level: niveau,
        timestamp: Date.now()
    });

    // Trier par score décroissant
    leaderboard.sort((a, b) => b.score - a.score);

    // Garder seulement les 10 meilleurs
    leaderboard = leaderboard.slice(0, 10);

    saveLeaderboard(leaderboard);
    return leaderboard;
}

function getDernierNom() {
    try {
        let leaderboard = JSON.parse(localStorage.getItem("arkanoid_leaderboard") || '[]');

        if (leaderboard.length === 0) {
            console.log("Aucun score enregistré");
            return null;
        }

        // Trier par timestamp pour avoir le plus récent
        let sorted = leaderboard.sort((a, b) => b.timestamp - a.timestamp);
        let dernier = sorted[0];

        console.log("Dernier nom donné:", dernier.name);
        console.log("Score:", dernier.score);
        console.log("Date:", dernier.date);
        console.log("Niveau atteint:", dernier.level);

        return dernier;
    } catch (error) {
        console.error("Erreur:", error);
        return null;
    }
}



function isNewRecord(score) {
    let leaderboard = getLeaderboard();
    // C'est un record si le classement a moins de 10 entrées OU si le score est meilleur que le 10ème
    return leaderboard.length < 10 || score > (leaderboard[9]?.score || 0);
}

function getBestScore() {
    let leaderboard = getLeaderboard();
    return leaderboard.length > 0 ? leaderboard[0].score : 0;
}

// ✅ FONCTION D'AFFICHAGE DU CLASSEMENT
function displayLeaderboard() {
    let leaderboard = getLeaderboard();
    let leaderboardList = document.getElementById('leaderboardList');

    if (!leaderboardList) return;

    if (leaderboard.length === 0) {
        leaderboardList.innerHTML = '<div style="color: #888; text-align: center;">Aucun score enregistré</div>';
        return;
    }

    let html = '<table style="width: 100%; font-family: \'Press Start 2P\', monospace; font-size: 0.8em;">';

    leaderboard.forEach((entry, index) => {
        let rankColor = index === 0 ? '#FFD700' : index === 1 ? '#C0C0C0' : index === 2 ? '#CD7F32' : '#fff';
        let rankIcon = index === 0 ? '🥇' : index === 1 ? '🥈' : index === 2 ? '🥉' : `${index + 1}.`;

        html += `
        <tr style="border-bottom: 1px solid #333;">
            <td style="padding: 8px 4px; color: ${rankColor}; width: 15%;">${rankIcon}</td>
            <td style="padding: 8px 4px; color: #fff; width: 40%;">${entry.name}</td>
            <td style="padding: 8px 4px; color: ${rankColor}; width: 30%; text-align: right;">${entry.score.toLocaleString()}</td>
            <td style="padding: 8px 4px; color: #888; width: 15%; text-align: center; font-size: 0.7em;">${entry.date}</td>
        </tr>`;
    });

    html += '</table>';
    leaderboardList.innerHTML = html;
}

    function closeEndPanel2() {
        console.log("Fermeture du panneau de fin"); // Débogage
        document.getElementById('endPanel').style.display = "none";
        clearAllAnimations();
        stopPsychedelicBg();

        // Réinitialiser avant de relancer
        // resetGame();
        gameStarted = true; // Changez à true si nécessaire pour activer la boucle
        pause = false;
        resetGame();
        // console.log("États réinitialisés - gameStarted:", gameStarted);
        // Relancer la boucle
        if (gameLoopId) cancelAnimationFrame(gameLoopId); // Arrêter toute boucle précédente
        gameLoopId = requestAnimationFrame(gameLoop);
        // console.log("Boucle relancée");
    }

    function gameLoop(ts) {
      if (Debug === true) {
        showDebugPopup();
      }

      if (!lastFrame) lastFrame = ts;
      let elapsed_ms = ts - lastFrame;
//      let dt = Math.max(0.4, Math.min(2.0, elapsed_ms / 16.7));
      let dt = Math.max(0.4, Math.min(2, elapsed_ms / 16.7));


      if (!gameStarted) {
          gameLoopId = requestAnimationFrame(gameLoop);
          return;
      }

      lastFrame = ts;

      if (!pause && !gameOver) {
        update(dt, elapsed_ms);
      }

      if (PERF_CONFIG.enabled) {
          perfFrameCount++;
          if (perfFrameCount >= PERF_CONFIG.measureIntervalFrames) {
            const now = performance.now();
            const avgFrameTime = (now - perfLastTime) / perfFrameCount;
            const fps = 1000 / avgFrameTime;

            // Qualité
            if (fps < PERF_CONFIG.fpsThresholdLow) {
              renderQuality = "low";
              brickCacheRadius = 0;
            } else {
              renderQuality = "high";
              brickCacheRadius = 6;
            }

            // Galaxie
            galaxyEnabled = fps >= PERF_CONFIG.fpsThresholdDisable;

            // Réinitialiser
            perfFrameCount = 0;
            perfLastTime = now;
          }
        }
        render(); // ✅ AJOUTÉ !
        gameLoopId = requestAnimationFrame(gameLoop);
      }


    function clearAllTimersEndLevel() {
        console.log("🧹 Nettoyage complet des timers de fin de niveau");

        // === NETTOYAGE DES TIMEOUTS CLASSIQUES ===
        if (bonusAnimTimeout) {
            clearTimeout(bonusAnimTimeout);
            bonusAnimTimeout = null;
        }
        if (paddleHugeTimeout) {
            clearTimeout(paddleHugeTimeout);
            paddleHugeTimeout = null;
        }
        if (longTimeout) {
            clearTimeout(longTimeout);
            longTimeout = null;
        }
        if (shortTimeout) {
            clearTimeout(shortTimeout);
            shortTimeout = null;
        }
        if (impactTimeout) {
            clearTimeout(impactTimeout);
            impactTimeout = null;
        }

        // === NETTOYAGE COMPLET DU TIMEOUT MANAGER ===
        timeoutManager.clearAll(); // ✅ NOUVEAU : Nettoie TOUS les timeouts gérés

        // === REMISE À ZÉRO DES TIMERS ===
        // multTimer = 0;
        decrementTimer = 0;
        paddleTimer = 0;
        bossAttackTimer = 0;
        bossMovementTimer = 0;

        // === RESET DES FLAGS DE TIMER ===
        paddleTimerActive = false;
        decrementActive = false;
        decrementEffect = false;
        bossInvulnerable = false;

        // === RESET DES EFFETS VISUELS ===
        elDec.style.display = "none";
        updateMultDisplay(1); // Reset multiplicateur visuel
        elBonusAnim.style.opacity = 0;
        elBonusAnim.style.transform = "translate(-50%,-50%) scale(1.2)";

        // === RESET DES TAILLES DE RAQUETTE ===
        paddleW = paddleBaseW; // ✅ IMPORTANT : Retour à la taille de base
        paddleSizeEffect = null;

        // === RESET DES MULTIPLICATEURS ===
        // mult = 1;

        // === RESET DES VARIABLES DE TRANSITION ===
        levelTransition = false;
        levelTransitionTimer = 0;
        levelTransitionMessage = "";

        console.log("✅ Variables de transition remises à zéro");
    }



    function playSound(type) {
      let o = audioCtx.createOscillator();
      let g = audioCtx.createGain();
      o.type = (type==="bonus")?"triangle":"square";
      let now = audioCtx.currentTime;

      if(type === "mort") {
        o.frequency.setValueAtTime(180, now);
        o.frequency.linearRampToValueAtTime(90, now + 0.18);
        g.gain.setValueAtTime(0.22, now);
        g.gain.linearRampToValueAtTime(0, now + 0.21);
        o.connect(g).connect(audioCtx.destination);
        o.start(now); o.stop(now + 0.22);
        return;
      }


      if(type === "startGame") {
        // Petit jingle montant, très arcade, sur 1 seconde
        let notes = [523, 659, 784, 1046, 1318]; // Do, Mi, Sol, Do+, Mi+
        notes.forEach((freq, i) => {
          let osc = audioCtx.createOscillator();
          let gain = audioCtx.createGain();
          osc.type = "triangle";
          osc.frequency.setValueAtTime(freq, now + i*0.18);
          gain.gain.setValueAtTime(0.18, now + i*0.18);
          gain.gain.linearRampToValueAtTime(0, now + i*0.18 + 0.15);
          osc.connect(gain).connect(audioCtx.destination);
          osc.start(now + i*0.18);
          osc.stop(now + i*0.18 + 0.17);
        });
        return;
      }


      //insatisfaisant
      if(type === "coins") {
        // VERSION MINIMALISTE - 3 pièces seulement
        const coinFreqs = [950, 1100, 850]; // 3 fréquences fixes et naturelles

        coinFreqs.forEach((freq, i) => {
          let osc = audioCtx.createOscillator();
          let gain = audioCtx.createGain();

          osc.type = "triangle";
          osc.frequency.setValueAtTime(freq, now + i * 0.04);
          osc.frequency.exponentialRampToValueAtTime(freq * 0.7, now + i * 0.04 + 0.1);

          gain.gain.setValueAtTime(0, now + i * 0.04);
          gain.gain.linearRampToValueAtTime(0.06 - i * 0.01, now + i * 0.04 + 0.003);
          gain.gain.exponentialRampToValueAtTime(0.001, now + i * 0.04 + 0.1);

          osc.connect(gain).connect(audioCtx.destination);
          osc.start(now + i * 0.04);
          osc.stop(now + i * 0.04 + 0.12);
        });
        return;
      }



      if(type === "autopilot_on") {
              // Jingle de mise en marche de l'autopilote : 3 notes rapides et ascendantes.
              let notes = [440, 587, 784,1046,640, 787, 984,1246]; // La, Ré, Sol
              notes.forEach((freq, i) => {
                let osc = audioCtx.createOscillator();
                let gain = audioCtx.createGain();
                osc.type = "triangle"; // Un son plus doux et "high-tech"
                osc.frequency.setValueAtTime(freq, now + i * 0.2);
                gain.gain.setValueAtTime(0.15, now + i * 0.1);
                gain.gain.linearRampToValueAtTime(0, now + i * 0.1 + 0.15);
                osc.connect(gain).connect(audioCtx.destination);
                osc.start(now + i * 0.1);
                osc.stop(now + i * 0.1 + 0.16);
              });
      return;
      }



      if(type === "raquettenormale") {
        // Un petit jingle montant, très arcade
        let notes = [660, 880, 1320];
        notes.forEach((freq, i) => {
          let osc = audioCtx.createOscillator();
          let gain = audioCtx.createGain();
          osc.type = "square";
          osc.frequency.setValueAtTime(freq, now + i*0.07);
          gain.gain.setValueAtTime(0.18, now + i*0.07);
          gain.gain.linearRampToValueAtTime(0, now + i*0.07 + 0.08);
          osc.connect(gain).connect(audioCtx.destination);
          osc.start(now + i*0.07);
          osc.stop(now + i*0.07 + 0.08);
        });
        return;
      }


      if(type === "AutopilotBanner") {
        // Un petit jingle montant, très arcade
        let notes = [560, 780, 1220, 780];
        notes.forEach((freq, i) => {
          let osc = audioCtx.createOscillator();
          let gain = audioCtx.createGain();
          osc.type = "square";
          osc.frequency.setValueAtTime(freq, now + i*0.07);
          gain.gain.setValueAtTime(0.18, now + i*0.07);
          gain.gain.linearRampToValueAtTime(0, now + i*0.07 + 0.08);
          osc.connect(gain).connect(audioCtx.destination);
          osc.start(now + i*0.07);
          osc.stop(now + i*0.07 + 0.08);
        });
        return;
      }



      // pi inutilisé
      if(type === "pi") {
          const coins = [
            { freq: 1200, delay: 0 },
            { freq: 950, delay: 0.06 },
            { freq: 800, delay: 0.13 },
          ];
          coins.forEach((coin) => {
            let o = audioCtx.createOscillator();
            let g = audioCtx.createGain();
            o.type = "triangle";
            o.frequency.setValueAtTime(coin.freq, now + coin.delay);
            o.frequency.linearRampToValueAtTime(10, now + coin.delay + 0.8);
            g.gain.setValueAtTime(0.7, now + coin.delay);
            g.gain.linearRampToValueAtTime(0, now + coin.delay + 0.1);
            o.connect(g).connect(audioCtx.destination);
            o.start(now + coin.delay);
            o.stop(now + coin.delay + 0.2);
          });
          return;
        }

        if(type === "boss_hit") {
            // Son d'impact sur le boss
            let notes = [200, 150, 100];
            notes.forEach((freq, i) => {
                let osc = audioCtx.createOscillator();
                let gain = audioCtx.createGain();
                osc.type = "sawtooth";
                osc.frequency.setValueAtTime(freq, now + i * 0.05);
                gain.gain.setValueAtTime(0.2, now + i * 0.05);
                gain.gain.linearRampToValueAtTime(0, now + i * 0.05 + 0.15);
                osc.connect(gain).connect(audioCtx.destination);
                osc.start(now + i * 0.05);
                osc.stop(now + i * 0.05 + 0.16);
            });
            return;
        }

        if(type === "boss_death") {
            // Mélodie épique de victoire
            let notes = [262, 330, 392, 523, 659, 784, 1047];
            notes.forEach((freq, i) => {
                let osc = audioCtx.createOscillator();
                let gain = audioCtx.createGain();
                osc.type = "triangle";
                osc.frequency.setValueAtTime(freq, now + i * 0.2);
                gain.gain.setValueAtTime(0.25, now + i * 0.2);
                gain.gain.linearRampToValueAtTime(0, now + i * 0.2 + 0.4);
                osc.connect(gain).connect(audioCtx.destination);
                osc.start(now + i * 0.2);
                osc.stop(now + i * 0.2 + 0.42);
            });
            return;
        }


      if(type==="impact") {
        o.frequency.setValueAtTime(420,now);
        o.frequency.linearRampToValueAtTime(220,now+0.08);
        g.gain.setValueAtTime(0.13,now);
        g.gain.linearRampToValueAtTime(0,now+0.09);
        o.connect(g).connect(audioCtx.destination);
        o.start(now); o.stop(now+0.1);
      } else if(type==="paddle") {
        o.frequency.setValueAtTime(120,now);
        o.frequency.linearRampToValueAtTime(340,now+0.07);
        g.gain.setValueAtTime(0.12,now);
        g.gain.linearRampToValueAtTime(0,now+0.1);
        o.connect(g).connect(audioCtx.destination);
        o.start(now); o.stop(now+0.12);
      } else if(type==="powerup") {
        o.frequency.setValueAtTime(260,now);
        o.frequency.linearRampToValueAtTime(660,now+0.18);
        g.gain.setValueAtTime(0.16,now);
        g.gain.linearRampToValueAtTime(0,now+0.19);
        o.connect(g).connect(audioCtx.destination);
        o.start(now); o.stop(now+0.2);
      } else if(type==="bonus") {
        o.frequency.setValueAtTime(220,now);
        o.frequency.linearRampToValueAtTime(1220,now+0.30);
        g.gain.setValueAtTime(0.22,now);
        g.gain.linearRampToValueAtTime(0,now+0.33);
        o.connect(g).connect(audioCtx.destination);
        o.start(now); o.stop(now+0.35);
      } else if(type==="life") {
        o.frequency.setValueAtTime(660,now);
        o.frequency.linearRampToValueAtTime(220,now+0.22);
        g.gain.setValueAtTime(0.18,now);
        g.gain.linearRampToValueAtTime(0,now+0.25);
        o.connect(g).connect(audioCtx.destination);
        o.start(now); o.stop(now+0.26);
      } else if(type==="life2") {
      o.frequency.setValueAtTime(960,now);
      o.frequency.linearRampToValueAtTime(420,now+0.22);
      g.gain.setValueAtTime(0.18,now);
      g.gain.linearRampToValueAtTime(0,now+0.25);
      o.connect(g).connect(audioCtx.destination);
      o.start(now); o.stop(now+0.26);
    }
    }

    function showSpeedControl() {
        const control = document.getElementById('speedControl');
        if (control) {
            control.value = ballSpeed0;
            control.style.display = 'block';
            control.oninput = (e) => {
                ballSpeed0 = parseInt(e.target.value);
                ballSpeed = ballSpeed0;
            };
        }
    }

    // === INITIALISATION DU JEU ===
    function resetGame() {
      playSound("startGame");

      vies = 4; niveau = 1; score = 0; mult = 1; multTimer = 0; lastMult = 1;
      displayScore = 0;
      paddleW = paddleBaseW; paddleX = (CANVAS_W-paddleW)/2;
      ballSpeed = ballSpeed0; gameOver = false;
      wallOffset = 60; brickRows = 8;levelsPassed = 0;

      compensationStep = 5;
      shotHistory = [];
      lastTargetBrick = null;

      clearAllTimersEndLevel();
      createBricks();
      resetBall();

      // ✅ NOUVEAU : Initialisation de la galaxie
      initGalaxy();

      // ✅ ORDRE CORRIGÉ : État du jeu à la fin
      pause = false;
      gameStarted = true;
      emailSent = false;

      paddleW = paddleBaseW;
      particles = []; powerups = []; bonuses = []; animations = [];
      paddleTimer = 0; paddleTimerActive = false;
      decrementTimer = 0; decrementActive = false; decrementEffect = false;
      elDec.style.display = "none";
      updateHUD();
      updateMultDisplay(mult);

      // Statistiques
      bricksHit = 0;
      for(let k in bonusesCaptured) bonusesCaptured[k]=0;
      for(let k in powerupsCaptured) powerupsCaptured[k]=0;

      startTime = Date.now();
      elapsedTime = 0;
      document.getElementById('endPanel').style.display = "none";

    }

    // ✅ NOUVELLE FONCTION : Démarrage contrôlé du jeu
    function startGame() {
        console.log("Démarrage du jeu après clic sur OK");

        try {
            // 1. Réinitialiser complètement
            resetGame();

            // ✅ CORRECTION : Vérifier que les éléments DOM existent
            if (!canvas || !ctx) {
                console.error("❌ Canvas non trouvé !");
                return;
            }

            if (!ball) {
                console.error("❌ Balle non initialisée !");
                return;
            }

            // ✅ S'assurer que AudioContext est initialisé
            if (audioCtx.state === 'suspended') {
                audioCtx.resume().then(() => {
                    console.log('🔊 AudioContext activé');
                }).catch(e => {
                    console.warn('⚠️ Problème audio:', e);
                });
            }

            // 2. S'assurer que la boucle n'est pas déjà lancée
            if (gameLoopId) {
                cancelAnimationFrame(gameLoopId);
                gameLoopId = null;
            }

            // 3. Initialiser le panneau de stats
            try {
                updateStatsPanel();
                console.log("✅ Panneau de stats initialisé");
            } catch (statsError) {
                console.warn("⚠️ Erreur panneau de stats:", statsError);
            }

            // 4. Lancer la boucle de jeu
            console.log("🚀 Lancement de la boucle de jeu");
            lastFrame = 0; // ✅ AJOUT : Reset du timer
            gameLoopId = requestAnimationFrame(gameLoop);

            console.log("✅ Jeu démarré avec succès - États:", {
                gameStarted: gameStarted,
                pause: pause,
                gameOver: gameOver,
                ballExists: !!ball
            });

        } catch (error) {
            console.error("❌ Erreur critique de démarrage:", error);

            // ✅ Fallback robuste amélioré
            setTimeout(() => {
                console.log("🔄 Tentative de récupération...");

                // Reset complet des états
                gameStarted = true;
                pause = false;
                gameOver = false;

                // Recréer la balle si nécessaire
                if (!ball) {
                    ball = {x: CANVAS_W/2, y: paddleY-30, r: ballR};
                    ballDX = 5;
                    ballDY = -5;
                }

                // Relancer la boucle
                if (!gameLoopId) {
                    gameLoopId = requestAnimationFrame(gameLoop);
                    console.log("✅ Boucle de récupération lancée");
                }
            }, 1000);
        }
    }


    function isBossLevelCheck() {
        return niveau % 5 === 0; // Boss tous les 5 niveaux : 5, 10, 15, 20, etc.
    }



    function createBoss() {
        isBossLevel = true;
        bossDefeated = false;

        // Stats du boss évoluent avec le niveau
        bossMaxHP = 50 + Math.floor(niveau / 5) * 25;
        bossHP = bossMaxHP;
        bossPhase = 1;
        bossInvulnerable = false;
        bossAttackTimer = 0;
        bossMovementTimer = 0;

        // Position initiale du boss
        boss = {
            x: CANVAS_W / 2 - 60,
            y: 140,
            w: 170,
            h: 80,
            targetX: CANVAS_W / 2 - 60,
            speed: 8 + niveau * 0.5,
            direction: 1,
            lastAttack: 0,
            attackCooldown: Math.max(1500, 2500 - niveau * 40),
            alive: true,
            hitFlash: 0,
            entrancePhase: true,
            entranceY: -100
        };

        // Créer quelques briques protectrices
        createBossShield();
    }


    function createBossShield() {
        bricks = [];

        // ✅ FORMATION DÉFENSIVE RENFORCÉE
        const formations = [
            // Mur de protection principal (plus large)
            {x: boss.x - 120, y: boss.y + 80},
            {x: boss.x - 60, y: boss.y + 80},
            {x: boss.x, y: boss.y + 80},
            {x: boss.x + 60, y: boss.y + 80},
            {x: boss.x + 120, y: boss.y + 80},
            {x: boss.x + 180, y: boss.y + 80},

            // Deuxième ligne de protection
            {x: boss.x - 90, y: boss.y + 120},
            {x: boss.x - 30, y: boss.y + 120},
            {x: boss.x + 30, y: boss.y + 120},
            {x: boss.x + 90, y: boss.y + 120},
            {x: boss.x + 150, y: boss.y + 120},

            // Troisième ligne (briques spéciales)
            {x: boss.x - 60, y: boss.y + 160},
            {x: boss.x + 30, y: boss.y + 160},
            {x: boss.x + 120, y: boss.y + 160},

            // Tours de défense latérales
            {x: boss.x - 150, y: boss.y + 40},
            {x: boss.x - 150, y: boss.y + 100},
            {x: boss.x + boss.w + 80, y: boss.y + 40},
            {x: boss.x + boss.w + 80, y: boss.y + 100}
        ];

        formations.forEach((pos, idx) => {
            if (pos.x >= 0 && pos.x + brickW <= CANVAS_W) {
                let specialChance = 0.4; // 40% de chance d'avoir un special
                let isSpecial = Math.random() < specialChance;
                let special = null;

                if (isSpecial) {
                    // ✅ PLUS DE MULTIPLICATEURS DANS LES BRIQUES BOSS
                    let specials = ["1️⃣", "2️⃣", "4️⃣", "8️⃣", "🏳️", "❤️‍🔥"];
                    if (Math.random() < 0.3) specials.push("☠️"); // Quelques skulls
                    special = specials[Math.floor(Math.random() * specials.length)];
                }

                bricks.push({
                    x: pos.x,
                    y: pos.y,
                    w: brickW,
                    h: brickH,
                    finalX: pos.x,
                    finalY: pos.y,
                    colorIdx: (idx < 6) ? 4 : (idx < 11) ? 3 : 2, // Dégradé de couleurs
                    special: special,
                    alive: true,
                    animFrame: 36,
                    animAngle: 0,
                    animating: false,
                    isBossShield: true
                });
            }
        });
    }



    function createBricks() {
      bricks = [];
      isBossLevel = false;
      let specials = [];
      let AutopilotBanner = false
      let nbSpecials = 10;
      while(specials.length < nbSpecials) {
        let idx = Math.floor(Math.random()*brickRows*brickCols);
        if(!specials.includes(idx)) specials.push(idx);
      }
      let skullsIdx = [];
      while(skullsIdx.length < 2) {
        let idx = Math.floor(Math.random()*brickRows*brickCols);
        if(!skullsIdx.includes(idx)) skullsIdx.push(idx);
      }
      for(let r=0; r<brickRows; r++) {
        for(let c=0; c<brickCols; c++) {
          let idx = r*brickCols+c;
          let special = null;
          if(skullsIdx.includes(idx)) special = "☠️";
          else if(specials.includes(idx)) special = SPECIAL_ICONS[Math.floor(Math.random()*SPECIAL_ICONS.length)];
          let colorIdx = r%BRICK_GRADIENTS.length;
          // Emplacement final
          let finalX = c*(brickW+brickGap)+brickGap+((CANVAS_W-brickCols*(brickW+brickGap))/2);
          let finalY = wallOffset+r*(brickH+brickGap);
          // Apparition depuis le centre, avec angle unique pour chaque brique
          let angle = Math.random() * 3 * Math.PI;
          bricks.push({
            x: CANVAS_W/2,
            y: CANVAS_H/2,
            w: brickW, h: brickH,
            finalX, finalY,
            colorIdx, special, alive:true,
            animFrame: 0,
            animAngle: angle,
            animating: true
          });
        }
      }
    }



    function drawPaddle(ctx,x,y,w,h,r=10){
      const p = new Path2D();
      p.moveTo(x+r, y);
      p.lineTo(x+w-r, y);
      p.arc(x+w-r, y+h/2, r, -Math.PI/2,  Math.PI/2);
      p.lineTo(x+r, y+h);
      p.arc(x+r,   y+h/2, r,  Math.PI/2, -Math.PI/2);
      ctx.fillStyle = '#fff';
      ctx.shadowColor = '#0ff';
      ctx.shadowBlur  = 20;
      ctx.fill(p);
    }


    function resetBall() {

      setTimeout(() => {   }, 500);
      ball = {x:CANVAS_W/2, y:paddleY-30, r:ballR};
      // ✅ CONSERVATION DE LA VITESSE PROGRESSIVE

//      updateBallSpeed(); // Recalcule la vitesse actuelle

      // ✅ PROGRESSION TRÈS GRADUELLE par niveau
      baseGameSpeed = Math.min(14, 12 + (niveau - 1) * 0.05);
      ballSpeed = baseGameSpeed;

      let angle = (Math.random()*0.6+0.2)*Math.PI;
      ballDX = Math.cos(angle)*currentGameSpeed*(Math.random()<0.5?-1:1);
      ballDY = -Math.abs(Math.sin(angle)*currentGameSpeed);
      gameStarted = true; // Flag obligatoire
    }

    function updateHUD() {
      elScore.textContent = score.toString().padStart(9, "0");
      elVies.textContent = "VIES:"+vies;
      elNiveau.textContent = "NIVEAU:"+niveau;
      elMult.textContent = "x" + mult;



      const elCookies = document.getElementById('cookies');
      if (elCookies) {
          if (cookies > 0) {
            elCookies.textContent = "COOKIES:" + cookies;
            elCookies.style.display = 'inline-block';
          } else {
            elCookies.style.display = 'none';
          }
        }
    }



    function updateMultDisplay(newMult) {

      elMult.textContent = "x" + newMult;
      // Logique de clignotement
      if (newMult > 1) {
        elMult.classList.add("blinking-effect"); // On ajoute la classe pour le faire clignoter
      } else {
        elMult.classList.remove("blinking-effect"); // On la retire s'il revient à x1
      }

      // L'ancien système de "flash" lors du changement est conservé
      //if (newMult !== lastMult) {
      //  elMult.classList.add("flash");
      //  setTimeout(() => elMult.classList.remove("flash"), 250);
      //  lastMult = newMult;
      //}

    }

    // === CONTRÔLES CLAVIER & SOURIS ===

    document.addEventListener('keydown',e=>{

      if ((e.key==="m" || e.key==="M") && cookies > 0 && !autopilot) {
          panic = 600; PanicButon=true
          --cookies; updateHUD();
          playSound("pi");
      }
      if ((e.key==="*" || e.key==="*") && !autopilot) {
//          ++vies; updateHUD();
          playSound("pi");
      }

      if ((e.key==="n" || e.key==="N") && !autopilot) {
//          niveau +=1 ; updateHUD();
      }

      // ✅ TOUCHE DEBUG : Z (simple et sans conflit)
      if(e.key==="z" || e.key==="Z") {
          e.preventDefault();
          if (Debug === true) {
              Debug = false;
            } else {
              Debug=true;
              showDebugPopup();
          return;
      }
    }

      // ✅ GESTION DES TOUCHES DE MOUVEMENT
      if(e.code==="ArrowLeft"||e.key==="q"||e.key==="Q") leftDown=true;
      if(e.code==="ArrowRight"||e.key==="d"||e.key==="D") rightDown=true;

      // ✅ GESTION DU SON ET DE LA PAUSE
      if(e.key==="s" || e.key==="S") {
        // Toggle du son (si tu as une fonction pour ça)
      }

      if(e.key==="p" || e.key==="P") {
        pause = !pause; // Toggle de la pause
      }
    });


    // ✅ NOUVEAU CODE (fonctionne partout)
    document.addEventListener('mousemove', e => {
        // Empêche la souris de prendre le contrôle si l'autopilote est actif
        if (autopilot) return;

        // Calcul des coordonnées relatives au canvas même si souris à l'extérieur
        const rect = canvas.getBoundingClientRect();
        const scaleFactor = getCurrentScaleFactor();

        let canvasX = (e.clientX - rect.left) / scaleFactor;
        let canvasY = (e.clientY - rect.top) / scaleFactor;

        // ✅ NOUVEAU : Contraindre les coordonnées dans les limites du canvas
        canvasX = Math.max(0, Math.min(CANVAS_W, canvasX));

        // Système de démultiplication du mouvement (votre code existant)
        if (lastMouseX !== null) {
            let deltaX = canvasX - lastMouseX;
            let amplifiedDelta = deltaX * mouseSensitivity;
            let targetX = paddleX + paddleW/2 + amplifiedDelta - paddleW/2;

            const limits = getEffectiveCanvasLimits();
            paddleX = Math.max(0, Math.min(limits.width - paddleW, targetX));
        } else {
            const limits = getEffectiveCanvasLimits();
            paddleX = Math.max(0, Math.min(limits.width - paddleW, canvasX - paddleW / 2));
        }

        lastMouseX = canvasX;
    });
    //Fin de fonction mousemove_demultiplie


    // ✅ NOUVEAU : Contrôle par molette de souris
    // === CONTRÔLE MOLETTE CORRIGÉ POUR LE RESPONSIVE ===
    canvas.addEventListener('wheel', e => {
        e.preventDefault(); // Empêche le scroll de la page

        // Ne pas contrôler si l'autopilote est actif
        if (autopilot) return;

        // ✅ NOUVEAU : Sensibilité ajustée selon le scale
        const scaleFactor = getCurrentScaleFactor();
        const baseSensitivity = 20;
        const adjustedSensitivity = baseSensitivity * scaleFactor;

        // Calcul du déplacement basé sur la direction de la molette
        let deltaMove = 0;

        if (e.deltaY > 0) {
            // Molette vers le bas = mouvement vers la droite
            deltaMove = adjustedSensitivity;
        } else if (e.deltaY < 0) {
            // Molette vers le haut = mouvement vers la gauche
            deltaMove = -adjustedSensitivity;
        }

        // ✅ NOUVEAU : Limites ajustées selon le scale
        const limits = getEffectiveCanvasLimits();
        paddleX = Math.max(
            0,
            Math.min(limits.width - paddleW, paddleX + deltaMove)
        );
    });
    //Fin de fonction wheel_corrected


function autopilotMove(dt) {
    if (!ball) return;

    let finalTargetX = paddleX;
    let moveSpeed = 600; // ✅ VITESSE DE BASE AUGMENTÉE
    let urgency = 1;

    // === VARIABLES DE PERFORMANCE ===
    const paddleCenter = paddleX + paddleW/2;
    const remainingBricks = bricks.filter(b => b.alive);
    const isEndGame = remainingBricks.length <= 8;

    // ✅ NOUVEAU : DÉTECTION ULTRA-AGRESSIVE DES POWER-UPS
    let bestPowerup = null;
    let bestPowerupScore = -1;
    let powerupUrgency = 1;

    // === 1. PHASE COLLECTE POWER-UPS - PRIORITÉ ABSOLUE ===
    powerups.forEach(p => {
        // ✅ ZONE DE DÉTECTION MASSIMENT ÉLARGIE
        if (p.y > 50 && p.y < paddleY + 200 && !p.caught) { // Zone énorme !

            // ✅ CALCUL PRÉDICTIF DE LA TRAJECTOIRE
            let timeToIntercept = Math.max(0.1, (paddleY - p.y) / (p.speed || 6));
            let futureX = p.x + (p.dx || 0) * timeToIntercept;
            let currentDistance = Math.abs(futureX - paddleCenter);

            // ✅ NOUVEAU : Test si c'est atteignable
            let maxReachDistance = Math.min(CANVAS_W, paddleW * 4 + timeToIntercept * 1000);

            if (currentDistance <= maxReachDistance && timeToIntercept < 5) {
                let score = 5000; // Score de base énorme !

                // ✅ PRIORISATION RÉVOLUTIONNAIRE DES MULTIPLICATEURS
                if (p.type === "mult8") {
                    score = 50000;  // ✅ PRIORITÉ MAXIMALE ABSOLUE
                    powerupUrgency = 5;
                } else if (p.type === "mult4") {
                    score = 40000;  // ✅ ULTRA PRIORITAIRE
                    powerupUrgency = 4.5;
                } else if (p.type === "mult2") {
                    score = 30000;  // ✅ TRÈS PRIORITAIRE
                    powerupUrgency = 4;
                } else if (p.type === "mult1") {
                    score = 25000;  // ✅ PRIORITAIRE
                    powerupUrgency = 3.5;
                } else if (p.type === "huge") {
                    score = 20000;  // ✅ Raquette géante importante
                    powerupUrgency = 3;
                } else if (p.type === "long") {
                    score = 15000;  // ✅ Raquette longue importante
                    powerupUrgency = 2.5;
                } else if (p.type !== "skull") {
                    score = 10000;  // ✅ Autres power-ups importants
                    powerupUrgency = 2;
                }

                // ✅ BONUS TEMPOREL MASSIF
                let timeBonus = Math.max(0, 10000 - timeToIntercept * 2000);
                score += timeBonus;

                // ✅ BONUS PROXIMITÉ ÉNORME
                let proximityBonus = Math.max(0, 8000 - currentDistance * 20);
                score += proximityBonus;

                // ✅ BONUS D'URGENCE selon la hauteur
                if (p.y > paddleY - 150) {
                    score += 15000; // Bonus énorme si proche !
                    powerupUrgency += 2;
                }

                // ✅ SÉLECTION DU MEILLEUR POWER-UP
                if (score > bestPowerupScore) {
                    bestPowerupScore = score;
                    bestPowerup = {
                        x: futureX,
                        originalX: p.x,
                        y: p.y,
                        timeToIntercept: timeToIntercept,
                        type: p.type,
                        urgency: powerupUrgency,
                        score: score
                    };
                }
            }
        }
    });

    // ✅ SI POWER-UP TROUVÉ : MODE COLLECTE ULTRA-AGRESSIF
    if (bestPowerup) {
        console.log(`🎯 POWER-UP CIBLÉ : ${bestPowerup.type} (Score: ${bestPowerup.score}) à ${Math.floor(bestPowerup.x)}`);

        finalTargetX = bestPowerup.x - paddleW/2;
        moveSpeed = 1200 + bestPowerup.urgency * 200; // ✅ VITESSE ÉNORME !
        urgency = bestPowerup.urgency;

        // ✅ BOOST SUPPLÉMENTAIRE SI TRÈS PROCHE
        if (bestPowerup.timeToIntercept < 1) {
            moveSpeed *= 2; // DOUBLE LA VITESSE !
            urgency *= 2;
        }

        // ✅ CORRECTION PRÉDICTIVE AVANCÉE
        let horizontalSpeed = Math.abs(finalTargetX - paddleCenter);
        let correctionFactor = Math.min(2, horizontalSpeed / 100);
        finalTargetX += (finalTargetX > paddleCenter ? 1 : -1) * correctionFactor * 20;

    // === 2. SI PAS DE POWER-UP : LOGIQUE DÉFENSIVE/OFFENSIVE ===
    } else {
        // ✅ ÉVITEMENT SKULLS (inchangé - fonctionne bien)
        let dangerousSkull = null;
        let minDanger = Infinity;

        skulls.forEach(skull => {
            if (skull.y < paddleY && skull.y > CANVAS_H * 0.4) {
                let timeToImpact = (paddleY - skull.y) / skull.speed;
                if (timeToImpact < minDanger && timeToImpact > 0.3) {
                    minDanger = timeToImpact;
                    dangerousSkull = skull;
                }
            }
        });

        if (dangerousSkull) {
            let skullCenter = dangerousSkull.x;
            let safeDistance = paddleW * 0.8;

            if (skullCenter - safeDistance > paddleW/2) {
                finalTargetX = skullCenter - safeDistance - paddleW/2;
            } else if (skullCenter + safeDistance < CANVAS_W - paddleW/2) {
                finalTargetX = skullCenter + safeDistance - paddleW/2;
            } else {
                finalTargetX = (paddleCenter < CANVAS_W/2) ? 0 : CANVAS_W - paddleW;
            }
            moveSpeed = 800;
            urgency = 3;

        // ✅ DÉFENSE (si balle descend)
        } else if (ballDY > 0 && ball.y > CANVAS_H * 0.6) {
            let timeToImpact = (paddleY - ball.y) / ballDY;
            let impactX = ball.x + ballDX * timeToImpact;

            // Gestion des rebonds
            while (impactX < 0 || impactX > CANVAS_W) {
                if (impactX < 0) impactX = -impactX;
                if (impactX > CANVAS_W) impactX = CANVAS_W - (impactX - CANVAS_W);
            }

            finalTargetX = impactX - paddleW/2;
            moveSpeed = 700;
            urgency = 2;

        // ✅ COLLECTE BONUS SECONDAIRE
        } else {
            let bestBonus = null;
            let bestBonusScore = -1;

            bonuses.forEach(b => {
                if (b.y > CANVAS_H * 0.2 && b.y < paddleY - 10) {
                    let timeToIntercept = (paddleY - b.y) / (b.speed || 6);
                    let distance = Math.abs(b.x - paddleCenter);

                    if (timeToIntercept > 0.2 && timeToIntercept < 3 && distance < CANVAS_W * 0.7) {
                        let score = (b.points || 100) * 10 + Math.max(0, 500 - distance);

                        if (score > bestBonusScore) {
                            bestBonusScore = score;
                            bestBonus = {x: b.x, timeToIntercept: timeToIntercept};
                        }
                    }
                }
            });

            if (bestBonus) {
                finalTargetX = bestBonus.x - paddleW/2;
                moveSpeed = 600;
                urgency = 1.5;

            // ✅ PHASE OFFENSIVE (attaque des briques)
            } else if (ballDY < 0 && ball.y < CANVAS_H * 0.7) {
                // Logique de ciblage des briques simplifiée mais efficace
                let targetBrick = null;
                let bestBrickScore = -1;

                remainingBricks.forEach(brick => {
                    let distance = Math.abs(brick.x + brick.w/2 - ball.x) + Math.abs(brick.y - ball.y);
                    let score = 1000 - distance;

                    // Bonus pour briques accessibles
                    if (brick.y > wallOffset + brickH * 2) score += 300;

                    // Bonus pour briques spéciales
                    if (brick.special && brick.special.includes("️⃣")) score += 500;

                    if (score > bestBrickScore) {
                        bestBrickScore = score;
                        targetBrick = brick;
                    }
                });

                if (targetBrick) {
                    let targetX = targetBrick.x + targetBrick.w/2;
                    let deltaX = targetX - ball.x;
                    let deltaY = targetBrick.y - ball.y;
                    let requiredAngle = Math.atan2(deltaX, -deltaY);
                    let paddleOffset = Math.sin(requiredAngle) * paddleW * 0.4;
                    finalTargetX = ball.x - paddleW/2 + paddleOffset;
                    moveSpeed = 650;
                    urgency = 1.8;
                } else {
                    finalTargetX = (CANVAS_W - paddleW) / 2;
                    moveSpeed = 400;
                }
            }
        }
    }

    // === 3. MOUVEMENT ULTRA-OPTIMISÉ ET FLUIDE ===
    finalTargetX = Math.max(0, Math.min(CANVAS_W - paddleW, finalTargetX));

    let currentX = paddleX;
    let deltaX = finalTargetX - currentX;
    let distance = Math.abs(deltaX);

    if (distance > 1) { // Seuil ultra-fin
        let direction = deltaX > 0 ? 1 : -1;

        // ✅ VITESSE ADAPTATIVE RÉVOLUTIONNAIRE
        let adaptiveSpeed = moveSpeed * urgency;

        // ✅ BOOST MASSIF pour les power-ups
        if (bestPowerup) {
            adaptiveSpeed *= 2.5; // Boost énorme !
        }

        // Boost selon distance
        if (distance > paddleW * 2) adaptiveSpeed *= 1.8;
        else if (distance > paddleW) adaptiveSpeed *= 1.4;

        // ✅ MOUVEMENT FLUIDE AVEC INERTIE AMÉLIORÉE
        let maxMove = Math.min(distance, adaptiveSpeed * dt * megaspeed * 3);

        // Lissage près de la cible
        if (distance < 30) {
            maxMove *= (0.5 + (distance / 30) * 0.5);
        }

        // ✅ SYSTÈME D'INERTIE NATURELLE
        if (!paddleVelocity) paddleVelocity = 0;
        let targetVelocity = direction * maxMove;
        paddleVelocity += (targetVelocity - paddleVelocity) * 0.4; // Inertie plus réactive

        paddleX += paddleVelocity;
    } else {
        // Arrêt en douceur
        if (paddleVelocity) paddleVelocity *= 0.9;
        paddleX += paddleVelocity;
    }

    // Contraintes finales
    //  paddleX = Math.max(0, Math.min(CANVAS_W - paddleW, paddleX));

    const limits = getEffectiveCanvasLimits();
    paddleX = Math.max(0, Math.min(limits.width - paddleW, paddleX));

    // ✅ CONTRÔLE VITESSE BALLE ENDGAME (inchangé)
    if (isEndGame && Math.sqrt(ballDX * ballDX + ballDY * ballDY) < 16) {
        let currentSpeed = Math.sqrt(ballDX * ballDX + ballDY * ballDY);
        let targetSpeed = Math.min(18, 16 + (8 - remainingBricks.length));
        if (currentSpeed > 0) {
            let ratio = targetSpeed / currentSpeed;
            ballDX *= ratio;
            ballDY *= ratio;
        }
    }
}

    /**
     * Calcule le point d'impact précis pour la défense (fonction conservée car elle est parfaite).
     */
    function calculateDefensiveinterceptionPoint() {
      if (ballDY < 0) return ball.x;
      const timeToImpact = (paddleY - ball.y) / ballDY;
      let impactX = ball.x + ballDX * timeToImpact;
      while (impactX < 0 || impactX > CANVAS_W) {
        if (impactX < 0) impactX = -impactX;
        if (impactX > CANVAS_W) impactX = CANVAS_W - (impactX - CANVAS_W);
      }
      return impactX;
    }

    function calculateTrajectory(ball, dx, dy, brick, maxBounces) {
        let testX = ball.x;
        let testY = ball.y;
        let testDX = dx;
        let testDY = dy;
        let bounces = 0;
        let time = 0;

        // Simulation de trajectoire
        for (let i = 0; i < 200 && time < 300; i++) {
            let nextX = testX + testDX;
            let nextY = testY + testDY;
            time++;

            // Vérification collision avec la brique cible
            if (nextY >= brick.y && nextY <= brick.y + brick.h &&
                nextX >= brick.x && nextX <= brick.x + brick.w) {

                // Calculer la position de raquette requise
                let ballReturnTime = (paddleY - nextY) / Math.abs(testDY);
                let ballReturnX = nextX + testDX * ballReturnTime;

                // Gérer les rebonds sur le retour
                while (ballReturnX < 0 || ballReturnX > CANVAS_W) {
                    if (ballReturnX < 0) ballReturnX = -ballReturnX;
                    if (ballReturnX > CANVAS_W) ballReturnX = CANVAS_W - (ballReturnX - CANVAS_W);
                }

                return {
                    canHit: true,
                    impactX: nextX,
                    impactY: nextY,
                    requiredPaddleX: ballReturnX - paddleW/2,
                    timeToHit: time,
                    bounces: bounces
                };
            }

            // Gestion des rebonds sur les murs
            if (nextX <= 0 || nextX >= CANVAS_W) {
                testDX = -testDX;
                bounces++;
                if (bounces > maxBounces) break;
            }
            if (nextY <= 0) {
                testDY = -testDY;
                bounces++;
                if (bounces > maxBounces) break;
            }

            testX = nextX;
            testY = nextY;
        }

        return { canHit: false };
    }

    // ✅ FONCTION UTILITAIRE : Trouver la brique la plus accessible
    function findMostAccessibleBrick() {
        let closestBrick = null;
        let minDistance = Infinity;

        bricks.forEach(brick => {
            if (!brick.alive) return;

            let distance = Math.sqrt(
                Math.pow(brick.x + brick.w/2 - ball.x, 2) +
                Math.pow(brick.y + brick.h/2 - ball.y, 2)
            );

            // Bonus pour les briques du bas (plus faciles à atteindre)
            if (brick.y > wallOffset + brickH * 2) {
                distance *= 0.8;
            }

            if (distance < minDistance) {
                minDistance = distance;
                closestBrick = brick;
            }
        });

        return closestBrick;
    }

    // ✅ FONCTION CENTRALE DE GESTION DE LA VITESSE
    function calculateGameSpeed() {
        // Vitesse de base + bonus niveau + bonus briques cassées
        let progressiveSpeed = baseGameSpeed +
                              (niveau - 1) * speedIncreasePerLevel +
                              bricksHit * speedIncreasePerBrick;

        // Application du multiplicateur autopilote si actif
        if (autopilot) {
            currentGameSpeed = progressiveSpeed * autopilotSpeedMultiplier;
        } else {
            currentGameSpeed = progressiveSpeed;
        }

        // ✅ LIMITATIONS PLUS STRICTES selon le mode
        if (autopilot) {
            currentGameSpeed = Math.min(currentGameSpeed, 13 + niveau * 0.05); // Limite autopilote
        } else {
            currentGameSpeed = Math.min(currentGameSpeed, 15 + niveau * 0.15); // Limite normale
        }

        return currentGameSpeed;
    }

    // ✅ FONCTION DE MISE À JOUR DE LA VITESSE DE LA BALLE
    function updateBallSpeed() {
        let newSpeed = calculateGameSpeed();

        // Conservation de la direction actuelle
        let currentSpeed = Math.sqrt(ballDX * ballDX + ballDY * ballDY);
        if (currentSpeed > 0) {
            let ratio = newSpeed / currentSpeed;
            ballDX *= ratio;
            ballDY *= ratio;
        }

        ballSpeed = newSpeed;

        // ✅ SÉCURITÉ ABSOLUE : Plafond de vitesse global RÉDUIT
        let absoluteMaxSpeed = Math.min(18, 14 + niveau * 0.08); // Progression très lente + plafond à 18
        if (ballSpeed > absoluteMaxSpeed) {
            ballSpeed = absoluteMaxSpeed;
            console.log(`Vitesse limitée à ${absoluteMaxSpeed.toFixed(1)} au niveau ${niveau}`);
        }

        // ✅ Application immédiate de la limitation
        let currentBallSpeed = Math.sqrt(ballDX * ballDX + ballDY * ballDY);
        if (currentBallSpeed > ballSpeed) {
            let ratio = ballSpeed / currentBallSpeed;
            ballDX *= ratio;
            ballDY *= ratio;
        }



    }

    // === LOGIQUE DE MISE À JOUR DU JEU ===

    function update(dt, elapsed_ms) {

      // ✅ MISE À JOUR CONDITIONNELLE DE LA GALAXIE
      if (galaxyEnabled) {
          updateGalaxy(dt);
      }


      // --- GESTION AUTOPILOTE & BANDEAU (VERSION CORRIGÉE) ---
      let briquesRestantes = bricks.filter(b => b.alive).length;

      // 1. Logique du bandeau d'avertissement (SIMPLIFIÉE)
      if (!autopilot && !isBossLevel &&
          briquesRestantes > 0 && briquesRestantes <= LancementAutoPilote + countdownRange &&
          briquesRestantes > LancementAutoPilote) {

          let bricksToActivation = briquesRestantes - LancementAutoPilote;
          elAutopilotBanner.textContent = `AUTOPILOT DANS ${bricksToActivation}`;

          if (elAutopilotBanner.style.display !== 'block') {
              playSound("AutopilotBanner");
              elAutopilotBanner.style.display = 'block';
          }

          elAutopilotBanner.classList.remove('flash');
          void elAutopilotBanner.offsetWidth;
          elAutopilotBanner.classList.add('flash');

      } else {
          if (elAutopilotBanner.style.display !== 'none') {
              elAutopilotBanner.style.display = 'none';
          }
      }

      // ✅ APPEL DIRECT ET SIMPLE
      if (document.getElementById('statsPanel')) {
        updateStatsPanel();
      }


      // 2. Activation de l'autopilote (LOGIQUE CORRIGÉE)
      if (briquesRestantes <= LancementAutoPilote && !autopilot && !isBossLevel) {
          autopilot = true;
          leftDown = rightDown = false;

          // ✅ TRANSITION FLUIDE VERS LA VITESSE AUTOPILOTE
          updateBallSpeed(); // Applique immédiatement le multiplicateur autopilote
          playSound("autopilot_on");
      }

      // 3. Désactivation pour les boss (SÉCURISÉE)
      if (isBossLevel && autopilot) {
          autopilot = false;
          updateBallSpeed(); // Retire le multiplicateur autopilote
          leftDown = rightDown = false;
          playSound("raquettenormale");

          // Affichage du message boss
          elAutopilotBanner.textContent = "⚠️ BOSS FIGHT - CONTRÔLE MANUEL ⚠️";
          elAutopilotBanner.style.display = 'block';
          elAutopilotBanner.style.color = '#ff0000';

          setTimeout(() => {
              if (elAutopilotBanner.style.display !== 'none') {
                  elAutopilotBanner.style.display = 'none';
              }
          }, 3000);
      }

      // 4. Retour au manuel si trop de briques (NOUVEAU NIVEAU)
      if (briquesRestantes > LancementAutoPilote && autopilot && !isBossLevel) {
          autopilot = false;
          megaspeed = 1;
      }

      // GESTION DU MODE PANIC (CORRIGÉE)
      if (panic > 0) {
          panic--;
          if (!autopilot) {
              autopilot = true;
              leftDown = rightDown = false;
          }
      } else if (PanicButon) {
          autopilot = false;
          PanicButon = false;
      }

      // AFFICHAGE DU STATUS AUTOPILOT (CORRIGÉ)
      if (autopilot) {
        elAutopilotStatus.style.display = 'inline-block';
        elAutopilotStatus.classList.add('blinking-effect');
       } else {
        elAutopilotStatus.style.display = 'none';
        elAutopilotStatus.classList.remove('blinking-effect');
      }

      // APPEL DE L'AUTOPILOTE (CONDITION CORRIGÉE)
      if (autopilot && !isBossLevel) { // ✅ AJOUT : !isBossLevel
          autopilotMove(dt);
      } else {
          // Contrôle manuel
          // CONTRÔLE MANUEL (VERSION CORRIGÉE POUR LE RESPONSIVE)
          if (leftDown && !rightDown) {
              paddleAcceleration = Math.min(paddleAcceleration + paddleAccelerationStep, maxPaddleAcceleration);

              // ✅ NOUVEAU : Vitesse ajustée selon le scale
              const scaleFactor = getCurrentScaleFactor();
              const adjustedSpeed = (paddleSpeed + paddleAcceleration) * scaleFactor;

              paddleX = Math.max(0, paddleX - adjustedSpeed * dt);

          } else if (rightDown && !leftDown) {
              paddleAcceleration = Math.min(paddleAcceleration + paddleAccelerationStep, maxPaddleAcceleration);

              // ✅ NOUVEAU : Vitesse et limites ajustées selon le scale
              const scaleFactor = getCurrentScaleFactor();
              const adjustedSpeed = (paddleSpeed + paddleAcceleration) * scaleFactor;
              const limits = getEffectiveCanvasLimits();

              paddleX = Math.min(limits.width - paddleW, paddleX + adjustedSpeed * dt);

          } else {
              paddleAcceleration = 0;
          }
          //Fin de fonction controle_manuel_corrige

      }


      if (decrementActive) {
        // Temps écoulé en secondes réelles
        let elapsed = (performance.now() - decrementStartTime) / 1000;
        let timeLeft = Math.max(0, decrementTimer - elapsed);

        if (timeLeft <= 0) {
          decrementActive = false;
          decrementEffect = false;
          elDec.style.display = "none";
          playSound("raquettenormale");
        }
      }


      let prevX = ball.x, prevY = ball.y;
      let nextX = ball.x + ballDX * dt, nextY = ball.y + ballDY * dt;
      ball.x=nextX; ball.y=nextY;

      // Collisions murs
      if(ball.x-ball.r<0) {ball.x=ball.r; ballDX=Math.abs(ballDX); playSound("impact");}
      if(ball.x+ball.r>CANVAS_W) {ball.x=CANVAS_W-ball.r; ballDX=-Math.abs(ballDX); playSound("impact");}
      if(ball.y-ball.r<0) {ball.y=ball.r; ballDY=Math.abs(ballDY); playSound("impact");}
      if(Math.abs(ballDX)<2) ballDX=(Math.random()<0.5?-1:1)*2;

      // --- Collision raquette (VERSION HAUTE VITESSE SÉCURISÉE) ---
      if (ballDY > 0) { // La balle doit descendre
          // ✅ DÉTECTION PRÉDICTIVE pour éviter les traversées
          let nextBallY = ball.y + ballDY * dt;
          let nextBallX = ball.x + ballDX * dt;

          // Vérification collision avec la position prédite
          if (nextBallY + ball.r >= paddleY &&
              ball.y + ball.r <= paddleY + paddleH &&
              nextBallX + ball.r >= paddleX &&
              nextBallX - ball.r <= paddleX + paddleW) {

              // ✅ REPOSITIONNEMENT SÉCURISÉ avant le rebond
              ball.y = paddleY - ball.r - 1; // Marge de sécurité
              ball.x = nextBallX; // Conserve le mouvement horizontal

              // ✅ CALCUL DE L'ANGLE DE REBOND (inchangé - fonctionne bien)
              let impactPoint = (ball.x - (paddleX + paddleW / 2)) / (paddleW / 2);
              impactPoint = Math.max(-1, Math.min(1, impactPoint));
              const maxBounceAngle = 5 * Math.PI / 12;
              const newAngle = impactPoint * maxBounceAngle;

              // ✅ VITESSE LIMITÉE pour éviter les bugs
              let speed = Math.sqrt(ballDX * ballDX + ballDY * ballDY);
              let maxSpeed = autopilot ? (baseGameSpeed * 2) : (baseGameSpeed * 2.5);
              speed = Math.min(speed, maxSpeed);

              ballDX = speed * Math.sin(newAngle);
              ballDY = -speed * Math.cos(newAngle);

              playSound("paddle");
          }
      }


      // === MISE À JOUR DU BOSS (VERSION STABILISÉE) ===
      if (isBossLevel && boss && boss.alive) {
          // ✅ GESTION DE L'ENTRÉE SÉCURISÉE
          if (boss.entrancePhase) {
              boss.y += 1; // Vitesse d'entrée réduite
              if (boss.y >= 140) {
                  boss.entrancePhase = false;
                  boss.y = 140;
              }
          } else {
              // ✅ MOUVEMENT HORIZONTAL STABLE
              let moveSpeed = (5 + niveau * 0.2) * dt; // Vitesse très réduite
              boss.x += boss.direction * moveSpeed;

              // ✅ REBONDS SÉCURISÉS
              if (boss.x <= 0) {
                  boss.x = 0;
                  boss.direction = 1;
              } else if (boss.x + boss.w >= CANVAS_W) {
                  boss.x = CANVAS_W - boss.w;
                  boss.direction = -1;
              }

              // ✅ ATTAQUES CONTRÔLÉES
              bossAttackTimer += elapsed_ms;
              if (bossAttackTimer > boss.attackCooldown) {
                  bossAttack();
                  bossAttackTimer = 0;
              }
          }
      }

//      updateGalaxy(dt);


      // === COLLISION AVEC LE BOSS (VERSION SÉCURISÉE) ===
      if (isBossLevel && boss && boss.alive && !bossInvulnerable) {
          // ✅ COLLISION DETECTION AMÉLIORÉE
          let ballRight = ball.x + ball.r;
          let ballLeft = ball.x - ball.r;
          let ballBottom = ball.y + ball.r;
          let ballTop = ball.y - ball.r;

          let bossRight = boss.x + boss.w;
          let bossBottom = boss.y + boss.h;

          if (ballRight > boss.x && ballLeft < bossRight &&
              ballBottom > boss.y && ballTop < bossBottom) {

              // ✅ CALCUL SÉCURISÉ DU REBOND
              let overlapX = Math.min(ballRight - boss.x, bossRight - ballLeft);
              let overlapY = Math.min(ballBottom - boss.y, bossBottom - ballTop);

              if (overlapX < overlapY) {
                  // Collision horizontale
                  ballDX = ball.x < boss.x + boss.w/2 ? -Math.abs(ballDX) : Math.abs(ballDX);
                  ball.x = ball.x < boss.x + boss.w/2 ? boss.x - ball.r : boss.x + boss.w + ball.r;
              } else {
                  // Collision verticale
                  ballDY = ball.y < boss.y + boss.h/2 ? -Math.abs(ballDY) : Math.abs(ballDY);
                  ball.y = ball.y < boss.y + boss.h/2 ? boss.y - ball.r : boss.y + boss.h + ball.r;
              }

              // ✅ DÉGÂTS ET EFFETS (SÉCURISÉS)
              bossHP = Math.max(0, bossHP - 10);
              boss.hitFlash = 10;
              playSound("boss_hit");

              // ✅ INVULNÉRABILITÉ TEMPORAIRE SÉCURISÉE
              bossInvulnerable = true;
              timeoutManager.set('bossInvulnerable', () => {
                  bossInvulnerable = false;
              }, 500);

              // ✅ PARTICULES D'IMPACT
              for (let j = 0; j < 15; j++) {
                  let angle = Math.random() * 2 * Math.PI;
                  let velocity = 3 + Math.random() * 4;
                  particles.push({
                      x: ball.x, y: ball.y,
                      dx: Math.cos(angle) * velocity,
                      dy: Math.sin(angle) * velocity,
                      life: 20, color: "#ff0"
                  });
              }

              // ✅ VÉRIFICATION DE DÉFAITE DU BOSS
              if (bossHP <= 0) {
                  boss.alive = false;
                  bossDefeated = true;
                  playSound("boss_death");

                  // Récompenses

                  score += 20000 * niveau;
                  cookies += 3;
                  vies += 1;

                  // ✅ NOUVEAU : Animation du gain qui monte vers le score
                  showScoreBonusAnim(boss.x + boss.w/2, boss.y + boss.h/2, 20000 * niveau);

                  updateHUD();

                  // Animation de victoire
                  for (let i = 0; i < 30; i++) {
                      timeoutManager.set(`bossVictory${i}`, () => {
                          particles.push({
                              x: boss.x + Math.random() * boss.w,
                              y: boss.y + Math.random() * boss.h,
                              dx: (Math.random() - 0.5) * 8,
                              dy: (Math.random() - 0.5) * 8,
                              life: 50,
                              color: COLORS[Math.floor(Math.random() * COLORS.length)]
                          });
                      }, i * 30);
                  }
              }
          }
      }


      // Collision briques
      for(let i=0;i<bricks.length;i++) {
        let b=bricks[i];
        if(!b.alive) continue;
        if(ball.x+ball.r>b.x && ball.x-ball.r<b.x+b.w && ball.y+ball.r>b.y && ball.y-ball.r<b.y+b.h) {
          b.alive=false;

          if (autopilot && lastTargetBrick === b) {
              // Succès ! On mémorise cette stratégie
              shotHistory.push({
                  targetBrick: b,
                  paddlePosition: paddleX,
                  ballPosition: {x: ball.x, y: ball.y},
                  hit: true,
                  timestamp: performance.now()
              });

              // Nettoyer l'historique (garder seulement les 10 derniers)
              if (shotHistory.length > 10) {
                  shotHistory.shift();
              }
          } else if (autopilot && lastTargetBrick && lastTargetBrick.alive) {
              // Raté ! On mémorise l'échec pour ajuster
              shotHistory.push({
                  targetBrick: lastTargetBrick,
                  paddlePosition: paddleX,
                  ballPosition: {x: ball.x, y: ball.y},
                  hit: false,
                  timestamp: performance.now()
              });
          }

          // Reset des variables de ciblage
          lastTargetBrick = null;
          lastPaddleTarget = 0;


          bricksHit++; // Incrémentation ici
          playSound("impact");
          // --- Collision briques (vérification de l'appel) ---
          // Collision briques (vers ligne 1000)

        if (decrementEffect) {
          // Si le malus est actif, on applique la pénalité.
          let penalty = 100 * mult;
          score -= penalty;
          showScoreDecrementAnim(b.x + b.w / 2, b.y + b.h / 2, penalty);
        } else {
          // Le gain de points normal...
          let brickPoints = 100 * mult;
          score += brickPoints;
          updateStatsPanel();

          // ✅ NOUVEAU : Son de pièces pour les hauts scores
          if (brickPoints >= 200) {  // 200+ points (multiplicateur x2 minimum)
            playSound("coins");
          } else {
            playSound("impact");  // Son normal pour les briques de base
          }

          showScoreBonusAnim(b.x + b.w / 2, b.y + b.h / 2, brickPoints);
        }

          for(let j=0;j<16;j++) {
            let a=Math.random()*2*Math.PI, v=2+Math.random()*3;
            particles.push({x:ball.x,y:ball.y,dx:Math.cos(a)*v,dy:Math.sin(a)*v,life:16,color:COLORS[b.colorIdx%COLORS.length]});
          }
          if(b.special) {
            if(b.special === "☠️") {
              spawnSkull(b);
            } else {
              spawnPowerup(b);
            }
          }

          bricksHit++; // Incrément pour calcul de vitesse
          updateBallSpeed(); // Mise à jour progressive de la vitesse

          // Conservation de la direction pour le rebond
          let dir = Math.atan2(ballDY, ballDX);
          ballDX = Math.cos(dir) * currentGameSpeed;
          ballDY = Math.sin(dir) * currentGameSpeed;

          if(Math.abs(ball.x-(b.x+b.w/2))>Math.abs(ball.y-(b.y+b.h/2))) ballDX*=-1;
          else ballDY*=-1;
          break;
        }
      }

      // --- Boucle de collecte des power-ups (CORRIGÉE DÉFINITIVEMENT) ---
      powerups.forEach(p => {
          // ✅ NOUVEAU : Validation de sécurité pour éviter les crashes
          if (!p || typeof p.y === 'undefined') {
              p.caught = true; // Marquer pour suppression
              return;
          }

          // ✅ MOUVEMENT SÉCURISÉ POUR TOUS LES PROJECTILES
          if (p.type === "boss_projectile") {
              // Mouvement vertical standard
              p.y += p.speed * dt;

              // Mouvement horizontal pour les projectiles en éventail
              if (p.dx && typeof p.dx === 'number') {
                  p.x += p.dx * dt * 0.5; // Vitesse réduite pour l'horizontal
              }

              // ✅ HOMING SÉCURISÉ ET PRÉVISIBLE
              if (p.homing && p.y < paddleY + 100 && p.y > 50) {
                  let targetX = paddleX + paddleW / 2;
                  let deltaX = targetX - p.x;

                  // Vitesse de correction très réduite pour éviter les oscillations
                  let correctionSpeed = Math.min(Math.abs(deltaX) * 0.02, 30 * dt);
                  let direction = deltaX > 0 ? 1 : -1;

                  p.x += direction * correctionSpeed;
              }
          } else {
              // Mouvement normal pour les autres powerups
              p.y += p.speed * dt;
          }

          // ✅ DISPARITION AVEC MARGE ÉTENDUE
          if (p.y > CANVAS_H + 100 || p.x < -100 || p.x > CANVAS_W + 100) {
              p.caught = true;
              return;
          }

          // ✅ COLLISION AMÉLIORÉE ET SÉCURISÉE
          if (p.y + 10 >= paddleY && p.y - 10 <= paddleY + paddleH &&
              p.x + 10 >= paddleX && p.x - 10 <= paddleX + paddleW) {

              p.caught = true;

              // ✅ GESTION DES PROJECTILES DE BOSS (CORRIGÉE)
              if (p.type === "boss_projectile") {
                  // Dégâts au joueur
                  vies = Math.max(0, vies - 1);
                  playSound("mort");

                  // Effet visuel de dégâts
                  for (let j = 0; j < 15; j++) {
                      let a = Math.random() * 2 * Math.PI, v = 4 + Math.random() * 6;
                      particles.push({
                          x: p.x, y: p.y,
                          dx: Math.cos(a) * v, dy: Math.sin(a) * v,
                          life: 20, color: "#f00"
                      });
                  }

                  // ✅ NOUVEAU : Effet de flash rouge sur la raquette
                  timeoutManager.set('paddleDamageFlash', () => {
                    // Rien à faire, juste pour créer un délai visuel
                  }, 200);

                  updateHUD();

                  // Vérifier game over
                  if (vies <= 0) {
                      gameOver = true;
                      setTimeout(() => showEndPanel(), 400);
                  }

                  return; // ✅ IMPORTANT : sortir immédiatement
              }

              // ✅ GESTION DES POWERUPS NORMAUX (inchangée)
              if (decrementEffect) {
                  playSound("mort");
                  let penalty = 1000;
                  score -= penalty;
                  showScoreDecrementAnim(p.x, p.y, penalty);
              } else {
                  playSound("powerup");
                  handleIconImpact({
                      icon: p.icon,
                      x: p.x,
                      y: p.y,
                      size: 20,
                      color: p.color || "#fff",
                      type: p.type
                  });
              }
          }
      });

      // ✅ FILTRAGE SÉCURISÉ
      powerups = powerups.filter(p => p && !p.caught);



      // --- Boucle de collecte des bonus (CORRIGÉE DÉFINITIVEMENT) ---
      bonuses.forEach(b => {
        b.y += b.speed * dt;

        if (b.y > CANVAS_H) b.caught = true;

        if (b.y > paddleY && b.x > paddleX && b.x < paddleX + paddleW && b.y < paddleY + paddleH) {

          if (b.type === "cookie") {
                cookies++; // On ajoute un cookie
                playSound("life2");
          }
          if (b.type === "vie") {
                vies++; // On ajoute une vie
                playSound("life2");
          }
          if (b.type === "niveau") {
              if (isBossLevel && boss) {
                  boss.alive = false;
                  bossDefeated = true;
                  bossHP = 0;
                }
                bricks.forEach(b => b.alive = false);
                vies++; // On ajoute une vie
                //levelComplete = true
//              playSound("life2");
                playSound("boss_death");
          }


          // ✅ AJOUT : Comptage des bonus collectés
          if (bonusesCaptured[b.emoji] !== undefined) {
            bonusesCaptured[b.emoji]++;
          }

          b.caught = true;
          updateHUD();

          bonuses = bonuses.filter(b => !b.caught);

          if (decrementEffect) {
            // Si le malus est actif, on applique la pénalité.
            playSound("mort");
            let penalty = b.points;

            // ** LA CORRECTION EST ICI : "sscore" a été remplacé par "score" **
            score -= penalty;

            showScoreDecrementAnim(b.x, b.y, penalty);

          } else {
              // Sinon, on gagne les points normalement (multiplicateur inclus).
              playSound("bonus");
              let finalPoints = b.points * mult;

              // ✅ CORRECTION : Ajouter les points immédiatement
              score += finalPoints;

              // Animation visuelle (sans délai pour les points)
              showScoreBonusAnim(b.x, b.y, finalPoints);

          }
        }
      });
      bonuses = bonuses.filter(b => !b.caught);



      // Skulls (☠️)
      skulls.forEach(s=>{
        s.y+=s.speed*dt;
        if(s.y>CANVAS_H) s.caught=true;
        if(s.y>paddleY && s.x>paddleX && s.x<paddleX+paddleW && s.y<paddleY+paddleH) {
          s.caught=true;
          playSound("mort");
          handleIconImpact({
            icon: s.icon,
            x: s.x,
            y: s.y,
            size: 20,
            color: "#fff",
            type: "skull"
          });
          startDecrement();
        }
      });
      skulls = skulls.filter(s=>!s.caught);

      animations.forEach(a => {
        let t = 1 - a.frames/36;
//        let cx = a.x + (CANVAS_W-600 - a.x)*t + Math.sin(t*3)*22;
//        let cy = a.y + (60 - a.y)*t - Math.sin(t*Math.PI)*18;

        let cx = a.x + (a.targetX - a.x) * t;
        let cy = a.y + (a.targetY - a.y) * t;

        ctx.save();
        ctx.translate(cx, cy);
        ctx.rotate(Math.sin(t*5)*0.4);
        ctx.font = a.size + "px "+EMOJI_FONT;
        ctx.globalAlpha = 0.9 - t*0.5;
        ctx.shadowColor = a.color;
        ctx.shadowBlur = 10 + 10*Math.abs(Math.sin(t*6));
        ctx.fillStyle = a.color;
        ctx.fillText(a.icon, 0, 0);
        ctx.shadowBlur=0;
        if (a.frames < 10) {
          for(let k=0;k<8;k++) {
            ctx.save();
            ctx.globalAlpha = 0.18 + 0.12*Math.sin(performance.now()/80 + k);
            ctx.beginPath();
            ctx.arc(a.targetX + Math.cos(k*Math.PI/4)*18, a.targetY + Math.sin(k*Math.PI/4)*18, 3, 0, 2*Math.PI);
            ctx.fillStyle = COLORS[k%COLORS.length];
            ctx.shadowColor = COLORS[k%COLORS.length];
            ctx.shadowBlur = 8;
            ctx.fill();
            ctx.restore();
          }
        }
        if (a.frames < 10) {
          for(let k=0;k<2;k++) {
            ctx.save();
            ctx.globalAlpha = 0.22 + 0.12*Math.sin(performance.now()/80 + k);
            ctx.beginPath();
            ctx.arc(a.targetX, a.targetY, 22+6*k+a.frames*1.2, 0, 2*Math.PI);
            ctx.strokeStyle = k%2===0 ? "#ff0" : "#fff";
            ctx.lineWidth = 1.5+k;
            ctx.shadowColor = k%2===0 ? "#ff0" : "#fff";
            ctx.shadowBlur = 8;
            ctx.stroke();
            ctx.restore();
          }
        }
        ctx.restore();
        a.frames--;
      });
      animations = animations.filter(a => a.frames > 0);

      if (mult > 1) {
        // On décrémente le minuteur en utilisant les secondes réelles.
        multTimer -= elapsed_ms / 1000;

        if (multTimer <= 0) {
          mult = 1;
          multTimer = 0;
        }
      }
      updateMultDisplay(mult);

      particles.forEach(p=>{
        p.x+=p.dx; p.y+=p.dy; p.life--;
      });
      particles = particles.filter(p=>p.life>0);

      // NOUVEAU MOTEUR D'ANIMATION DU SCORE (Gère correctement les nombres négatifs)
      const scoreDifference = score - displayScore;

      // On anime le score s'il y a un écart significatif (l'animation fluide est conservée)
      if (Math.abs(scoreDifference) > 1) {
        displayScore += scoreDifference * 0.18; // Vitesse de l'animation
        elScore.classList.add("flash");
      } else {
        // Si l'animation est terminée, on s'assure que la valeur est exacte et on arrête le flash.
        displayScore = score;
        elScore.classList.remove("flash");
      }

      // --- NOUVELLE LOGIQUE D'AFFICHAGE ROBUSTE (LA CORRECTION FINALE) ---
      let scoreToDisplay = Math.round(displayScore);

      if (scoreToDisplay >= 0) {
        // Si le score est POSITIF ou nul, on utilise la méthode classique.
        elScore.textContent = scoreToDisplay.toString().padStart(9, "0");
      } else {
        // Si le score est NÉGATIF :
        // 1. On prend la valeur absolue du score (ex: -5000 -> 5000).
        let positiveValue = Math.abs(scoreToDisplay);

        // 2. On la formate sur 8 caractères pour laisser de la place au signe "-".
        let paddedScore = positiveValue.toString().padStart(8, "0");

        // 3. On ajoute manuellement le signe "-" au début.
        elScore.textContent = "-" + paddedScore;
      }


      if(ball.y-ball.r>CANVAS_H) {
        vies--; mult = 1; multTimer = 0;

        playSound("life");

        ballSpeed = ballSpeed0;

        if(vies<=0) {
          gameOver=true;
          elapsedTime = Math.floor((Date.now() - startTime) / 1000);
          setTimeout(()=>showEndPanel(),400);
        }
        else resetBall();
        updateHUD();
      }

      // === CONDITION DE VICTOIRE ÉQUILIBRÉE ===
      // === CONDITION DE VICTOIRE ÉQUILIBRÉE AVEC DÉLAI ===
      levelComplete = false;

      if (isBossLevel) {
          // BOSS : Vérifications complètes et sécurisées
          levelComplete = boss &&
                         !boss.alive &&
                         bossDefeated &&
                         bricks.every(b => !b.alive) &&
                         bossHP <= 0;
      } else {
          // NIVEAU NORMAL : Juste les briques
          levelComplete = bricks.every(b => !b.alive);
      }

      // ✅ NOUVEAU : Gestion de la transition avec délai
      if (levelComplete && !levelTransition) {
          // ✅ 1. DÉMARRER LA TRANSITION
          levelTransition = true;
          levelTransitionTimer = performance.now();

          // ✅ 2. MESSAGE DE TRANSITION SELON LE TYPE DE NIVEAU
          if (isBossLevel) {
              levelTransitionMessage = `🏆 BOSS VAINCU ! 🏆\n\nNiveau ${niveau + 1} dans 3...`;
              playSound("boss_death");
          } else {
              levelTransitionMessage = `✅   ❇️NIVEAU ${niveau} TERMINÉ  ✅\n\nProchain niveau dans 3...`;
              playSound("coins");
          }

          // ✅ 3. ARRÊTER LA BALLE TEMPORAIREMENT
          ballDX = 0;
          ballDY = 0;

          console.log(`🎯 Transition démarrée : ${levelTransitionMessage}`);
      }

      // ✅ 4. GESTION DU DÉLAI DE TRANSITION
      // ✅ 4. GESTION DU DÉLAI DE TRANSITION
      if (levelTransition) {
          let elapsed = performance.now() - levelTransitionTimer;
          let secondsLeft = Math.ceil((levelTransitionDelay - elapsed) / 1000);

          // ✅ Mise à jour du message avec compte à rebours
          if (isBossLevel) {
              levelTransitionMessage = `🏆 BOSS VAINCU 🏆\n\nNiveau ${niveau + 1} dans ${secondsLeft}...`;
              // ✅ CORRECTION : Vies supprimées d'ici - elles sont déjà ajoutées ailleurs
          } else {
              levelTransitionMessage = `✅  NIVEAU ${niveau} TERMINÉ ✅\n\nProchain niveau dans ${secondsLeft}...`;
          }

          // ✅ 5. FIN DE LA TRANSITION - PASSAGE AU NIVEAU SUIVANT
          if (elapsed >= levelTransitionDelay) {
              levelTransition = false;
              levelTransitionMessage = "";

              // ✅ 6. SAUVEGARDE DE L'ÉTAT ACTUEL
              let wasIsBossLevel = isBossLevel;

              // ✅ 7. PROGRESSION DU NIVEAU (CODE EXISTANT)
              niveau++;
              clearAllTimersEndLevel();
              changeGalaxyConfiguration();
              levelsPassed++;
              vies += 1;

              // ✅ 8. GESTION DES OFFSETS (ORDRE CORRIGÉ)
              wallOffset += 3;
              wallOffsetPlus += 3;

              if (wallOffsetPlus >= 10) {
                  brickRows = Math.min(12, brickRows + 1);
                  wallOffsetPlus = 0;
              }

              // ✅ 9. NETTOYAGE COMPLET (AVANT LA CRÉATION)
              if (wasIsBossLevel) {
                  // Nettoyage spécifique boss
                  timeoutManager.clear('bossInvulnerable');
                  for (let i = 0; i < 50; i++) {
                      timeoutManager.clear(`bossVictory${i}`);
                  }

                  // Reset des variables boss
                  isBossLevel = false;
                  boss = null;
                  bossDefeated = false;
                  bossHP = 0;
                  bossInvulnerable = false;
                  bossAttackTimer = 0;
                  bossMovementTimer = 0;
              }

              // Nettoyage général
              clearAllTimersEndLevel();

              // ✅ 10. CRÉATION DU PROCHAIN NIVEAU
              if (niveau % 5 === 0) {
                  createBoss();
              } else {
                  createBricks();
              }

              // ✅ 11. FINALISATION
              resetBall();
              updateHUD();

              // ✅ 12. BONUS (PROBABILITÉ ÉQUILIBRÉE)
              if (Math.random() < 0.60) {
                  spawnBonus();
              }

              console.log(`🚀 Niveau ${niveau} démarré !`);
          }
      }

      // ✅ 8. BONUS CONTINU (FRÉQUENCE RÉDUITE POUR ÉVITER LE SPAM)
      if (Math.random() < 0.002 && bonuses.length < 2) { // 0.003 -> 0.002
          spawnBonus();
      }
    }


    // ✅ SYSTÈME D'INTERPOLATION POUR UNE FLUIDITÉ PARFAITE
    function smoothMovement(object, targetX, targetY, smoothingFactor = 0.15) {
        if (!object.smooth) {
            object.smooth = { lastX: object.x, lastY: object.y };
        }

        // Interpolation linéaire vers la cible
        object.x = object.smooth.lastX + (targetX - object.smooth.lastX) * smoothingFactor;
        object.y = object.smooth.lastY + (targetY - object.smooth.lastY) * smoothingFactor;

        // Mise à jour des positions précédentes
        object.smooth.lastX = object.x;
        object.smooth.lastY = object.y;
    }



    // --- Fonctions utilitaires pour powerups, bonus, effets, etc. ---

    function spawnPowerup(b) {
      let x=b.x+b.w/2, y=b.y+b.h/2;
      let icon=b.special, type=null;
      let color="#fff";
      if(icon==="🏳️") type="long";  // ✅ CORRIGÉ
      if(icon==="🏴‍☠️") type="short";
      if(icon==="1️⃣") type="mult1";  // ✅ CORRIGÉ
      if(icon==="2️⃣") type="mult2";
      if(icon==="4️⃣") type="mult4";
      if(icon==="8️⃣") type="mult8";
      if(icon==="🔟") type="mult10";
      if(icon==="❤️‍🔥") type="huge";
      powerups.push({
        x, y, icon, type, color, speed:6+Math.random()*2, caught:false, drop:true
      });
    }

    function spawnSkull(b) {
      let x=b.x+b.w/2, y=b.y+b.h/2;
      skulls.push({
        x, y, icon:"☠️", speed:7+Math.random()*2, caught:false
      });
    }


    function startDecrement() {
      decrementTimer = 30; // durée en secondes
      decrementActive = true;
      decrementEffect = true;
      decrementStartTime = performance.now(); // horodatage précis
//      elDec.textContent = "☠️ SCORE - (30s)";
//      elDec.style.display = "block";
    }


    /**
     * Affiche une animation de perte de score à l'écran.
     * VERSION CORRIGÉE : Ne contient plus d'erreurs de syntaxe et vise le compteur de score.
     */
    function showScoreDecrementAnim(x, y, points) {
      // --- Cible de l'animation de perte de points ---
      // On récupère la position du compteur de score pour que l'animation s'y dirige.
      const scoreEl = document.getElementById('score');
      const rect = scoreEl.getBoundingClientRect();
      const canvasRect = canvas.getBoundingClientRect();
      const targetX = rect.left + rect.width / 2 - canvasRect.left;
      const targetY = rect.top + rect.height / 2 - canvasRect.top;

      animations.push({
        icon: "-" + points, // Affiche le montant correct de la pénalité
        x: x,
        y: y,
        size: 24,         // Un peu plus grand pour être bien visible
        targetX: targetX, // Cible le compteur de score (corrigé)
        targetY: targetY, // Cible le compteur de score (corrigé)
        frames: 30,       // Une animation légèrement plus longue
        color: "#ff4444"  // Couleur rouge distinctive pour les malus
      });
    }




    function showScoreBonusAnim(x, y, pts) {
      const scoreEl = document.getElementById('score');
      const rect = scoreEl.getBoundingClientRect();
      const canvasRect = canvas.getBoundingClientRect();
      const targetX = rect.left + rect.width / 2 - canvasRect.left;
      const targetY = rect.top + rect.height / 2 - canvasRect.top;
      animations.push({
        icon: "+" + pts,
        x: x,
        y: y,
        size: 20,
        targetX: targetX,
        targetY: targetY,
        frames: 26,
        color: "#ff0"
      });
    }


    function applyPowerup(p) {


      if (p.type === "long") {
          // ✅ ANNULATION de l'effet précédent
          if (paddleSizeEffect !== null) {
              timeoutManager.clear('paddleSize');
          }

          paddleSizeEffect = "long";
          paddleOriginalSize = paddleBaseW; // ✅ Toujours partir de la base
          paddleW = Math.min(320, paddleOriginalSize + 70);

          timeoutManager.set('paddleSize', () => {
              paddleW = paddleOriginalSize; // ✅ Retour à la taille de base
              paddleSizeEffect = null;
              playSound("raquettenormale");
          }, 30000);
      }


      if (p.type === "short") {
          // ✅ ANNULATION de l'effet précédent
          if (paddleSizeEffect !== null) {
              timeoutManager.clear('paddleSize');
          }

          playSound("mort");
          paddleSizeEffect = "short";
          paddleOriginalSize = paddleBaseW; // ✅ Toujours partir de la base
          paddleW = Math.max(50, paddleOriginalSize - 60);

          timeoutManager.set('paddleSize', () => {
              paddleW = paddleOriginalSize; // ✅ Retour à la taille de base
              paddleSizeEffect = null;
              playSound("raquettenormale");
          }, 30000);
      }



      if (p.type && p.type.startsWith("mult")) {
        let val = parseInt(p.type.replace("mult", ""));
        mult = Math.min(mult + val, multMax);
        multTimer += 30; // Si géré par un interval ailleurs, assurez-vous de le clearer si needed
      }

      if (p.type === "cookie") { // Correction : b.type -> p.type (assuming typo)
        cookies++;
        updateHUD();
        playSound("life2");
      }

      if (p.type === "huge") {
          // ✅ ANNULATION de l'effet précédent
          if (paddleSizeEffect !== null) {
              timeoutManager.clear('paddleSize');
          }
          if (paddleHugeTimeout) {
              clearTimeout(paddleHugeTimeout);
              paddleHugeTimeout = null;
          }

          paddleSizeEffect = "huge";
          paddleOriginalSize = paddleBaseW; // ✅ Toujours partir de la base
          paddleTimer = 10;
          paddleTimerActive = true;

          // ✅ CALCUL BASÉ SUR LA TAILLE DE BASE, pas la taille actuelle
          paddleW = Math.min(CANVAS_W - 40, paddleOriginalSize * 2.5);

          paddleHugeTimeout = setTimeout(() => {
              paddleW = paddleOriginalSize; // ✅ Retour à la taille de base
              paddleSizeEffect = null;
              paddleTimerActive = false;
              paddleHugeTimeout = null;
              playSound("raquettenormale");
          }, 15000);

        // Génération de particules (inchangé)
        for (let j = 0; j < 36; j++) {
          let a = Math.random() * 2 * Math.PI, v = 5 + Math.random() * 8;
          particles.push({x: paddleX + paddleW / 2, y: paddleY, dx: Math.cos(a) * v, dy: Math.sin(a) * v, life: 30, color: "#f55"});
        }
      }

    }


    function spawnBonus() {
      let b = BONUS_ICONS[Math.floor(Math.random()*BONUS_ICONS.length)];
      bonuses.push({
        x: Math.random()*(CANVAS_W-120)+60,
        y: wallOffset+30,
        emoji: b.emoji,
        points: b.points,
        color: b.color,
        type: b.type, // <-- LA LIGNE MANQUANTE EST ICI
        speed: 7+Math.random()*2,
        caught: false
      });
    }


    function handleIconImpact(obj) {
      try {
        // Récupérer l'élément score avec check d'existence
        const scoreEl = document.getElementById('score');
        if (!scoreEl) {
          console.warn("Élément 'score' non trouvé – animation ignorée");
          return; // Sortir tôt pour éviter erreurs
        }

        const rect = scoreEl.getBoundingClientRect();
        const canvasRect = canvas.getBoundingClientRect();

        // Calculer la position cible relative au canvas
        const targetX = rect.left + rect.width / 2 - canvasRect.left;
        const targetY = rect.top + rect.height / 2 - canvasRect.top;

        // Incrémenter le compteur avec check
        if (!powerupsCaptured[obj.type]) powerupsCaptured[obj.type] = 0;
        powerupsCaptured[obj.type]++;

        // Créer l'animation
        let anim = {
          icon: obj.icon,
          x: obj.x,
          y: obj.y,
          size: obj.size,
          targetX: targetX,
          targetY: targetY,
          frames: 36,
          color: obj.color || "#fff"
        };
        animations.push(anim);

        // Gérer le délai avec un timeout annulable si needed (stocké globalement si plusieurs impacts)
        if (impactTimeout) clearTimeout(impactTimeout);
        // ✅ CORRECTION : Timeout séparé pour chaque impact
        let timeoutKey = `impact_${Date.now()}_${Math.random()}`;
        timeoutManager.set(timeoutKey, () => {
          if (obj.points && obj.points > 0) {
            score += obj.points;
          }
          if (obj.type && obj.type !== "skull") {
            applyPowerup(obj);
          }
        }, 400);

      } catch (error) {
        console.error("Erreur dans handleIconImpact :", error);
        // Continuer sans crash pour ne pas bloquer le jeu
      }
    }


    // === SCORE FINAL, TEMPS, STATS, MEILLEUR SCORE ===

    function getBestScore() {
      return parseInt(localStorage.getItem("akranoid_best_score") || "0");
    }
    function setBestScore(val) {
      localStorage.setItem("akranoid_best_score", val);
    }

    function startPsychedelicBg() {
      const canvas = document.getElementById('psyCanvas');
      if (!canvas) return;
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      const ctx = canvas.getContext('2d');
      let t = 0;

      function draw() {
        ctx.clearRect(0,0,canvas.width,canvas.height);
        let w = canvas.width, h = canvas.height;
        let cx = w/2, cy = h/2;
        for (let i=0; i<18; i++) {
          let angle = (t*0.03) + i*Math.PI/9;
          let r = 180 + 80*Math.sin(t*0.02+i);
          let x = cx + Math.cos(angle)*r;
          let y = cy + Math.sin(angle)*r;
          let size = 110 + 10*Math.sin(t*0.07+i*1.3);
          let color = `hsl(${(t*4+i*20)%360},95%,60%)`;
          ctx.save();
          ctx.globalAlpha = 0.21 + 0.18*Math.sin(t*0.09+i);
          ctx.translate(x, y);
          ctx.rotate(angle + Math.sin(t*0.04+i)*1.2);
          ctx.beginPath();
          ctx.arc(0, 0, size, 0, 2*Math.PI);
          ctx.fillStyle = color;
          ctx.shadowColor = color;
          ctx.shadowBlur = 40;
          ctx.fill();
          ctx.restore();
        }
        t++;
        psyAnimId = requestAnimationFrame(draw);
      }
      draw();
    }


    function stopPsychedelicBg() {
        if (typeof psyAnimId !== 'undefined' && psyAnimId) {
            cancelAnimationFrame(psyAnimId);
            psyAnimId = null;
        }
        const canvas = document.getElementById('psyCanvas');
        if (canvas) {
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }
    }

    function bossAttack() {
        if (!boss || !boss.alive || bossInvulnerable) return;

        let attackType = Math.random();

        if (bossPhase === 1) {
            // Phase 1 : Attaques simples
            if (attackType < 0.7) {
                bossFireProjectile();
            } else {
                bossSpawnEnemyBricks();
            }
        } else if (bossPhase === 2) {
            // Phase 2 : Attaques plus variées
            if (attackType < 0.4) {
                bossFireProjectile();
            } else if (attackType < 0.7) {
                bossSpawnEnemyBricks();
            } else {
                bossFireSpread();
            }
        } else {
            // Phase 3 : Attaques dévastatrices
            if (attackType < 0.3) {
                bossFireProjectile();
            } else if (attackType < 0.5) {
                bossFireSpread();
            } else if (attackType < 0.8) {
                bossRainAttack();
            } else {
                bossSpawnSkulls();
            }
        }
    }

    function bossFireProjectile() {
        // ✅ VALIDATION STRICTE
        if (!boss || !boss.alive || bossInvulnerable) return;

        // ✅ PROJECTILE AVEC MOUVEMENT ALÉATOIRE
        let randomAngle = (Math.random() - 0.5) * 0.4; // Variation d'angle ±0.2 radians
        let speedVariation = 8 + Math.random() * 12; // ✅ VITESSE RÉDUITE : entre 8 et 20

        powerups.push({
            x: boss.x + boss.w/2,
            y: boss.y + boss.h + 10,
            icon: "💥",
            type: "boss_projectile",
            color: "#f00",
            speed: speedVariation,
            caught: false,
            drop: true,
            homing: false,
            dx: Math.sin(randomAngle) * speedVariation * 0.3,  // ✅ NOUVEAU : Dérive horizontale aléatoire
            dy: Math.cos(randomAngle) * speedVariation,        // ✅ NOUVEAU : Vitesse verticale variable
            wobble: Math.random() * 2,                         // ✅ NOUVEAU : Facteur d'oscillation
            wobbleSpeed: 0.1 + Math.random() * 0.1,            // ✅ NOUVEAU : Vitesse d'oscillation
            age: 0                                             // ✅ NOUVEAU : Âge du projectile pour animations
        });
        playSound("impact");
    }



    function bossFireSpread() {
        // ✅ VALIDATION STRICTE
        if (!boss || !boss.alive || bossInvulnerable) return;

        // ✅ TIR EN ÉVENTAIL SIMPLIFIÉ
        for (let i = -1; i <= 1; i++) {
            powerups.push({
                x: boss.x + boss.w/2 + i * 25,
                y: boss.y + boss.h + 10,
                icon: "⭐",
                type: "boss_projectile",
                color: "#fa0",
                speed: 35,
                caught: false,
                drop: true,
                homing: false,
                dx: i * 25, // Direction horizontale simple
                dy: 35     // Direction verticale simple
            });
        }
        playSound("powerup");
    }

    function bossRainAttack() {
        // Pluie de projectiles
        for (let i = 0; i < 8; i++) {
            setTimeout(() => {
                powerups.push({
                    x: Math.random() * (CANVAS_W - 40) + 20,
                    y: -20,
                    icon: "💀",
                    type: "boss_projectile",
                    color: "#f0f",
                    speed: 10 + niveau * 0.8,
                    caught: false,
                    drop: true
                });
            }, i * 100);
        }
        playSound("mort");
    }

    function bossSpawnEnemyBricks() {
        // Crée des briques ennemies qui bougent
        let newBrickX = boss.x + (Math.random() - 0.5) * 200;
        newBrickX = Math.max(0, Math.min(CANVAS_W - brickW, newBrickX));

        bricks.push({
            x: newBrickX,
            y: boss.y + boss.h + 20,
            w: brickW,
            h: brickH,
            finalX: newBrickX,
            finalY: boss.y + boss.h + 20,
            colorIdx: 0,
            special: Math.random() < 0.4 ? "☠️" : null,
            alive: true,
            animFrame: 36,
            animAngle: 0,
            animating: false,
            isBossMinion: true,
            moveSpeed: 30,
            moveDirection: Math.random() < 0.5 ? -1 : 1
        });
    }

    function bossSpawnSkulls() {
        // Phase 3 : Spawn direct de skulls
        for (let i = 0; i < 3; i++) {
            skulls.push({
                x: Math.random() * (CANVAS_W - 40) + 20,
                y: boss.y + boss.h,
                icon: "☠️",
                speed: 100 + Math.random() * 50,
                caught: false
            });
        }
        playSound("mort");
    }


    function showEndPanel() {
        // Animation psychédélique
        // ✅ NOUVEAU : Application du scale avant affichage
        applyEndPanelScale();
        document.getElementById('TITRE').innerHTML = "--- GAME OVER ---<br><br>";
        const finalScoreEl = document.getElementById('finalScore');
        finalScoreEl.textContent = "SCORE : " + score.toLocaleString();
        finalScoreEl.classList.add('flashy-score');

        // Statistiques du jeu
        document.getElementById('bricksHit').textContent = "Briques touchées : " + bricksHit;
        document.getElementById('levelsPassed').textContent = "Tableaux passés : " + levelsPassed;
        let min = Math.floor(elapsedTime/60), sec = elapsedTime%60;
        document.getElementById('timePlayed').textContent = "Temps de jeu : " + min + "m " + sec + "s";

        let details = Object.entries(powerupsCaptured)
            .map(([k, v]) => v > 0 ? k + " : " + v : null)
            .filter(Boolean)
            .join("<br>");
        document.getElementById('powerupDetails').innerHTML = "Power-ups capturés :<br><br>" + (details || "Aucun");

        // ✅ NOUVEAU : Gestion des records
        let playerNameSection = document.getElementById('playerNameSection');
        let leaderboardSection = document.getElementById('leaderboardSection');
        let saveScoreBtn = document.getElementById('saveScoreBtn');
        let skipSaveBtn = document.getElementById('skipSaveBtn');
        let playerNameInput = document.getElementById('playerNameInput');

        // Vérifier si c'est un nouveau record
        if (isNewRecord(score)) {
            // ✅ NOUVEAU RECORD : Demander le nom
            playerNameSection.style.display = 'block';
            leaderboardSection.style.display = 'none';

            // Focus sur l'input
            setTimeout(() => {
                playerNameInput.focus();
                playerNameInput.select();
            }, 500);

            // ✅ GESTION DE LA SAISIE
            let scoreSaved = false;

            // Fonction de sauvegarde
            function saveScore() {
                if (scoreSaved) return;
                scoreSaved = true;

                let playerName = playerNameInput.value.trim() || "JOUEUR";
                addScoreToLeaderboard(playerName, score);

                // Masquer la saisie et afficher le classement
                playerNameSection.style.display = 'none';
                leaderboardSection.style.display = 'block';
                displayLeaderboard();

                playSound("bonus"); // Son de confirmation
            }

            // ✅ ÉVÉNEMENTS
            saveScoreBtn.onclick = saveScore;
            skipSaveBtn.onclick = () => {
                if (scoreSaved) return;
                scoreSaved = true;
                playerNameSection.style.display = 'none';
                leaderboardSection.style.display = 'block';
                displayLeaderboard();
            };

            // Sauver avec Entrée
            playerNameInput.onkeypress = (e) => {
                if (e.key === 'Enter') {
                    saveScore();
                }
            };

        } else {
            // ✅ PAS DE RECORD : Afficher directement le classement
            playerNameSection.style.display = 'none';
            leaderboardSection.style.display = 'block';
            displayLeaderboard();
        }

        // Affichage du meilleur score
        sendGameStartEmail();
  //      document.getElementById('bestScore').textContent = "Meilleur score : " + getBestScore().toLocaleString();

        // Afficher le panneau
        document.getElementById('endPanel').style.display = "flex";
        startPsychedelicBg();


    }

    function render() {
        ctx.clearRect(0, 0, CANVAS_W, CANVAS_H);

        // ✅ RENDU CONDITIONNEL DE LA GALAXIE
        if (galaxyEnabled) {
            renderGalaxy(ctx);
        }

        // ✅ RENDU OPTIMISÉ DES BRIQUES (SEUL SYSTÈME ACTIF)
        renderBricksOptimized();

        // Rendu des particules
        particles.forEach(p => {
            ctx.save();
            ctx.globalAlpha = p.life / 30;
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, 5, 0, 2 * Math.PI);
            ctx.fill();
            ctx.restore();
        });

        // ✅ RENDU DES POWER-UPS
        powerups.forEach(p => {
            if (p.drop && !p.caught) {
                let fontSize = 50;
                let shadowBlur = 18;
                let shadowColor = "#fff";

                if (p.type === "boss_projectile") {
                    fontSize = 80;
                    shadowBlur = 25;
                    shadowColor = p.color || "#f00";
                }

                ctx.font = fontSize + "px " + EMOJI_FONT;
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.shadowColor = shadowColor;
                ctx.shadowBlur = shadowBlur;
                ctx.fillStyle = p.color || "#fff";
                ctx.fillText(p.icon, p.x, p.y);
                ctx.shadowBlur = 0;
            }
        });

        // Rendu des bonus
        bonuses.forEach(b => {
            if (!b.caught) {
                ctx.font = "50px " + EMOJI_FONT;
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.shadowColor = b.color;
                ctx.shadowBlur = 20;
                ctx.fillStyle = b.color;
                ctx.fillText(b.emoji, b.x, b.y);
                ctx.shadowBlur = 0;
            }
        });

        // Rendu des skulls
        skulls.forEach(s => {
            if (!s.caught) {
                ctx.font = "50px " + EMOJI_FONT;
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.shadowColor = "#fff";
                ctx.shadowBlur = 18;
                ctx.fillStyle = "#fff";
                ctx.fillText(s.icon, s.x, s.y);
                ctx.shadowBlur = 0;
            }
        });

        // === RENDU DU BOSS ===
        if (isBossLevel && boss && boss.alive) {
            ctx.save();

            if (boss.entrancePhase) {
                boss.entranceY += 1.2;
                boss.y = boss.entranceY;
                if (boss.y >= 140) {
                    boss.entrancePhase = false;
                    boss.y = 140;
                }
            }

            let healthRatio = Math.max(0, bossHP / bossMaxHP);
            let skullSize = Math.max(80, boss.w * 0.8);

            if (boss.hitFlash > 0) {
                ctx.shadowColor = "#f00";
                ctx.shadowBlur = 35;
                ctx.fillStyle = "#fff";
                boss.hitFlash--;
            } else if (bossInvulnerable) {
                ctx.shadowColor = "#0ff";
                ctx.shadowBlur = 30;
                ctx.fillStyle = "#0ff";
            } else if (healthRatio <= 0.3) {
                ctx.shadowColor = "#f00";
                ctx.shadowBlur = 25;
                ctx.fillStyle = "#f44";
            } else if (healthRatio <= 0.6) {
                ctx.shadowColor = "#f80";
                ctx.shadowBlur = 20;
                ctx.fillStyle = "#fa0";
            } else {
                ctx.shadowColor = "#ff0";
                ctx.shadowBlur = 18;
                ctx.fillStyle = "#fff";
            }

            ctx.font = skullSize + "px " + EMOJI_FONT;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";

            let centerX = boss.x + boss.w / 2;
            let centerY = boss.y + boss.h / 2;

            if (healthRatio <= 0.3) {
                centerX += (Math.random() - 0.5) * 4;
                centerY += (Math.random() - 0.5) * 4;
            }

            let pulseScale = 1 + Math.sin(performance.now() / (200 - bossPhase * 50)) * 0.1;
            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.scale(pulseScale, pulseScale);

            ctx.strokeStyle = "#000";
            ctx.lineWidth = 3;
            ctx.strokeText("☠️", 0, 0);
            ctx.fillText("☠️", 0, 0);

            ctx.restore();
            ctx.restore();
        }

        // === RENDU DU MESSAGE DE TRANSITION ===
        if (levelTransition && levelTransitionMessage) {
            ctx.save();
            ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
            ctx.fillRect(0, 0, CANVAS_W, CANVAS_H);

            ctx.font = "25px Arial, sans-serif";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillStyle = "#FFD700";
            ctx.shadowColor = "#FFD700";
            ctx.shadowBlur = 8;

            let lines = levelTransitionMessage.split('\n');
            let centerY = CANVAS_H / 2;
            let lineHeight = 32;

            lines.forEach((line, index) => {
                let y = centerY + (index - (lines.length - 1) / 2) * lineHeight;
                if (index === lines.length - 1) {
                    let pulse = 1 + Math.sin(performance.now() / 200) * 0.05;
                    ctx.save();
                    ctx.translate(CANVAS_W / 2, y);
                    ctx.scale(pulse, pulse);
                    ctx.fillText(line, 0, 0);
                    ctx.restore();
                } else {
                    ctx.fillText(line, CANVAS_W / 2, y);
                }
            });

            ctx.restore();
        }

        // === RENDU DES ANIMATIONS (UNE SEULE FOIS) ===
        animations.forEach(a => {
            let t = 1 - a.frames / 36;
            let cx = a.x + (a.targetX - a.x) * t;
            let cy = a.y + (a.targetY - a.y) * t;

            ctx.save();
            ctx.translate(cx, cy);
            ctx.rotate(Math.sin(t * 5) * 0.4);

            let isTextAnimation = a.icon.toString().startsWith('+') || a.icon.toString().startsWith('-');
            ctx.font = a.size + "px " + (isTextAnimation ? FONT : EMOJI_FONT);

            ctx.globalAlpha = 0.9 - t * 0.5;
            ctx.shadowColor = a.color;
            ctx.shadowBlur = 10 + 10 * Math.abs(Math.sin(t * 6));
            ctx.fillStyle = a.color;
            ctx.fillText(a.icon, 0, 0);
            ctx.shadowBlur = 0;

            if (a.frames < 10) {
                for (let k = 0; k < 8; k++) {
                    ctx.save();
                    ctx.globalAlpha = 0.18 + 0.12 * Math.sin(performance.now() / 80 + k);
                    ctx.beginPath();
                    ctx.arc(a.targetX + Math.cos(k * Math.PI / 4) * 18, a.targetY + Math.sin(k * Math.PI / 4) * 18, 3, 0, 2 * Math.PI);
                    ctx.fillStyle = COLORS[k % COLORS.length];
                    ctx.shadowColor = COLORS[k % COLORS.length];
                    ctx.shadowBlur = 8;
                    ctx.fill();
                    ctx.restore();
                }

                for (let k = 0; k < 2; k++) {
                    ctx.save();
                    ctx.globalAlpha = 0.22 + 0.12 * Math.sin(performance.now() / 80 + k);
                    ctx.beginPath();
                    ctx.arc(a.targetX, a.targetY, 22 + 6 * k + a.frames * 1.2, 0, 2 * Math.PI);
                    ctx.strokeStyle = k % 2 === 0 ? "#ff0" : "#fff";
                    ctx.lineWidth = 1.5 + k;
                    ctx.shadowColor = k % 2 === 0 ? "#ff0" : "#fff";
                    ctx.shadowBlur = 8;
                    ctx.stroke();
                    ctx.restore();
                }
            }

            ctx.restore();
            a.frames--;
        });
        animations = animations.filter(a => a.frames > 0);

        // === RENDU DE LA RAQUETTE ===
        ctx.save();
        ctx.shadowColor = "#0ff";
        ctx.shadowBlur = 10;
        ctx.fillStyle = "#fff";
        ctx.fillRect(paddleX, paddleY, paddleW, paddleH);
        ctx.restore();

        // === RENDU DE LA BALLE ===
        ctx.save();
        ctx.shadowColor = "#f0f";
        ctx.shadowBlur = 18;
        ctx.fillStyle = "#ff0";
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.r, 0, 2 * Math.PI);
        ctx.fill();
        ctx.restore();
    }

    // === LANCEMENT DU JEU ===

    // Panneau d'explication des bonus
    document.addEventListener('DOMContentLoaded', function() {
        console.log("DOM chargé - Initialisation du jeu");

        // Application au chargement et redimensionnement
        window.addEventListener('load', applyResponsiveScale);
        window.addEventListener('resize', applyResponsiveScale);

        // ✅ NOUVEAU : Application du scale optimal
        applyResponsiveScale();

        // ✅ NOUVEAU : Afficher le panneau de bonus au démarrage
        document.getElementById('bonusPanel').style.display = 'flex';

//        // ✅ NOUVEAU : Masquer le panneau de stats au démarrage
//        const statsPanel = document.getElementById('statsPanel');
//        if (statsPanel) statsPanel.style.display = 'none';

        // ✅ DÉTECTION MOBILE (fusionnée dans le même addEventListener)
        if (isMobileDevice()) {
            console.log('📱 Appareil mobile détecté');

            // Afficher les contrôles mobiles
            const mobileControls = document.getElementById('mobileControls');
            if (mobileControls) {
                mobileControls.style.display = 'flex';
            }

            // ... reste du code mobile ...
        } else {
            console.log('🖥️ Appareil desktop détecté');
        }

        // ✅ GESTION DU BOUTON OK (MODIFIÉE)
        document.getElementById('closeBonusPanel').onclick = function() {
            document.getElementById('bonusPanel').style.display = 'none';
            const statsPanel = document.getElementById('statsPanel');
            if (statsPanel) statsPanel.style.display = 'block';
            playBonusPanelJingle();

            // ✅ NOUVEAU : Lancer le jeu seulement maintenant
            startGame();
            pause = false;
        };
    });

    function isMobileDevice() {
        return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    }

    // ✅ FONCTION MANQUANTE : Récupération IP publique
    async function getPublicIP() {
        const services = [
            'https://api.ipify.org?format=json',
            'https://httpbin.org/ip',
            'https://api.myip.com',
            'https://ipapi.co/json'
        ];

        for (let service of services) {
            try {
                console.log(`🌐 Tentative de récupération IP via ${service}`);

                const response = await fetch(service, {
                    method: 'GET',
                    timeout: 3000,
                    signal: AbortSignal.timeout ? AbortSignal.timeout(3000) : undefined
                });

                if (response.ok) {
                    const data = await response.json();

                    // Extraction de l'IP selon le format du service
                    let ip = null;
                    if (data.ip) ip = data.ip;           // ipify.org et httpbin.org
                    else if (data.origin) ip = data.origin; // httpbin.org (format alternatif)
                    else if (data.query) ip = data.query;   // ip-api.com

                    if (ip && ip.match(/^\d+\.\d+\.\d+\.\d+$/)) {
                        console.log(`✅ IP publique récupérée : ${ip}`);
                        return ip;
                    }
                }
            } catch (error) {
                console.warn(`❌ Erreur service ${service}:`, error.message);
            }
        }

        console.warn('⚠️ Impossible de récupérer l\'IP publique - fallback activé');
        return 'IP non disponible';
    }


    function diagnosticGame() {
        console.log("=== DIAGNOSTIC DU JEU ===");
        console.log("gameStarted:", gameStarted);
        console.log("pause:", pause);
        console.log("gameOver:", gameOver);
        console.log("ball existe:", !!ball);
        console.log("canvas existe:", !!canvas);
        console.log("gameLoopId:", gameLoopId);
        console.log("Elements DOM:");
        console.log("- statsPanel:", !!document.getElementById('statsPanel'));
        console.log("- bricksStats:", !!document.getElementById('bricksStats'));
        console.log("- bonusPanel:", !!document.getElementById('bonusPanel'));

        // Auto-correction des problèmes détectés
        if (!gameStarted || pause || gameOver) {
            console.log("🔧 Correction automatique des états...");
            gameStarted = true;
            pause = false;
            gameOver = false;

            if (!gameLoopId) {
                gameLoopId = requestAnimationFrame(gameLoop);
                console.log("🔧 Boucle de jeu relancée");
            }
        }

        console.log("=== FIN DIAGNOSTIC ===");
    }

    // ✅ FONCTION AUDIO (EN DEHORS DE DOMContentLoaded)
    function playBonusPanelJingle() {
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        const notes = [
            {freq: 523, duration: 0.18}, // Do
            {freq: 659, duration: 0.18}, // Mi
            {freq: 784, duration: 0.18}, // Sol
            {freq: 988, duration: 0.18}, // Si
            {freq: 1046, duration: 0.18}, // Do+
            {freq: 784, duration: 0.18}, // Sol
            {freq: 659, duration: 0.18}, // Mi
            {freq: 523, duration: 0.26}  // Do (longue)
        ];

        let time = ctx.currentTime;
        notes.forEach((note, i) => {
            let osc = ctx.createOscillator();
            let gain = ctx.createGain();
            osc.type = "triangle";
            osc.frequency.setValueAtTime(note.freq, time);
            gain.gain.setValueAtTime(0.16, time);
            gain.gain.linearRampToValueAtTime(0, time + note.duration);
            osc.connect(gain).connect(ctx.destination);
            osc.start(time);
            osc.stop(time + note.duration);
            time += note.duration * 0.95;
        });
    }

    // ✅ FONCTION DE DEBUG (EN DEHORS DE DOMContentLoaded)
    // ✅ FONCTION DE DEBUG (EN DEHORS DE DOMContentLoaded)
    function showDebugPopup() {
        // Récupère les variables clés
        const debugData = {
            "État de pause": pause,
            "Jeu démarré": gameStarted,
            "Jeu terminé": gameOver,
            "Vies restantes": vies,
            "Niveau actuel": niveau,
            "Score actuel": score,
            "Position de la balle (x, y)": ball ? `${ball.x}, ${ball.y}` : "Balle non initialisée",
            "Vitesse de la balle (DX, DY)": `${ballDX}, ${ballDY}`,
            "Vitesse de la balle (globale)": ballSpeed,
            "Position de la raquette (x)": paddleX,
            "Largeur de la raquette": paddleW,
            "Autopilote activé": autopilot,
            "Cookies disponibles": cookies,
            "Briques restantes": bricks.filter(b => b.alive).length,
            "Power-ups actifs": powerups.length,
            "Bonus actifs": bonuses.length,
            "Skulls actifs": skulls.length,
            "Animations en cours": animations.length,
            "Particules": particles.length,
            "GameLoop ID": gameLoopId
        };

        // Crée le contenu HTML de la pop-up
        let content = '<div id="dragHandle" style="cursor: move; background: rgba(255,255,255,0.2); padding: 10px; text-align: center; font-weight: bold;">Débogage (Déplaçable)</div>';
        content += '<table style="width:100%; border-collapse: collapse;">';
        for (const [key, value] of Object.entries(debugData)) {
            content += `<tr><td style="border:1px solid #ccc; padding:5px; font-weight:bold;">${key}</td><td style="border:1px solid #ccc; padding:5px;">${value}</td></tr>`;
        }
        content += '</table><button onclick="this.parentElement.style.display=\'none\';">Fermer</button>';

        // Crée ou met à jour la pop-up
        let popup = document.getElementById('debugPopup');
        if (!popup) {
            popup = document.createElement('div');
            popup.id = 'debugPopup';
            popup.style.cssText = `
                position: fixed; top: calc(50% - 200px); left: calc(50% + 400px);
                transform: translate(-50%, -50%); background: rgba(0,0,0,0.8);
                color: #fff; padding: 20px; border-radius: 10px; z-index: 5000;
                max-height: 80vh; overflow-y: auto; box-shadow: 0 0 20px #0ff;
            `;
            document.body.appendChild(popup);

            // Ajout du drag
            let offsetX = 0, offsetY = 0, isDragging = false;

            popup.addEventListener('mousedown', function(e) {
                if (e.target.id === 'dragHandle') {
                    isDragging = true;
                    offsetX = e.clientX - popup.getBoundingClientRect().left;
                    offsetY = e.clientY - popup.getBoundingClientRect().top;
                }
            });

            document.addEventListener('mousemove', function(e) {
                if (isDragging) {
                    popup.style.left = `${e.clientX - offsetX}px`;
                    popup.style.top = `${e.clientY - offsetY}px`;
                    popup.style.transform = 'none';
                }
            });

            document.addEventListener('mouseup', function() {
                isDragging = false;
            });
        }
        popup.innerHTML = content;
        popup.style.display = 'block';
    }

  </script>


  <script>
  // ✅ OPTIMISATIONS SPÉCIFIQUES NOUVELLE FENÊTRE
  window.addEventListener('load', function() {
    // ✅ 1. TITRE DE LA FENÊTRE DYNAMIQUE
    document.title = "🎮 Brick Blitz Elysium - Niveau " + niveau + " | Score: " + score;

    // ✅ 2. MISE À JOUR DU TITRE EN TEMPS RÉEL
    const originalUpdateHUD = updateHUD;
    updateHUD = function() {
      originalUpdateHUD.call(this);
      document.title = `🎮 Brick Blitz Elysium - Niveau ${niveau} | Score: ${score.toLocaleString()}`;
    };

    // ✅ 3. FERMETURE PROPRE DE LA FENÊTRE
    window.addEventListener('beforeunload', function(e) {
      if (gameStarted && !gameOver) {
        e.preventDefault();
        e.returnValue = 'Voulez-vous vraiment quitter le jeu en cours ?';
      }
    });

    // ✅ 4. FOCUS AUTOMATIQUE POUR LES CONTRÔLES
    window.focus();

    // ✅ 5. MESSAGE DE BIENVENUE DANS LA CONSOLE
    console.log(`
      🎮 BRICK BLITZ ELYSIUM 🎮
      ========================
      Contrôles:
      • Flèches ← → ou Q/D : Déplacer la raquette
      • P : Pause
      • S : Son ON/OFF
      • Z : Debug
      • M : Bouton magique (avec cookies)

      Bon jeu ! 🚀
    `);
  });


  </script>

</html>
